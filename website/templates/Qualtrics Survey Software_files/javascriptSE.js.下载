var QModules = {
  /** the base modules path */
  moduleBasePath: "/WRQualtricsShared/JavaScript/Modules/",
  /** the base path for any javascript that is not a module */
  basePath: "/",
  loadedModules: {},
  /** 'eval' - Evaluates module
   *  'script' - Places module code inside script tag
   *  'head' - Places a script tag into the head of the page and waits for it to load
   */
  loadType: "script",
  /**
   * QModules.loadModule
   * @param {String} path - can be just 'mymodule.js' in the Modules dir, or can be a full path to anything. eg. '/WRQualtricsShared/JavaScript/Modules/mymodule.js'
   * @param {function} options.onComplete - the function to call when the script has been loaded.
   * @param {function} options.asynchronous - if it loads the script asynchronously
   */
  loadModule: function(path, options2) {
    var defaultOptions = {
      method: "get",
      //must be get so it can be cached, posts prevent caching
      asynchronous: false,
      modulePath: path
      //this is so we can get the path inside our oncomplete without any additional closures.
    };
    if (options2 && options2.onComplete) {
      defaultOptions.asynchronous = true;
      options2.customOnComplete = options2.onComplete;
      options2.onComplete = null;
    }
    if (QModules.loadType == "script" || QModules.loadType == "head") {
      defaultOptions.evalJS = false;
    }
    defaultOptions.evalJS = false;
    options2 = Object.extend(defaultOptions, options2);
    options2.onComplete = QModules.onModuleLoad;
    var useVersion = options2.version || null;
    var parsedPath = options2.noParse && path || QModules.parsePath(path, useVersion);
    if (!QModules.loadedModules[path]) {
      if (options2.killCache) {
        var prefix = "?";
        if (parsedPath.indexOf("?") != -1) {
          prefix = "&";
        }
        parsedPath += prefix + "CacheKiller=" + Math.random();
      }
      if ((QModules.loadType == "head" || options2.loadType == "head") && (options2.customOnComplete || options2.asynchronous)) {
        var script = QBuilder("script", { src: parsedPath });
        script.onload = script.onreadystatechange = function(_, isAbort) {
          if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {
            script.onload = script.onreadystatechange = null;
            script = void 0;
            if (!isAbort) {
              QModules.moduledLoaded(options2);
            }
          }
        };
        document.head.appendChild(script);
      } else {
        var requestObj = new Ajax.Request(parsedPath, options2);
      }
    } else if (options2.customOnComplete) {
      options2.customOnComplete.defer();
    }
  },
  onModuleLoad: function(transport2) {
    if (transport2.status == 412 && !transport2.request.options.killCache) {
      transport2.request.options.killCache = true;
      QModules.loadModule(transport2.request.options.modulePath, transport2.request.options);
      return;
    }
    if (QModules.loadType == "script" || QModules.loadType == "head") {
      try {
        QModules.exec(transport2.responseText);
      } catch (e) {
        QES_Error("Error loading script module: " + e);
      }
    } else if (transport2.request.options.evalJS === false) {
      try {
        new Function(transport2.responseText)();
      } catch (e) {
        QES_Error("Error running module: " + e);
      }
    }
    if (transport2.status == 200) {
      QModules.moduledLoaded(transport2.request.options);
    }
  },
  /** Called after the module is completely loaded and evaluated */
  moduledLoaded: function(options2) {
    if (options2.modulePath) {
      QModules.loadedModules[options2.modulePath] = "loaded";
    }
    if (options2.customOnComplete) {
      try {
        options2.customOnComplete();
      } catch (e) {
        console.error(e);
      }
    }
  },
  /**
   * Dynamically Loads a stylesheet from Qualtrics/Product/StyleSheets/
   */
  loadStylesheet: function(path, options2) {
    options2 = options2 || {};
    var fullPath = "/WRQualtricsShared/Stylesheet.php?";
    if (path.indexOf("/") == -1) {
      fullPath += "p=ControlPanel&s=" + path;
    } else {
      fullPath += "sf=" + encodeURIComponent(path.split("?")[0]);
    }
    fullPath = QModules.getVersionedFile(fullPath, true);
    if (options2.blocking && !QModules.loadedModules[fullPath]) {
      QModules.loadedModules[fullPath] = "loaded";
      new Ajax.Request(fullPath, {
        method: "get",
        //so the browser caches it
        asynchronous: false,
        //this is what blocking means
        onComplete: QModules.onStylesheetLoad
      });
      return;
    }
    (function() {
      if (!QModules.loadedModules[fullPath]) {
        QModules.loadedModules[fullPath] = "loaded";
        var link = QBuilder("link", { rel: "stylesheet", type: "text/css", href: fullPath });
        document.getElementsByTagName("head")[0].appendChild(link);
      }
      if (options2.onLoad && options2.triggerClass) {
        var triggerElement = QBuilder("span", { className: options2.triggerClass });
        $(triggerElement).hide();
        document.body.appendChild(triggerElement);
        new PeriodicalExecuter(function(pe) {
          var color = $(triggerElement).getStyle("color");
          if (color == "#abcdef" || color == "rgb(171, 205, 239)") {
            pe.stop();
            options2.onLoad(path, options2.triggerClass);
          }
        }, 0.2);
      }
    }).defer();
  },
  onStylesheetLoad: function(transport2) {
    QModules.loadedModules[transport2.request.url] = "loaded";
    var style = QBuilder("style", { type: "text/css" });
    if (style.styleSheet) {
      style.styleSheet.cssText = transport2.responseText;
    } else {
      style.appendChild(document.createTextNode(transport2.responseText));
    }
    document.getElementsByTagName("head")[0].appendChild(style);
  },
  /**
   * exec is experimental and doesnt work in ie6
   */
  exec: function(code) {
    if ((code += "").blank())
      return;
    var script, scriptId;
    var head = $$("head").first() || $(document.documentElement);
    if (document.loaded) {
      try {
        script = new Element("script", { type: "text/javascript" });
        try {
          script.appendChild(document.createTextNode(code));
        } catch (e) {
          script.text = code;
        }
        head.insert(script);
      } catch (e) {
        console.error(e);
      }
    } else {
      scriptId = "__prototype_exec_script";
      document.write('<script id="' + scriptId + '" type="text/javascript">' + code + "<\/script>");
      script = $(scriptId);
    }
    script.remove();
  },
  loadExternalModule: function(path, callback) {
    var head = $$("head").first() || $(document.documentElement);
    var script = new Element("script", { type: "text/javascript", src: path });
    if (callback) {
      if (script.onreadystatechange !== void 0) {
        script.onreadystatechange = function() {
          if (this.readyState == "loaded" || this.readyState == "complete") {
            callback();
          }
        };
      } else {
        Event.observe(script, "load", callback);
      }
    }
    head.insert(script);
  },
  /** returns true if loaded false if it isn't.
   * @return {bool} true if it has been included
   */
  isLoaded: function(path) {
    if (!QModules.loadedModules[path])
      return false;
    else
      return true;
  },
  /**
   * If you preloaded a module using other means, call this function to let QModules know not
   * to try loading it again.
   *
   * @param array modules array of paths to mark as loaded
   */
  markModulesLoaded: function(modules) {
    for (var i2 = 0, len2 = modules.length; i2 < len2; ++i2) {
      QModules.loadedModules[modules[i2]] = "loaded";
    }
  },
  parsePath: function(path, useVersion) {
    path = QModules.getVersionedFile(path, false, useVersion);
    if (path.indexOf("http") === 0) {
      QModules.loadType = "script";
      return path;
    }
    if (path.indexOf("./") == 0) {
      path = QModules.moduleBasePath + path.substr(2);
    } else if (path.search("/") == -1) {
      path = QModules.moduleBasePath + path;
    } else if (path.indexOf("/") !== 0) {
      path = QModules.basePath + path;
    }
    return path;
  },
  /**
   * QModules.unload
   * if you manually clear out your module to clear up memory
   * then you will need to unload the module so it gets loaded again when requested.
   * SurveyFlow does this.
   */
  unload: function(path) {
    if (QModules.loadedModules[path]) {
      delete QModules.loadedModules[path];
    }
  },
  /** Returns the file versioned appropriately.
   * @param {string} file The file to be versioned.
   * @param {Boolean} forceParamVersioning - if true will not put the version in the filename but just at a url get param with the version
   * @return {string} the versioned file.
   */
  getVersionedFile: function(file, forceParamVersioning, useVersion) {
    var isModule = file.indexOf(QModules.moduleBasePath) !== -1 || file.indexOf("/") === -1;
    var isReportingModule = isModule && file.indexOf(QModules.moduleBasePath + "Reporting/") !== -1;
    var useVersion = useVersion || window.serviceVersion || window.qVersion || void 0;
    if (isModule && !isReportingModule) {
      useVersion = window.staticVersion || window.qVersion || void 0;
    }
    if (typeof useVersion != "undefined") {
      var matches = file.match(/(.*)\.(js|css|jpg|gif|png)$/i);
      if (!useVersion) {
        useVersion = 0;
      }
      if (matches && !forceParamVersioning) {
        return matches[1] + "." + useVersion + "." + matches[2];
      } else {
        var prefix = "?";
        if (file.indexOf("?") != -1) {
          prefix = "&";
        }
        return file + prefix + "v=" + useVersion;
      }
    } else
      return file;
  }
};
var Builder = {
  NODEMAP: {
    AREA: "map",
    CAPTION: "table",
    COL: "table",
    COLGROUP: "table",
    LEGEND: "fieldset",
    OPTGROUP: "select",
    OPTION: "select",
    PARAM: "object",
    TBODY: "table",
    TD: "table",
    TFOOT: "table",
    TH: "table",
    THEAD: "table",
    TR: "table"
  },
  // note: For Firefox < 1.5, OPTION and OPTGROUP tags are currently broken,
  //       due to a Firefox bug
  node: function(elementName) {
    elementName = elementName.toUpperCase();
    var parentTag = this.NODEMAP[elementName] || "div";
    var parentElement = document.createElement(parentTag);
    try {
      parentElement.innerHTML = "<" + elementName + "></" + elementName + ">";
    } catch (e) {
    }
    var element = parentElement.firstChild || null;
    if (element && element.tagName.toUpperCase() != elementName)
      element = element.getElementsByTagName(elementName)[0];
    if (!element)
      element = document.createElement(elementName);
    if (!element)
      return;
    if (arguments[1])
      if (this._isStringOrNumber(arguments[1]) || arguments[1] instanceof Array || arguments[1].tagName) {
        this._children(element, arguments[1]);
      } else {
        var attrs = this._attributes(arguments[1]);
        if (attrs.length) {
          try {
            parentElement.innerHTML = "<" + elementName + " " + attrs + "></" + elementName + ">";
          } catch (e) {
          }
          element = parentElement.firstChild || null;
          if (!element) {
            element = document.createElement(elementName);
            for (attr in arguments[1])
              element[attr == "class" ? "className" : attr] = arguments[1][attr];
          }
          if (element.tagName.toUpperCase() != elementName)
            element = parentElement.getElementsByTagName(elementName)[0];
        }
      }
    if (arguments[2])
      this._children(element, arguments[2]);
    return $(element);
  },
  _text: function(text) {
    return document.createTextNode(text);
  },
  ATTR_MAP: {
    "className": "class",
    "htmlFor": "for"
  },
  _attributes: function(attributes) {
    var attrs = [];
    for (attribute in attributes)
      attrs.push((attribute in this.ATTR_MAP ? this.ATTR_MAP[attribute] : attribute) + '="' + attributes[attribute].toString().escapeHTML().gsub(/"/, "&quot;") + '"');
    return attrs.join(" ");
  },
  _children: function(element, children) {
    if (children.tagName) {
      element.appendChild(children);
      return;
    }
    if (typeof children == "object") {
      children.flatten().each(function(e) {
        if (typeof e == "object")
          element.appendChild(e);
        else if (Builder._isStringOrNumber(e))
          element.appendChild(Builder._text(e));
      });
    } else if (Builder._isStringOrNumber(children))
      element.appendChild(Builder._text(children));
  },
  _isStringOrNumber: function(param) {
    return typeof param == "string" || typeof param == "number";
  },
  build: function(html) {
    var element = this.node("div");
    $(element).update(html.strip());
    return element.down();
  },
  dump: function(scope) {
    if (typeof scope != "object" && typeof scope != "function")
      scope = window;
    var tags = "A ABBR ACRONYM ADDRESS APPLET AREA B BASE BASEFONT BDO BIG BLOCKQUOTE BODY BR BUTTON CAPTION CENTER CITE CODE COL COLGROUP DD DEL DFN DIR DIV DL DT EM FIELDSET FONT FORM FRAME FRAMESET H1 H2 H3 H4 H5 H6 HEAD HR HTML I IFRAME IMG INPUT INS ISINDEX KBD LABEL LEGEND LI LINK MAP MENU META NOFRAMES NOSCRIPT OBJECT OL OPTGROUP OPTION P PARAM PRE Q S SAMP SCRIPT SELECT SMALL SPAN STRIKE STRONG STYLE SUB SUP TABLE TBODY TD TEXTAREA TFOOT TH THEAD TITLE TR TT U UL VAR".split(/\s+/);
    tags.each(function(tag) {
      scope[tag] = function() {
        return Builder.node.apply(Builder, [tag].concat($A(arguments)));
      };
    });
  }
};
String.prototype.parseColor = function() {
  var color = "#";
  if (this.slice(0, 4) == "rgb(") {
    var cols = this.slice(4, this.length - 1).split(",");
    var i2 = 0;
    do {
      color += parseInt(cols[i2]).toColorPart();
    } while (++i2 < 3);
  } else {
    if (this.slice(0, 1) == "#") {
      if (this.length == 4)
        for (var i2 = 1; i2 < 4; i2++)
          color += (this.charAt(i2) + this.charAt(i2)).toLowerCase();
      if (this.length == 7)
        color = this.toLowerCase();
    }
  }
  return color.length == 7 ? color : arguments[0] || this;
};
Element.collectTextNodes = function(element) {
  return $A($(element).childNodes).collect(function(node) {
    return node.nodeType == 3 ? node.nodeValue : node.hasChildNodes() ? Element.collectTextNodes(node) : "";
  }).flatten().join("");
};
Element.collectTextNodesIgnoreClass = function(element, className) {
  return $A($(element).childNodes).collect(function(node) {
    return node.nodeType == 3 ? node.nodeValue : node.hasChildNodes() && !Element.hasClassName(node, className) ? Element.collectTextNodesIgnoreClass(node, className) : "";
  }).flatten().join("");
};
Element.setContentZoom = function(element, percent) {
  element = $(element);
  element.setStyle({ fontSize: percent / 100 + "em" });
  if (Prototype.Browser.WebKit)
    window.scrollBy(0, 0);
  return element;
};
Element.getInlineOpacity = function(element) {
  return $(element).style.opacity || "";
};
Element.forceRerendering = function(element) {
  try {
    element = $(element);
    var n = document.createTextNode(" ");
    element.appendChild(n);
    element.removeChild(n);
  } catch (e) {
  }
};
var Effect = {
  _elementDoesNotExistError: {
    name: "ElementDoesNotExistError",
    message: "The specified DOM element does not exist, but is required for this effect to operate"
  },
  Transitions: {
    linear: Prototype.K,
    sinoidal: function(pos) {
      return -Math.cos(pos * Math.PI) / 2 + 0.5;
    },
    reverse: function(pos) {
      return 1 - pos;
    },
    flicker: function(pos) {
      var pos = -Math.cos(pos * Math.PI) / 4 + 0.75 + Math.random() / 4;
      return pos > 1 ? 1 : pos;
    },
    wobble: function(pos) {
      return -Math.cos(pos * Math.PI * (9 * pos)) / 2 + 0.5;
    },
    pulse: function(pos, pulses) {
      return -Math.cos(pos * ((pulses || 5) - 0.5) * 2 * Math.PI) / 2 + 0.5;
    },
    spring: function(pos) {
      return 1 - Math.cos(pos * 4.5 * Math.PI) * Math.exp(-pos * 6);
    },
    none: function(pos) {
      return 0;
    },
    full: function(pos) {
      return 1;
    }
  },
  DefaultOptions: {
    duration: 1,
    // seconds
    fps: 100,
    // 100= assume 66fps max.
    sync: false,
    // true for combining
    from: 0,
    to: 1,
    delay: 0,
    queue: "parallel"
  },
  tagifyText: function(element) {
    var tagifyStyle = "position:relative";
    if (Prototype.Browser.IE)
      tagifyStyle += ";zoom:1";
    element = $(element);
    $A(element.childNodes).each(function(child) {
      if (child.nodeType == 3) {
        child.nodeValue.toArray().each(function(character) {
          element.insertBefore(
            new Element("span", { style: tagifyStyle }).update(
              character == " " ? String.fromCharCode(160) : character
            ),
            child
          );
        });
        Element.remove(child);
      }
    });
  },
  multiple: function(element, effect) {
    var elements;
    if ((typeof element == "object" || Object.isFunction(element)) && element.length)
      elements = element;
    else
      elements = $(element).childNodes;
    var options2 = Object.extend({
      speed: 0.1,
      delay: 0
    }, arguments[2] || {});
    var masterDelay = options2.delay;
    $A(elements).each(function(element2, index) {
      new effect(element2, Object.extend(options2, { delay: index * options2.speed + masterDelay }));
    });
  },
  PAIRS: {
    "slide": ["SlideDown", "SlideUp"],
    "blind": ["BlindDown", "BlindUp"],
    "appear": ["Appear", "Fade"]
  },
  toggle: function(element, effect, options2) {
    element = $(element);
    effect = (effect || "appear").toLowerCase();
    return Effect[Effect.PAIRS[effect][element.visible() ? 1 : 0]](element, Object.extend({
      queue: { position: "end", scope: element.id || "global", limit: 1 }
    }, options2 || {}));
  }
};
Effect.DefaultOptions.transition = Effect.Transitions.sinoidal;
Effect.ScopedQueue = Class.create(Enumerable, {
  initialize: function() {
    this.effects = [];
    this.interval = null;
  },
  _each: function(iterator) {
    this.effects._each(iterator);
  },
  add: function(effect) {
    var timestamp = (/* @__PURE__ */ new Date()).getTime();
    var position = Object.isString(effect.options.queue) ? effect.options.queue : effect.options.queue.position;
    switch (position) {
      case "front":
        this.effects.findAll(function(e) {
          return e.state == "idle";
        }).each(function(e) {
          e.startOn += effect.finishOn;
          e.finishOn += effect.finishOn;
        });
        break;
      case "with-last":
        timestamp = this.effects.pluck("startOn").max() || timestamp;
        break;
      case "end":
        timestamp = this.effects.pluck("finishOn").max() || timestamp;
        break;
    }
    effect.startOn += timestamp;
    effect.finishOn += timestamp;
    if (!effect.options.queue.limit || this.effects.length < effect.options.queue.limit)
      this.effects.push(effect);
    if (!this.interval)
      this.interval = setInterval(this.loop.bind(this), 15);
  },
  remove: function(effect) {
    this.effects = this.effects.reject(function(e) {
      return e == effect;
    });
    if (this.effects.length == 0) {
      clearInterval(this.interval);
      this.interval = null;
    }
  },
  loop: function() {
    var timePos = (/* @__PURE__ */ new Date()).getTime();
    for (var i2 = 0, len2 = this.effects.length; i2 < len2; i2++)
      this.effects[i2] && this.effects[i2].loop(timePos);
  }
});
Effect.Queues = {
  instances: $H(),
  get: function(queueName) {
    if (!Object.isString(queueName))
      return queueName;
    return this.instances.get(queueName) || this.instances.set(queueName, new Effect.ScopedQueue());
  }
};
Effect.Queue = Effect.Queues.get("global");
Effect.Base = Class.create({
  position: null,
  start: function(options2) {
    if (options2 && options2.transition === false)
      options2.transition = Effect.Transitions.linear;
    this.options = Object.extend(Object.extend({}, Effect.DefaultOptions), options2 || {});
    this.currentFrame = 0;
    this.state = "idle";
    this.startOn = this.options.delay * 1e3;
    this.finishOn = this.startOn + this.options.duration * 1e3;
    this.fromToDelta = this.options.to - this.options.from;
    this.totalTime = this.finishOn - this.startOn;
    this.totalFrames = this.options.fps * this.options.duration;
    this.render = function() {
      function dispatch(effect, eventName) {
        if (effect.options[eventName + "Internal"])
          effect.options[eventName + "Internal"](effect);
        if (effect.options[eventName])
          effect.options[eventName](effect);
      }
      return function(pos) {
        if (this.state === "idle") {
          this.state = "running";
          dispatch(this, "beforeSetup");
          if (this.setup)
            this.setup();
          dispatch(this, "afterSetup");
        }
        if (this.state === "running") {
          pos = this.options.transition(pos) * this.fromToDelta + this.options.from;
          this.position = pos;
          dispatch(this, "beforeUpdate");
          if (this.update)
            this.update(pos);
          dispatch(this, "afterUpdate");
        }
      };
    }();
    this.event("beforeStart");
    if (!this.options.sync)
      Effect.Queues.get(Object.isString(this.options.queue) ? "global" : this.options.queue.scope).add(this);
  },
  loop: function(timePos) {
    if (timePos >= this.startOn) {
      if (timePos >= this.finishOn) {
        this.render(1);
        this.cancel();
        this.event("beforeFinish");
        if (this.finish)
          this.finish();
        this.event("afterFinish");
        return;
      }
      var pos = (timePos - this.startOn) / this.totalTime, frame = (pos * this.totalFrames).round();
      if (frame > this.currentFrame) {
        this.render(pos);
        this.currentFrame = frame;
      }
    }
  },
  cancel: function() {
    if (!this.options.sync)
      Effect.Queues.get(Object.isString(this.options.queue) ? "global" : this.options.queue.scope).remove(this);
    this.state = "finished";
  },
  event: function(eventName) {
    if (this.options[eventName + "Internal"])
      this.options[eventName + "Internal"](this);
    if (this.options[eventName])
      this.options[eventName](this);
  },
  inspect: function() {
    var data = $H();
    for (property in this)
      if (!Object.isFunction(this[property]))
        data.set(property, this[property]);
    return "#<Effect:" + data.inspect() + ",options:" + $H(this.options).inspect() + ">";
  }
});
Effect.Parallel = Class.create(Effect.Base, {
  initialize: function(effects) {
    this.effects = effects || [];
    this.start(arguments[1]);
  },
  update: function(position) {
    this.effects.invoke("render", position);
  },
  finish: function(position) {
    this.effects.each(function(effect) {
      effect.render(1);
      effect.cancel();
      effect.event("beforeFinish");
      if (effect.finish)
        effect.finish(position);
      effect.event("afterFinish");
    });
  }
});
Effect.Tween = Class.create(Effect.Base, {
  initialize: function(object, from, to) {
    object = Object.isString(object) ? $(object) : object;
    var args = $A(arguments), method = args.last(), options2 = args.length == 5 ? args[3] : null;
    this.method = Object.isFunction(method) ? method.bind(object) : Object.isFunction(object[method]) ? object[method].bind(object) : function(value) {
      object[method] = value;
    };
    this.start(Object.extend({ from: from, to: to }, options2 || {}));
  },
  update: function(position) {
    this.method(position);
  }
});
Effect.Event = Class.create(Effect.Base, {
  initialize: function() {
    this.start(Object.extend({ duration: 0 }, arguments[0] || {}));
  },
  update: Prototype.emptyFunction
});
Effect.Opacity = Class.create(Effect.Base, {
  initialize: function(element) {
    this.element = $(element);
    if (!this.element)
      throw Effect._elementDoesNotExistError;
    if (Prototype.Browser.IE && !this.element.currentStyle.hasLayout)
      this.element.setStyle({ zoom: 1 });
    var options2 = Object.extend({
      from: this.element.getOpacity() || 0,
      to: 1
    }, arguments[1] || {});
    this.start(options2);
  },
  update: function(position) {
    this.element.setOpacity(position);
  }
});
Effect.Move = Class.create(Effect.Base, {
  initialize: function(element) {
    this.element = $(element);
    if (!this.element)
      throw Effect._elementDoesNotExistError;
    var options2 = Object.extend({
      x: 0,
      y: 0,
      mode: "relative"
    }, arguments[1] || {});
    this.start(options2);
  },
  setup: function() {
    this.element.makePositioned();
    this.originalLeft = parseFloat(this.element.getStyle("left") || "0");
    this.originalTop = parseFloat(this.element.getStyle("top") || "0");
    if (this.options.mode == "absolute") {
      this.options.x = this.options.x - this.originalLeft;
      this.options.y = this.options.y - this.originalTop;
    }
  },
  update: function(position) {
    this.element.setStyle({
      left: (this.options.x * position + this.originalLeft).round() + "px",
      top: (this.options.y * position + this.originalTop).round() + "px"
    });
  }
});
Effect.MoveBy = function(element, toTop, toLeft) {
  return new Effect.Move(
    element,
    Object.extend({ x: toLeft, y: toTop }, arguments[3] || {})
  );
};
Effect.Scale = Class.create(Effect.Base, {
  initialize: function(element, percent) {
    this.element = $(element);
    if (!this.element)
      throw Effect._elementDoesNotExistError;
    var options2 = Object.extend({
      scaleX: true,
      scaleY: true,
      scaleContent: true,
      scaleFromCenter: false,
      scaleMode: "box",
      // 'box' or 'contents' or { } with provided values
      scaleFrom: 100,
      scaleTo: percent
    }, arguments[2] || {});
    this.start(options2);
  },
  setup: function() {
    this.restoreAfterFinish = this.options.restoreAfterFinish || false;
    this.elementPositioning = this.element.getStyle("position");
    this.originalStyle = {};
    ["top", "left", "width", "height", "fontSize"].each(function(k) {
      this.originalStyle[k] = this.element.style[k];
    }.bind(this));
    this.originalTop = this.element.offsetTop;
    this.originalLeft = this.element.offsetLeft;
    var fontSize = this.element.getStyle("font-size") || "100%";
    ["em", "px", "%", "pt"].each(function(fontSizeType) {
      if (fontSize.indexOf(fontSizeType) > 0) {
        this.fontSize = parseFloat(fontSize);
        this.fontSizeType = fontSizeType;
      }
    }.bind(this));
    this.factor = (this.options.scaleTo - this.options.scaleFrom) / 100;
    this.dims = null;
    if (this.options.scaleMode == "box")
      this.dims = [this.element.offsetHeight, this.element.offsetWidth];
    if (/^content/.test(this.options.scaleMode))
      this.dims = [this.element.scrollHeight, this.element.scrollWidth];
    if (!this.dims)
      this.dims = [
        this.options.scaleMode.originalHeight,
        this.options.scaleMode.originalWidth
      ];
  },
  update: function(position) {
    var currentScale = this.options.scaleFrom / 100 + this.factor * position;
    if (this.options.scaleContent && this.fontSize)
      this.element.setStyle({ fontSize: this.fontSize * currentScale + this.fontSizeType });
    this.setDimensions(this.dims[0] * currentScale, this.dims[1] * currentScale);
  },
  finish: function(position) {
    if (this.restoreAfterFinish)
      this.element.setStyle(this.originalStyle);
  },
  setDimensions: function(height2, width2) {
    var d = {};
    if (this.options.scaleX)
      d.width = width2.round() + "px";
    if (this.options.scaleY)
      d.height = height2.round() + "px";
    if (this.options.scaleFromCenter) {
      var topd = (height2 - this.dims[0]) / 2;
      var leftd = (width2 - this.dims[1]) / 2;
      if (this.elementPositioning == "absolute") {
        if (this.options.scaleY)
          d.top = this.originalTop - topd + "px";
        if (this.options.scaleX)
          d.left = this.originalLeft - leftd + "px";
      } else {
        if (this.options.scaleY)
          d.top = -topd + "px";
        if (this.options.scaleX)
          d.left = -leftd + "px";
      }
    }
    this.element.setStyle(d);
  }
});
Effect.Highlight = Class.create(Effect.Base, {
  initialize: function(element) {
    this.element = $(element);
    if (!this.element)
      throw Effect._elementDoesNotExistError;
    var options2 = Object.extend({ startcolor: "#ffff99" }, arguments[1] || {});
    this.start(options2);
  },
  setup: function() {
    if (this.element.getStyle("display") == "none") {
      this.cancel();
      return;
    }
    this.oldStyle = {};
    if (!this.options.keepBackgroundImage) {
      this.oldStyle.backgroundImage = this.element.getStyle("background-image");
      this.element.setStyle({ backgroundImage: "none" });
    }
    if (!this.options.endcolor)
      this.options.endcolor = this.element.getStyle("background-color").parseColor("#ffffff");
    if (!this.options.restorecolor)
      this.options.restorecolor = this.element.getStyle("background-color");
    this._base = $R(0, 2).map(function(i2) {
      return parseInt(this.options.startcolor.slice(i2 * 2 + 1, i2 * 2 + 3), 16);
    }.bind(this));
    this._delta = $R(0, 2).map(function(i2) {
      return parseInt(this.options.endcolor.slice(i2 * 2 + 1, i2 * 2 + 3), 16) - this._base[i2];
    }.bind(this));
  },
  update: function(position) {
    this.element.setStyle({ backgroundColor: $R(0, 2).inject("#", function(m, v, i2) {
      return m + (this._base[i2] + this._delta[i2] * position).round().toColorPart();
    }.bind(this)) });
  },
  finish: function() {
    this.element.setStyle(Object.extend(this.oldStyle, {
      backgroundColor: this.options.restorecolor
    }));
  }
});
Effect.ScrollTo = function(element) {
  var options2 = arguments[1] || {}, scrollOffsets = document.viewport.getScrollOffsets(), elementOffsets = $(element).cumulativeOffset();
  if (options2.offset)
    elementOffsets[1] += options2.offset;
  return new Effect.Tween(
    null,
    scrollOffsets.top,
    elementOffsets[1],
    options2,
    function(p) {
      scrollTo(scrollOffsets.left, p.round());
    }
  );
};
Effect.Fade = function(element) {
  element = $(element);
  var oldOpacity = element.getInlineOpacity();
  var options2 = Object.extend({
    from: element.getOpacity() || 1,
    to: 0,
    afterFinishInternal: function(effect) {
      if (effect.options.to != 0)
        return;
      effect.element.hide().setStyle({ opacity: oldOpacity });
    }
  }, arguments[1] || {});
  return new Effect.Opacity(element, options2);
};
Effect.Appear = function(element) {
  element = $(element);
  var options2 = Object.extend({
    from: element.getStyle("display") == "none" ? 0 : element.getOpacity() || 0,
    to: 1,
    // force Safari to render floated elements properly
    afterFinishInternal: function(effect) {
      effect.element.forceRerendering();
    },
    beforeSetup: function(effect) {
      effect.element.setOpacity(effect.options.from).show();
    }
  }, arguments[1] || {});
  return new Effect.Opacity(element, options2);
};
Effect.Puff = function(element) {
  element = $(element);
  var oldStyle = {
    opacity: element.getInlineOpacity(),
    position: element.getStyle("position"),
    top: element.style.top,
    left: element.style.left,
    width: element.style.width,
    height: element.style.height
  };
  return new Effect.Parallel(
    [
      new Effect.Scale(
        element,
        200,
        { sync: true, scaleFromCenter: true, scaleContent: true, restoreAfterFinish: true }
      ),
      new Effect.Opacity(element, { sync: true, to: 0 })
    ],
    Object.extend({
      duration: 1,
      beforeSetupInternal: function(effect) {
        Position.absolutize(effect.effects[0].element);
      },
      afterFinishInternal: function(effect) {
        effect.effects[0].element.hide().setStyle(oldStyle);
      }
    }, arguments[1] || {})
  );
};
Effect.BlindUp = function(element) {
  element = $(element);
  element.makeClipping();
  return new Effect.Scale(
    element,
    0,
    Object.extend({
      scaleContent: false,
      scaleX: false,
      restoreAfterFinish: true,
      afterFinishInternal: function(effect) {
        effect.element.hide().undoClipping();
      }
    }, arguments[1] || {})
  );
};
Effect.BlindDown = function(element) {
  element = $(element);
  var elementDimensions = element.getDimensions();
  return new Effect.Scale(element, 100, Object.extend({
    scaleContent: false,
    scaleX: false,
    scaleFrom: 0,
    scaleMode: { originalHeight: elementDimensions.height, originalWidth: elementDimensions.width },
    restoreAfterFinish: true,
    afterSetup: function(effect) {
      effect.element.makeClipping().setStyle({ height: "0px" }).show();
    },
    afterFinishInternal: function(effect) {
      effect.element.undoClipping();
    }
  }, arguments[1] || {}));
};
Effect.SwitchOff = function(element) {
  element = $(element);
  var oldOpacity = element.getInlineOpacity();
  return new Effect.Appear(element, Object.extend({
    duration: 0.4,
    from: 0,
    transition: Effect.Transitions.flicker,
    afterFinishInternal: function(effect) {
      new Effect.Scale(effect.element, 1, {
        duration: 0.3,
        scaleFromCenter: true,
        scaleX: false,
        scaleContent: false,
        restoreAfterFinish: true,
        beforeSetup: function(effect2) {
          effect2.element.makePositioned().makeClipping();
        },
        afterFinishInternal: function(effect2) {
          effect2.element.hide().undoClipping().undoPositioned().setStyle({ opacity: oldOpacity });
        }
      });
    }
  }, arguments[1] || {}));
};
Effect.DropOut = function(element) {
  element = $(element);
  var oldStyle = {
    top: element.getStyle("top"),
    left: element.getStyle("left"),
    opacity: element.getInlineOpacity()
  };
  return new Effect.Parallel(
    [
      new Effect.Move(element, { x: 0, y: 100, sync: true }),
      new Effect.Opacity(element, { sync: true, to: 0 })
    ],
    Object.extend(
      {
        duration: 0.5,
        beforeSetup: function(effect) {
          effect.effects[0].element.makePositioned();
        },
        afterFinishInternal: function(effect) {
          effect.effects[0].element.hide().undoPositioned().setStyle(oldStyle);
        }
      },
      arguments[1] || {}
    )
  );
};
Effect.Shake = function(element) {
  element = $(element);
  var options2 = Object.extend({
    distance: 20,
    duration: 0.5
  }, arguments[1] || {});
  var distance = parseFloat(options2.distance);
  var split = parseFloat(options2.duration) / 10;
  var oldStyle = {
    top: element.getStyle("top"),
    left: element.getStyle("left")
  };
  return new Effect.Move(
    element,
    { x: distance, y: 0, duration: split, afterFinishInternal: function(effect) {
      new Effect.Move(
        effect.element,
        { x: -distance * 2, y: 0, duration: split * 2, afterFinishInternal: function(effect2) {
          new Effect.Move(
            effect2.element,
            { x: distance * 2, y: 0, duration: split * 2, afterFinishInternal: function(effect3) {
              new Effect.Move(
                effect3.element,
                { x: -distance * 2, y: 0, duration: split * 2, afterFinishInternal: function(effect4) {
                  new Effect.Move(
                    effect4.element,
                    { x: distance * 2, y: 0, duration: split * 2, afterFinishInternal: function(effect5) {
                      new Effect.Move(
                        effect5.element,
                        { x: -distance, y: 0, duration: split, afterFinishInternal: function(effect6) {
                          effect6.element.undoPositioned().setStyle(oldStyle);
                        } }
                      );
                    } }
                  );
                } }
              );
            } }
          );
        } }
      );
    } }
  );
};
Effect.SlideDown = function(element) {
  element = $(element).cleanWhitespace();
  var oldInnerBottom = element.down().getStyle("bottom");
  var elementDimensions = element.getDimensions();
  return new Effect.Scale(
    element,
    100,
    Object.extend({
      scaleContent: false,
      scaleX: false,
      scaleFrom: window.opera ? 0 : 1,
      scaleMode: { originalHeight: elementDimensions.height, originalWidth: elementDimensions.width },
      restoreAfterFinish: true,
      afterSetup: function(effect) {
        effect.element.makePositioned();
        effect.element.down().makePositioned();
        if (window.opera)
          effect.element.setStyle({ top: "" });
        effect.element.makeClipping().setStyle({ height: "0px" }).show();
      },
      afterUpdateInternal: function(effect) {
        effect.element.down().setStyle({ bottom: effect.dims[0] - effect.element.clientHeight + "px" });
      },
      afterFinishInternal: function(effect) {
        effect.element.undoClipping().undoPositioned();
        effect.element.down().undoPositioned().setStyle({ bottom: oldInnerBottom });
      }
    }, arguments[1] || {})
  );
};
Effect.SlideUp = function(element) {
  element = $(element).cleanWhitespace();
  var oldInnerBottom = element.down().getStyle("bottom");
  var elementDimensions = element.getDimensions();
  return new Effect.Scale(
    element,
    window.opera ? 0 : 1,
    Object.extend({
      scaleContent: false,
      scaleX: false,
      scaleMode: "box",
      scaleFrom: 100,
      scaleMode: { originalHeight: elementDimensions.height, originalWidth: elementDimensions.width },
      restoreAfterFinish: true,
      afterSetup: function(effect) {
        effect.element.makePositioned();
        effect.element.down().makePositioned();
        if (window.opera)
          effect.element.setStyle({ top: "" });
        effect.element.makeClipping().show();
      },
      afterUpdateInternal: function(effect) {
        effect.element.down().setStyle({ bottom: effect.dims[0] - effect.element.clientHeight + "px" });
      },
      afterFinishInternal: function(effect) {
        effect.element.hide().undoClipping().undoPositioned();
        effect.element.down().undoPositioned().setStyle({ bottom: oldInnerBottom });
      }
    }, arguments[1] || {})
  );
};
Effect.Squish = function(element) {
  return new Effect.Scale(element, window.opera ? 1 : 0, {
    restoreAfterFinish: true,
    beforeSetup: function(effect) {
      effect.element.makeClipping();
    },
    afterFinishInternal: function(effect) {
      effect.element.hide().undoClipping();
    }
  });
};
Effect.Grow = function(element) {
  element = $(element);
  var options2 = Object.extend({
    direction: "center",
    moveTransition: Effect.Transitions.sinoidal,
    scaleTransition: Effect.Transitions.sinoidal,
    opacityTransition: Effect.Transitions.full
  }, arguments[1] || {});
  var oldStyle = {
    top: element.style.top,
    left: element.style.left,
    height: element.style.height,
    width: element.style.width,
    opacity: element.getInlineOpacity()
  };
  var dims = element.getDimensions();
  var initialMoveX, initialMoveY;
  var moveX, moveY;
  switch (options2.direction) {
    case "top-left":
      initialMoveX = initialMoveY = moveX = moveY = 0;
      break;
    case "top-right":
      initialMoveX = dims.width;
      initialMoveY = moveY = 0;
      moveX = -dims.width;
      break;
    case "bottom-left":
      initialMoveX = moveX = 0;
      initialMoveY = dims.height;
      moveY = -dims.height;
      break;
    case "bottom-right":
      initialMoveX = dims.width;
      initialMoveY = dims.height;
      moveX = -dims.width;
      moveY = -dims.height;
      break;
    case "center":
      initialMoveX = dims.width / 2;
      initialMoveY = dims.height / 2;
      moveX = -dims.width / 2;
      moveY = -dims.height / 2;
      break;
  }
  return new Effect.Move(element, {
    x: initialMoveX,
    y: initialMoveY,
    duration: 0.01,
    beforeSetup: function(effect) {
      effect.element.hide().makeClipping().makePositioned();
    },
    afterFinishInternal: function(effect) {
      new Effect.Parallel(
        [
          new Effect.Opacity(effect.element, { sync: true, to: 1, from: 0, transition: options2.opacityTransition }),
          new Effect.Move(effect.element, { x: moveX, y: moveY, sync: true, transition: options2.moveTransition }),
          new Effect.Scale(effect.element, 100, {
            scaleMode: { originalHeight: dims.height, originalWidth: dims.width },
            sync: true,
            scaleFrom: window.opera ? 1 : 0,
            transition: options2.scaleTransition,
            restoreAfterFinish: true
          })
        ],
        Object.extend({
          beforeSetup: function(effect2) {
            effect2.effects[0].element.setStyle({ height: "0px" }).show();
          },
          afterFinishInternal: function(effect2) {
            effect2.effects[0].element.undoClipping().undoPositioned().setStyle(oldStyle);
          }
        }, options2)
      );
    }
  });
};
Effect.Shrink = function(element) {
  element = $(element);
  var options2 = Object.extend({
    direction: "center",
    moveTransition: Effect.Transitions.sinoidal,
    scaleTransition: Effect.Transitions.sinoidal,
    opacityTransition: Effect.Transitions.none
  }, arguments[1] || {});
  var oldStyle = {
    top: element.style.top,
    left: element.style.left,
    height: element.style.height,
    width: element.style.width,
    opacity: element.getInlineOpacity()
  };
  var dims = element.getDimensions();
  var moveX, moveY;
  switch (options2.direction) {
    case "top-left":
      moveX = moveY = 0;
      break;
    case "top-right":
      moveX = dims.width;
      moveY = 0;
      break;
    case "bottom-left":
      moveX = 0;
      moveY = dims.height;
      break;
    case "bottom-right":
      moveX = dims.width;
      moveY = dims.height;
      break;
    case "center":
      moveX = dims.width / 2;
      moveY = dims.height / 2;
      break;
  }
  return new Effect.Parallel(
    [
      new Effect.Opacity(element, { sync: true, to: 0, from: 1, transition: options2.opacityTransition }),
      new Effect.Scale(element, window.opera ? 1 : 0, { sync: true, transition: options2.scaleTransition, restoreAfterFinish: true }),
      new Effect.Move(element, { x: moveX, y: moveY, sync: true, transition: options2.moveTransition })
    ],
    Object.extend({
      beforeStartInternal: function(effect) {
        effect.effects[0].element.makePositioned().makeClipping();
      },
      afterFinishInternal: function(effect) {
        effect.effects[0].element.hide().undoClipping().undoPositioned().setStyle(oldStyle);
      }
    }, options2)
  );
};
Effect.Pulsate = function(element) {
  element = $(element);
  var options2 = arguments[1] || {}, oldOpacity = element.getInlineOpacity(), transition = options2.transition || Effect.Transitions.linear, reverser = function(pos) {
    return 1 - transition(-Math.cos(pos * (options2.pulses || 5) * 2 * Math.PI) / 2 + 0.5);
  };
  return new Effect.Opacity(
    element,
    Object.extend(Object.extend({
      duration: 2,
      from: 0,
      afterFinishInternal: function(effect) {
        effect.element.setStyle({ opacity: oldOpacity });
      }
    }, options2), { transition: reverser })
  );
};
Effect.Fold = function(element) {
  element = $(element);
  var oldStyle = {
    top: element.style.top,
    left: element.style.left,
    width: element.style.width,
    height: element.style.height
  };
  element.makeClipping();
  return new Effect.Scale(element, 5, Object.extend({
    scaleContent: false,
    scaleX: false,
    afterFinishInternal: function(effect) {
      new Effect.Scale(element, 1, {
        scaleContent: false,
        scaleY: false,
        afterFinishInternal: function(effect2) {
          effect2.element.hide().undoClipping().setStyle(oldStyle);
        }
      });
    }
  }, arguments[1] || {}));
};
Effect.Morph = Class.create(Effect.Base, {
  initialize: function(element) {
    this.element = $(element);
    if (!this.element)
      throw Effect._elementDoesNotExistError;
    var options2 = Object.extend({
      style: {}
    }, arguments[1] || {});
    if (!Object.isString(options2.style))
      this.style = $H(options2.style);
    else {
      if (options2.style.include(":"))
        this.style = options2.style.parseStyle();
      else {
        this.element.addClassName(options2.style);
        this.style = $H(this.element.getStyles());
        this.element.removeClassName(options2.style);
        var css = this.element.getStyles();
        this.style = this.style.reject(function(style) {
          return style.value == css[style.key];
        });
        options2.afterFinishInternal = function(effect) {
          effect.element.addClassName(effect.options.style);
          effect.transforms.each(function(transform) {
            effect.element.style[transform.style] = "";
          });
        };
      }
    }
    this.start(options2);
  },
  setup: function() {
    function parseColor(color) {
      if (!color || ["rgba(0, 0, 0, 0)", "transparent"].include(color))
        color = "#ffffff";
      color = color.parseColor();
      return $R(0, 2).map(function(i2) {
        return parseInt(color.slice(i2 * 2 + 1, i2 * 2 + 3), 16);
      });
    }
    this.transforms = this.style.map(function(pair) {
      var property2 = pair[0], value = pair[1], unit = null;
      if (value.parseColor("#zzzzzz") != "#zzzzzz") {
        value = value.parseColor();
        unit = "color";
      } else if (property2 == "opacity") {
        value = parseFloat(value);
        if (Prototype.Browser.IE && !this.element.currentStyle.hasLayout)
          this.element.setStyle({ zoom: 1 });
      } else if (Element.CSS_LENGTH.test(value)) {
        var components = value.match(/^([\+\-]?[0-9\.]+)(.*)$/);
        value = parseFloat(components[1]);
        unit = components.length == 3 ? components[2] : null;
      }
      var originalValue = this.element.getStyle(property2);
      return {
        style: property2.camelize(),
        originalValue: unit == "color" ? parseColor(originalValue) : parseFloat(originalValue || 0),
        targetValue: unit == "color" ? parseColor(value) : value,
        unit: unit
      };
    }.bind(this)).reject(function(transform) {
      return transform.originalValue == transform.targetValue || transform.unit != "color" && (isNaN(transform.originalValue) || isNaN(transform.targetValue));
    });
  },
  update: function(position) {
    var style = {}, transform, i2 = this.transforms.length;
    while (i2--)
      style[(transform = this.transforms[i2]).style] = transform.unit == "color" ? "#" + Math.round(transform.originalValue[0] + (transform.targetValue[0] - transform.originalValue[0]) * position).toColorPart() + Math.round(transform.originalValue[1] + (transform.targetValue[1] - transform.originalValue[1]) * position).toColorPart() + Math.round(transform.originalValue[2] + (transform.targetValue[2] - transform.originalValue[2]) * position).toColorPart() : (transform.originalValue + (transform.targetValue - transform.originalValue) * position).toFixed(3) + (transform.unit === null ? "" : transform.unit);
    this.element.setStyle(style, true);
  }
});
Effect.Transform = Class.create({
  initialize: function(tracks) {
    this.tracks = [];
    this.options = arguments[1] || {};
    this.addTracks(tracks);
  },
  addTracks: function(tracks) {
    tracks.each(function(track) {
      track = $H(track);
      var data = track.values().first();
      this.tracks.push($H({
        ids: track.keys().first(),
        effect: Effect.Morph,
        options: { style: data }
      }));
    }.bind(this));
    return this;
  },
  play: function() {
    return new Effect.Parallel(
      this.tracks.map(function(track) {
        var ids = track.get("ids"), effect = track.get("effect"), options2 = track.get("options");
        var elements = [$(ids) || $$(ids)].flatten();
        return elements.map(function(e) {
          return new effect(e, Object.extend({ sync: true }, options2));
        });
      }).flatten(),
      this.options
    );
  }
});
Element.CSS_PROPERTIES = $w(
  "backgroundColor backgroundPosition borderBottomColor borderBottomStyle borderBottomWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderSpacing borderTopColor borderTopStyle borderTopWidth bottom clip color fontSize fontWeight height left letterSpacing lineHeight marginBottom marginLeft marginRight marginTop markerOffset maxHeight maxWidth minHeight minWidth opacity outlineColor outlineOffset outlineWidth paddingBottom paddingLeft paddingRight paddingTop right textIndent top width wordSpacing zIndex"
);
Element.CSS_LENGTH = /^(([\+\-]?[0-9\.]+)(em|ex|px|in|cm|mm|pt|pc|\%))|0$/;
String.__parseStyleElement = document.createElement("div");
String.prototype.parseStyle = function() {
  var style, styleRules = $H();
  if (Prototype.Browser.WebKit)
    style = new Element("div", { style: this }).style;
  else {
    String.__parseStyleElement.innerHTML = '<div style="' + this + '"></div>';
    style = String.__parseStyleElement.childNodes[0].style;
  }
  Element.CSS_PROPERTIES.each(function(property2) {
    if (style[property2])
      styleRules.set(property2, style[property2]);
  });
  if (Prototype.Browser.IE && this.include("opacity"))
    styleRules.set("opacity", this.match(/opacity:\s*((?:0|1)?(?:\.\d*)?)/)[1]);
  return styleRules;
};
if (document.defaultView && document.defaultView.getComputedStyle) {
  Element.getStyles = function(element) {
    var css = document.defaultView.getComputedStyle($(element), null);
    return Element.CSS_PROPERTIES.inject({}, function(styles, property2) {
      styles[property2] = css[property2];
      return styles;
    });
  };
} else {
  Element.getStyles = function(element) {
    element = $(element);
    var css = element.currentStyle, styles;
    styles = Element.CSS_PROPERTIES.inject({}, function(results, property2) {
      results[property2] = css[property2];
      return results;
    });
    if (!styles.opacity)
      styles.opacity = element.getOpacity();
    return styles;
  };
}
Effect.Methods = {
  morph: function(element, style) {
    element = $(element);
    new Effect.Morph(element, Object.extend({ style: style }, arguments[2] || {}));
    return element;
  },
  visualEffect: function(element, effect, options2) {
    element = $(element);
    var s = effect.dasherize().camelize(), klass = s.charAt(0).toUpperCase() + s.substring(1);
    new Effect[klass](element, options2);
    return element;
  },
  highlight: function(element, options2) {
    element = $(element);
    new Effect.Highlight(element, options2);
    return element;
  }
};
$w("fade appear grow shrink fold blindUp blindDown slideUp slideDown pulsate shake puff squish switchOff dropOut").each(
  function(effect) {
    Effect.Methods[effect] = function(element, options2) {
      element = $(element);
      Effect[effect.charAt(0).toUpperCase() + effect.substring(1)](element, options2);
      return element;
    };
  }
);
$w("getInlineOpacity forceRerendering setContentZoom collectTextNodes collectTextNodesIgnoreClass getStyles").each(
  function(f) {
    Effect.Methods[f] = Element[f];
  }
);
Element.addMethods(Effect.Methods);
if (Object.isUndefined(Effect))
  throw "dragdrop.js requires including script.aculo.us' effects.js library";
var Droppables = {
  drops: [],
  remove: function(element) {
    this.drops = this.drops.reject(function(d) {
      return d.element == $(element);
    });
  },
  add: function(element) {
    element = $(element);
    var options2 = Object.extend({
      greedy: true,
      hoverclass: null,
      tree: false
    }, arguments[1] || {});
    if (options2.containment) {
      options2._containers = [];
      var containment = options2.containment;
      if (Object.isArray(containment)) {
        containment.each(function(c) {
          options2._containers.push($(c));
        });
      } else {
        options2._containers.push($(containment));
      }
    }
    if (options2.accept)
      options2.accept = [options2.accept].flatten();
    Element.makePositioned(element);
    options2.element = element;
    this.drops.push(options2);
  },
  findDeepestChild: function(drops) {
    deepest = drops[0];
    for (i = 1; i < drops.length; ++i)
      if (Element.isParent(drops[i].element, deepest.element))
        deepest = drops[i];
    return deepest;
  },
  isContained: function(element, drop) {
    var containmentNode;
    if (drop.tree) {
      containmentNode = element.treeNode;
    } else {
      containmentNode = element.parentNode;
    }
    return drop._containers.detect(function(c) {
      return containmentNode == c;
    });
  },
  isAffected: function(point, element, drop) {
    return drop.element != element && (!drop._containers || this.isContained(element, drop)) && (!drop.accept || Element.classNames(element).detect(
      function(v) {
        return drop.accept.include(v);
      }
    )) && Position.within(drop.element, point[0], point[1]);
  },
  deactivate: function(drop) {
    if (drop.hoverclass)
      Element.removeClassName(drop.element, drop.hoverclass);
    this.last_active = null;
  },
  activate: function(drop) {
    if (drop.hoverclass)
      Element.addClassName(drop.element, drop.hoverclass);
    this.last_active = drop;
  },
  show: function(point, element) {
    if (!this.drops.length)
      return;
    var drop, affected = [];
    this.drops.each(function(drop2) {
      if (Droppables.isAffected(point, element, drop2))
        affected.push(drop2);
    });
    if (affected.length > 0)
      drop = Droppables.findDeepestChild(affected);
    if (this.last_active && this.last_active != drop)
      this.deactivate(this.last_active);
    if (drop) {
      Position.within(drop.element, point[0], point[1]);
      if (drop.onHover)
        drop.onHover(element, drop.element, Position.overlap(drop.overlap, drop.element));
      if (drop != this.last_active)
        Droppables.activate(drop);
    }
  },
  fire: function(event, element) {
    if (!this.last_active)
      return;
    Position.prepare();
    if (this.isAffected([Event.pointerX(event), Event.pointerY(event)], element, this.last_active)) {
      if (this.last_active.onDrop) {
        this.last_active.onDrop(element, this.last_active.element, event);
        return true;
      }
    }
  },
  reset: function() {
    if (this.last_active)
      this.deactivate(this.last_active);
  }
};
var Draggables = {
  drags: [],
  observers: [],
  register: function(draggable) {
    if (this.drags.length == 0) {
      this.eventMouseUp = this.endDrag.bindAsEventListener(this);
      this.eventMouseMove = this.updateDrag.bindAsEventListener(this);
      this.eventKeypress = this.keyPress.bindAsEventListener(this);
      Event.observe(document, "mouseup", this.eventMouseUp);
      Event.observe(document, "mousemove", this.eventMouseMove);
      Event.observe(document, "keypress", this.eventKeypress);
    }
    this.drags.push(draggable);
  },
  unregister: function(draggable) {
    this.drags = this.drags.reject(function(d) {
      return d == draggable;
    });
    if (this.drags.length == 0) {
      Event.stopObserving(document, "mouseup", this.eventMouseUp);
      Event.stopObserving(document, "mousemove", this.eventMouseMove);
      Event.stopObserving(document, "keypress", this.eventKeypress);
    }
  },
  activate: function(draggable) {
    if (draggable.options.delay) {
      this._timeout = setTimeout(function() {
        Draggables._timeout = null;
        window.focus();
        Draggables.activeDraggable = draggable;
      }.bind(this), draggable.options.delay);
    } else {
      window.focus();
      this.activeDraggable = draggable;
    }
  },
  deactivate: function() {
    this.activeDraggable = null;
  },
  updateDrag: function(event) {
    if (!this.activeDraggable)
      return;
    var pointer = [Event.pointerX(event), Event.pointerY(event)];
    if (this._lastPointer && this._lastPointer.inspect() == pointer.inspect())
      return;
    this._lastPointer = pointer;
    this.activeDraggable.updateDrag(event, pointer);
  },
  endDrag: function(event) {
    if (this._timeout) {
      clearTimeout(this._timeout);
      this._timeout = null;
    }
    if (!this.activeDraggable)
      return;
    this._lastPointer = null;
    this.activeDraggable.endDrag(event);
    this.activeDraggable = null;
  },
  keyPress: function(event) {
    if (this.activeDraggable)
      this.activeDraggable.keyPress(event);
  },
  addObserver: function(observer) {
    this.observers.push(observer);
    this._cacheObserverCallbacks();
  },
  removeObserver: function(element) {
    this.observers = this.observers.reject(function(o) {
      return o.element == element;
    });
    this._cacheObserverCallbacks();
  },
  notify: function(eventName, draggable, event) {
    if (this[eventName + "Count"] > 0)
      this.observers.each(function(o) {
        if (o[eventName])
          o[eventName](eventName, draggable, event);
      });
    if (draggable.options[eventName])
      draggable.options[eventName](draggable, event);
  },
  _cacheObserverCallbacks: function() {
    ["onStart", "onEnd", "onDrag"].each(function(eventName) {
      Draggables[eventName + "Count"] = Draggables.observers.select(
        function(o) {
          return o[eventName];
        }
      ).length;
    });
  }
};
var Draggable = Class.create({
  initialize: function(element) {
    var defaults = {
      handle: false,
      reverteffect: function(element2, top_offset, left_offset) {
        var dur = Math.sqrt(Math.abs(top_offset ^ 2) + Math.abs(left_offset ^ 2)) * 0.02;
        new Effect.Move(element2, {
          x: -left_offset,
          y: -top_offset,
          duration: dur,
          queue: { scope: "_draggable", position: "end" }
        });
      },
      endeffect: function(element2) {
        var toOpacity = Object.isNumber(element2._opacity) ? element2._opacity : 1;
        new Effect.Opacity(element2, {
          duration: 0.2,
          from: 0.7,
          to: toOpacity,
          queue: { scope: "_draggable", position: "end" },
          afterFinish: function() {
            Draggable._dragging[element2] = false;
          }
        });
      },
      zindex: 1e3,
      revert: false,
      quiet: false,
      scroll: false,
      scrollSensitivity: 20,
      scrollSpeed: 15,
      snap: false,
      // false, or xy or [x,y] or function(x,y){ return [x,y] }
      delay: 0
    };
    if (!arguments[1] || Object.isUndefined(arguments[1].endeffect))
      Object.extend(defaults, {
        starteffect: function(element2) {
          element2._opacity = Element.getOpacity(element2);
          Draggable._dragging[element2] = true;
          new Effect.Opacity(element2, { duration: 0.2, from: element2._opacity, to: 0.7 });
        }
      });
    var options2 = Object.extend(defaults, arguments[1] || {});
    this.element = $(element);
    if (options2.handle && Object.isString(options2.handle))
      this.handle = this.element.down("." + options2.handle, 0);
    if (!this.handle)
      this.handle = $(options2.handle);
    if (!this.handle)
      this.handle = this.element;
    if (options2.scroll && !options2.scroll.scrollTo && !options2.scroll.outerHTML) {
      options2.scroll = $(options2.scroll);
      this._isScrollChild = Element.childOf(this.element, options2.scroll);
    }
    Element.makePositioned(this.element);
    this.options = options2;
    this.dragging = false;
    this.eventMouseDown = this.initDrag.bindAsEventListener(this);
    Event.observe(this.handle, "mousedown", this.eventMouseDown);
    Draggables.register(this);
  },
  destroy: function() {
    Event.stopObserving(this.handle, "mousedown", this.eventMouseDown);
    Draggables.unregister(this);
  },
  currentDelta: function() {
    return [
      parseInt(Element.getStyle(this.element, "left") || "0"),
      parseInt(Element.getStyle(this.element, "top") || "0")
    ];
  },
  initDrag: function(event) {
    if (!Object.isUndefined(Draggable._dragging[this.element]) && Draggable._dragging[this.element])
      return;
    if (Event.isLeftClick(event)) {
      var src = Event.element(event);
      if ((tag_name = src.tagName.toUpperCase()) && (tag_name == "INPUT" || tag_name == "SELECT" || tag_name == "OPTION" || tag_name == "BUTTON" || tag_name == "TEXTAREA"))
        return;
      var pointer = [Event.pointerX(event), Event.pointerY(event)];
      var pos = this.element.cumulativeOffset();
      this.offset = [0, 1].map(function(i2) {
        return pointer[i2] - pos[i2];
      });
      Draggables.activate(this);
      Event.stop(event);
    }
  },
  startDrag: function(event) {
    this.dragging = true;
    if (!this.delta)
      this.delta = this.currentDelta();
    if (this.options.zindex) {
      this.originalZ = parseInt(Element.getStyle(this.element, "z-index") || 0);
      this.element.style.zIndex = this.options.zindex;
    }
    if (this.options.ghosting) {
      this._clone = this.element.cloneNode(true);
      this._originallyAbsolute = this.element.getStyle("position") == "absolute";
      if (!this._originallyAbsolute)
        Position.absolutize(this.element);
      this.element.parentNode.insertBefore(this._clone, this.element);
    }
    if (this.options.scroll) {
      if (this.options.scroll == window) {
        var where = this._getWindowScroll(this.options.scroll);
        this.originalScrollLeft = where.left;
        this.originalScrollTop = where.top;
      } else {
        this.originalScrollLeft = this.options.scroll.scrollLeft;
        this.originalScrollTop = this.options.scroll.scrollTop;
      }
    }
    Draggables.notify("onStart", this, event);
    if (this.options.starteffect)
      this.options.starteffect(this.element);
  },
  updateDrag: function(event, pointer) {
    if (!this.dragging)
      this.startDrag(event);
    if (!this.options.quiet) {
      Position.prepare();
      Droppables.show(pointer, this.element);
    }
    Draggables.notify("onDrag", this, event);
    this.draw(pointer);
    if (this.options.change)
      this.options.change(this);
    if (this.options.scroll) {
      this.stopScrolling();
      var p;
      if (this.options.scroll == window) {
        var winScroll = this._getWindowScroll(this.options.scroll);
        p = [winScroll.left, winScroll.top, winScroll.left + winScroll.width, winScroll.top + winScroll.height];
      } else {
        p = Position.page(this.options.scroll).toArray();
        p[0] += this.options.scroll.scrollLeft + Position.deltaX;
        p[1] += this.options.scroll.scrollTop + Position.deltaY;
        p.push(p[0] + this.options.scroll.offsetWidth);
        p.push(p[1] + this.options.scroll.offsetHeight);
      }
      var speed = [0, 0];
      if (pointer[0] < p[0] + this.options.scrollSensitivity)
        speed[0] = pointer[0] - (p[0] + this.options.scrollSensitivity);
      if (pointer[1] < p[1] + this.options.scrollSensitivity)
        speed[1] = pointer[1] - (p[1] + this.options.scrollSensitivity);
      if (pointer[0] > p[2] - this.options.scrollSensitivity)
        speed[0] = pointer[0] - (p[2] - this.options.scrollSensitivity);
      if (pointer[1] > p[3] - this.options.scrollSensitivity)
        speed[1] = pointer[1] - (p[3] - this.options.scrollSensitivity);
      this.startScrolling(speed);
    }
    if (Prototype.Browser.WebKit)
      window.scrollBy(0, 0);
    Event.stop(event);
  },
  finishDrag: function(event, success) {
    this.dragging = false;
    if (this.options.quiet) {
      Position.prepare();
      var pointer = [Event.pointerX(event), Event.pointerY(event)];
      Droppables.show(pointer, this.element);
    }
    if (this.options.ghosting) {
      if (!this._originallyAbsolute)
        Position.relativize(this.element);
      delete this._originallyAbsolute;
      Element.remove(this._clone);
      this._clone = null;
    }
    var dropped = false;
    if (success) {
      dropped = Droppables.fire(event, this.element);
      if (!dropped)
        dropped = false;
    }
    if (dropped && this.options.onDropped)
      this.options.onDropped(this.element);
    Draggables.notify("onEnd", this, event);
    var revert = this.options.revert;
    if (revert && Object.isFunction(revert))
      revert = revert(this.element);
    var d = this.currentDelta();
    if (revert && this.options.reverteffect) {
      if (dropped == 0 || revert != "failure")
        this.options.reverteffect(
          this.element,
          d[1] - this.delta[1],
          d[0] - this.delta[0]
        );
    } else {
      this.delta = d;
    }
    if (this.options.zindex)
      this.element.style.zIndex = this.originalZ;
    if (this.options.endeffect)
      this.options.endeffect(this.element);
    Draggables.deactivate(this);
    Droppables.reset();
  },
  keyPress: function(event) {
    if (event.keyCode != Event.KEY_ESC)
      return;
    this.finishDrag(event, false);
    Event.stop(event);
  },
  endDrag: function(event) {
    if (!this.dragging)
      return;
    this.stopScrolling();
    this.finishDrag(event, true);
    Event.stop(event);
  },
  draw: function(point) {
    var pos = this.element.cumulativeOffset();
    if (this.options.ghosting) {
      var r2 = Position.realOffset(this.element);
      pos[0] += r2[0] - Position.deltaX;
      pos[1] += r2[1] - Position.deltaY;
    }
    var d = this.currentDelta();
    pos[0] -= d[0];
    pos[1] -= d[1];
    if (this.options.scroll && (this.options.scroll != window && this._isScrollChild)) {
      pos[0] -= this.options.scroll.scrollLeft - this.originalScrollLeft;
      pos[1] -= this.options.scroll.scrollTop - this.originalScrollTop;
    }
    var p = [0, 1].map(function(i2) {
      return point[i2] - pos[i2] - this.offset[i2];
    }.bind(this));
    if (this.options.snap) {
      if (Object.isFunction(this.options.snap)) {
        p = this.options.snap(p[0], p[1], this);
      } else {
        if (Object.isArray(this.options.snap)) {
          p = p.map(function(v, i2) {
            return (v / this.options.snap[i2]).round() * this.options.snap[i2];
          }.bind(this));
        } else {
          p = p.map(function(v) {
            return (v / this.options.snap).round() * this.options.snap;
          }.bind(this));
        }
      }
    }
    var style = this.element.style;
    if (!this.options.constraint || this.options.constraint == "horizontal")
      style.left = p[0] + "px";
    if (!this.options.constraint || this.options.constraint == "vertical")
      style.top = p[1] + "px";
    if (style.visibility == "hidden")
      style.visibility = "";
  },
  stopScrolling: function() {
    if (this.scrollInterval) {
      clearInterval(this.scrollInterval);
      this.scrollInterval = null;
      Draggables._lastScrollPointer = null;
    }
  },
  startScrolling: function(speed) {
    if (!(speed[0] || speed[1]))
      return;
    this.scrollSpeed = [speed[0] * this.options.scrollSpeed, speed[1] * this.options.scrollSpeed];
    this.lastScrolled = /* @__PURE__ */ new Date();
    this.scrollInterval = setInterval(this.scroll.bind(this), 10);
  },
  scroll: function() {
    var current = /* @__PURE__ */ new Date();
    var delta = current - this.lastScrolled;
    this.lastScrolled = current;
    if (this.options.scroll == window) {
      var winScroll = this._getWindowScroll(this.options.scroll);
      if (this.scrollSpeed[0] || this.scrollSpeed[1]) {
        var d = delta / 1e3;
        this.options.scroll.scrollTo(winScroll.left + d * this.scrollSpeed[0], winScroll.top + d * this.scrollSpeed[1]);
      }
    } else {
      this.options.scroll.scrollLeft += this.scrollSpeed[0] * delta / 1e3;
      this.options.scroll.scrollTop += this.scrollSpeed[1] * delta / 1e3;
    }
    Position.prepare();
    Droppables.show(Draggables._lastPointer, this.element);
    Draggables.notify("onDrag", this);
    if (this._isScrollChild) {
      Draggables._lastScrollPointer = Draggables._lastScrollPointer || $A(Draggables._lastPointer);
      Draggables._lastScrollPointer[0] += this.scrollSpeed[0] * delta / 1e3;
      Draggables._lastScrollPointer[1] += this.scrollSpeed[1] * delta / 1e3;
      if (Draggables._lastScrollPointer[0] < 0)
        Draggables._lastScrollPointer[0] = 0;
      if (Draggables._lastScrollPointer[1] < 0)
        Draggables._lastScrollPointer[1] = 0;
      this.draw(Draggables._lastScrollPointer);
    }
    if (this.options.change)
      this.options.change(this);
  },
  _getWindowScroll: function(w) {
    var T, L, W, H;
    if (w.document.documentElement && documentElement.scrollTop) {
      T = w.document.documentElement.scrollTop;
      L = w.document.documentElement.scrollLeft;
    } else if (w.document.body) {
      T = w.document.body.scrollTop;
      L = w.document.body.scrollLeft;
    }
    if (w.innerWidth) {
      W = w.innerWidth;
      H = w.innerHeight;
    } else if (w.document.documentElement && documentElement.clientWidth) {
      W = w.document.documentElement.clientWidth;
      H = w.document.documentElement.clientHeight;
    } else {
      W = w.document.body.offsetWidth;
      H = w.document.body.offsetHeight;
    }
    return { top: T, left: L, width: W, height: H };
  }
});
Draggable._dragging = {};
var SortableObserver = Class.create({
  initialize: function(element, observer) {
    this.element = $(element);
    this.observer = observer;
    this.lastValue = Sortable.serialize(this.element);
  },
  onStart: function() {
    this.lastValue = Sortable.serialize(this.element);
  },
  onEnd: function() {
    Sortable.unmark();
    if (this.lastValue != Sortable.serialize(this.element))
      this.observer(this.element);
  }
});
var Sortable = {
  SERIALIZE_RULE: /^[^_\-](?:[A-Za-z0-9\-\_]*)[_](.*)$/,
  sortables: {},
  _findRootElement: function(element) {
    while (element.tagName.toUpperCase() != "BODY") {
      if (element.id && Sortable.sortables[element.id])
        return element;
      element = element.parentNode;
    }
  },
  options: function(element) {
    element = Sortable._findRootElement($(element));
    if (!element)
      return;
    return Sortable.sortables[element.id];
  },
  destroy: function(element) {
    element = $(element);
    var s = Sortable.sortables[element.id];
    if (s) {
      Draggables.removeObserver(s.element);
      s.droppables.each(function(d) {
        Droppables.remove(d);
      });
      s.draggables.invoke("destroy");
      delete Sortable.sortables[s.element.id];
    }
  },
  create: function(element) {
    element = $(element);
    var options2 = Object.extend({
      element: element,
      tag: "li",
      // assumes li children, override with tag: 'tagname'
      dropOnEmpty: false,
      tree: false,
      treeTag: "ul",
      overlap: "vertical",
      // one of 'vertical', 'horizontal'
      constraint: "vertical",
      // one of 'vertical', 'horizontal', false
      containment: element,
      // also takes array of elements (or id's); or false
      handle: false,
      // or a CSS class
      only: false,
      delay: 0,
      hoverclass: null,
      ghosting: false,
      quiet: false,
      scroll: false,
      scrollSensitivity: 20,
      scrollSpeed: 15,
      format: this.SERIALIZE_RULE,
      // these take arrays of elements or ids and can be
      // used for better initialization performance
      elements: false,
      handles: false,
      onChange: Prototype.emptyFunction,
      onUpdate: Prototype.emptyFunction
    }, arguments[1] || {});
    this.destroy(element);
    var options_for_draggable = {
      revert: true,
      quiet: options2.quiet,
      scroll: options2.scroll,
      scrollSpeed: options2.scrollSpeed,
      scrollSensitivity: options2.scrollSensitivity,
      delay: options2.delay,
      ghosting: options2.ghosting,
      constraint: options2.constraint,
      handle: options2.handle
    };
    if (options2.starteffect)
      options_for_draggable.starteffect = options2.starteffect;
    if (options2.reverteffect)
      options_for_draggable.reverteffect = options2.reverteffect;
    else if (options2.ghosting)
      options_for_draggable.reverteffect = function(element2) {
        element2.style.top = 0;
        element2.style.left = 0;
      };
    if (options2.endeffect)
      options_for_draggable.endeffect = options2.endeffect;
    if (options2.zindex)
      options_for_draggable.zindex = options2.zindex;
    var options_for_droppable = {
      overlap: options2.overlap,
      containment: options2.containment,
      tree: options2.tree,
      hoverclass: options2.hoverclass,
      onHover: Sortable.onHover
    };
    var options_for_tree = {
      onHover: Sortable.onEmptyHover,
      overlap: options2.overlap,
      containment: options2.containment,
      hoverclass: options2.hoverclass
    };
    Element.cleanWhitespace(element);
    options2.draggables = [];
    options2.droppables = [];
    if (options2.dropOnEmpty || options2.tree) {
      Droppables.add(element, options_for_tree);
      options2.droppables.push(element);
    }
    (options2.elements || this.findElements(element, options2) || []).each(function(e, i2) {
      var handle = options2.handles ? $(options2.handles[i2]) : options2.handle ? $(e).select("." + options2.handle)[0] : e;
      options2.draggables.push(
        new Draggable(e, Object.extend(options_for_draggable, { handle: handle }))
      );
      Droppables.add(e, options_for_droppable);
      if (options2.tree)
        e.treeNode = element;
      options2.droppables.push(e);
    });
    if (options2.tree) {
      (Sortable.findTreeElements(element, options2) || []).each(function(e) {
        Droppables.add(e, options_for_tree);
        e.treeNode = element;
        options2.droppables.push(e);
      });
    }
    this.sortables[element.identify()] = options2;
    Draggables.addObserver(new SortableObserver(element, options2.onUpdate));
  },
  // return all suitable-for-sortable elements in a guaranteed order
  findElements: function(element, options2) {
    return Element.findChildren(
      element,
      options2.only,
      options2.tree ? true : false,
      options2.tag
    );
  },
  findTreeElements: function(element, options2) {
    return Element.findChildren(
      element,
      options2.only,
      options2.tree ? true : false,
      options2.treeTag
    );
  },
  onHover: function(element, dropon, overlap) {
    if (Element.isParent(dropon, element))
      return;
    if (overlap > 0.33 && overlap < 0.66 && Sortable.options(dropon).tree) {
      return;
    } else if (overlap > 0.5) {
      Sortable.mark(dropon, "before");
      if (dropon.previousSibling != element) {
        var oldParentNode = element.parentNode;
        element.style.visibility = "hidden";
        dropon.parentNode.insertBefore(element, dropon);
        if (dropon.parentNode != oldParentNode)
          Sortable.options(oldParentNode).onChange(element);
        Sortable.options(dropon.parentNode).onChange(element);
      }
    } else {
      Sortable.mark(dropon, "after");
      var nextElement = dropon.nextSibling || null;
      if (nextElement != element) {
        var oldParentNode = element.parentNode;
        element.style.visibility = "hidden";
        dropon.parentNode.insertBefore(element, nextElement);
        if (dropon.parentNode != oldParentNode)
          Sortable.options(oldParentNode).onChange(element);
        Sortable.options(dropon.parentNode).onChange(element);
      }
    }
  },
  onEmptyHover: function(element, dropon, overlap) {
    var oldParentNode = element.parentNode;
    var droponOptions = Sortable.options(dropon);
    if (!Element.isParent(dropon, element)) {
      var index;
      var children = Sortable.findElements(dropon, { tag: droponOptions.tag, only: droponOptions.only });
      var child = null;
      if (children) {
        var offset = Element.offsetSize(dropon, droponOptions.overlap) * (1 - overlap);
        for (index = 0; index < children.length; index += 1) {
          if (offset - Element.offsetSize(children[index], droponOptions.overlap) >= 0) {
            offset -= Element.offsetSize(children[index], droponOptions.overlap);
          } else if (offset - Element.offsetSize(children[index], droponOptions.overlap) / 2 >= 0) {
            child = index + 1 < children.length ? children[index + 1] : null;
            break;
          } else {
            child = children[index];
            break;
          }
        }
      }
      dropon.insertBefore(element, child);
      Sortable.options(oldParentNode).onChange(element);
      droponOptions.onChange(element);
    }
  },
  unmark: function() {
    if (Sortable._marker)
      Sortable._marker.hide();
  },
  mark: function(dropon, position) {
    var sortable = Sortable.options(dropon.parentNode);
    if (sortable && !sortable.ghosting)
      return;
    if (!Sortable._marker) {
      Sortable._marker = ($("dropmarker") || Element.extend(document.createElement("DIV"))).hide().addClassName("dropmarker").setStyle({ position: "absolute" });
      document.getElementsByTagName("body").item(0).appendChild(Sortable._marker);
    }
    var offsets = dropon.cumulativeOffset();
    Sortable._marker.setStyle({ left: offsets[0] + "px", top: offsets[1] + "px" });
    if (position == "after")
      if (sortable.overlap == "horizontal")
        Sortable._marker.setStyle({ left: offsets[0] + dropon.clientWidth + "px" });
      else
        Sortable._marker.setStyle({ top: offsets[1] + dropon.clientHeight + "px" });
    Sortable._marker.show();
  },
  _tree: function(element, options2, parent) {
    var children = Sortable.findElements(element, options2) || [];
    for (var i2 = 0; i2 < children.length; ++i2) {
      var match = children[i2].id.match(options2.format);
      if (!match)
        continue;
      var child = {
        id: encodeURIComponent(match ? match[1] : null),
        element: element,
        parent: parent,
        children: [],
        position: parent.children.length,
        container: $(children[i2]).down(options2.treeTag)
      };
      if (child.container)
        this._tree(child.container, options2, child);
      parent.children.push(child);
    }
    return parent;
  },
  tree: function(element) {
    element = $(element);
    var sortableOptions = this.options(element);
    var options2 = Object.extend({
      tag: sortableOptions.tag,
      treeTag: sortableOptions.treeTag,
      only: sortableOptions.only,
      name: element.id,
      format: sortableOptions.format
    }, arguments[1] || {});
    var root = {
      id: null,
      parent: null,
      children: [],
      container: element,
      position: 0
    };
    return Sortable._tree(element, options2, root);
  },
  /* Construct a [i] index for a particular node */
  _constructIndex: function(node) {
    var index = "";
    do {
      if (node.id)
        index = "[" + node.position + "]" + index;
    } while ((node = node.parent) != null);
    return index;
  },
  sequence: function(element) {
    element = $(element);
    var options2 = Object.extend(this.options(element), arguments[1] || {});
    return $(this.findElements(element, options2) || []).map(function(item) {
      return item.id.match(options2.format) ? item.id.match(options2.format)[1] : "";
    });
  },
  setSequence: function(element, new_sequence) {
    element = $(element);
    var options2 = Object.extend(this.options(element), arguments[2] || {});
    var nodeMap = {};
    this.findElements(element, options2).each(function(n) {
      if (n.id.match(options2.format))
        nodeMap[n.id.match(options2.format)[1]] = [n, n.parentNode];
      n.parentNode.removeChild(n);
    });
    new_sequence.each(function(ident) {
      var n = nodeMap[ident];
      if (n) {
        n[1].appendChild(n[0]);
        delete nodeMap[ident];
      }
    });
  },
  serialize: function(element) {
    element = $(element);
    var options2 = Object.extend(Sortable.options(element), arguments[1] || {});
    var name = encodeURIComponent(
      arguments[1] && arguments[1].name ? arguments[1].name : element.id
    );
    if (options2.tree) {
      return Sortable.tree(element, arguments[1]).children.map(function(item) {
        return [name + Sortable._constructIndex(item) + "[id]=" + encodeURIComponent(item.id)].concat(item.children.map(arguments.callee));
      }).flatten().join("&");
    } else {
      return Sortable.sequence(element, arguments[1]).map(function(item) {
        return name + "[]=" + encodeURIComponent(item);
      }).join("&");
    }
  }
};
Element.isParent = function(child, element) {
  if (!child.parentNode || child == element)
    return false;
  if (child.parentNode == element)
    return true;
  return Element.isParent(child.parentNode, element);
};
Element.findChildren = function(element, only, recursive, tagName) {
  if (!element.hasChildNodes())
    return null;
  tagName = tagName.toUpperCase();
  if (only)
    only = [only].flatten();
  var elements = [];
  $A(element.childNodes).each(function(e) {
    if (e.tagName && e.tagName.toUpperCase() == tagName && (!only || Element.classNames(e).detect(function(v) {
      return only.include(v);
    })))
      elements.push(e);
    if (recursive) {
      var grandchildren = Element.findChildren(e, only, recursive, tagName);
      if (grandchildren)
        elements.push(grandchildren);
    }
  });
  return elements.length > 0 ? elements.flatten() : [];
};
Element.offsetSize = function(element, type) {
  return element["offset" + (type == "vertical" || type == "height" ? "Height" : "Width")];
};
if (typeof Effect == "undefined")
  throw "controls.js requires including script.aculo.us' effects.js library";
var Autocompleter = {};
Autocompleter.Base = Class.create({
  baseInitialize: function(element, update, options2) {
    element = $(element);
    this.element = element;
    this.update = $(update);
    this.hasFocus = false;
    this.changed = false;
    this.active = false;
    this.index = 0;
    this.entryCount = 0;
    this.oldElementValue = this.element.value;
    if (this.setOptions)
      this.setOptions(options2);
    else
      this.options = options2 || {};
    this.options.paramName = this.options.paramName || this.element.name;
    this.options.tokens = this.options.tokens || [];
    this.options.frequency = this.options.frequency || 0.4;
    this.options.minChars = this.options.minChars || 1;
    this.options.onShow = this.options.onShow || function(element2, update2) {
      if (!update2.style.position || update2.style.position == "absolute") {
        update2.style.position = "absolute";
        Position.clone(element2, update2, {
          setHeight: false,
          offsetTop: element2.offsetHeight
        });
      }
      Effect.Appear(update2, { duration: 0.15 });
    };
    this.options.onHide = this.options.onHide || function(element2, update2) {
      new Effect.Fade(update2, { duration: 0.15 });
    };
    if (typeof this.options.tokens == "string")
      this.options.tokens = new Array(this.options.tokens);
    if (!this.options.tokens.include("\n"))
      this.options.tokens.push("\n");
    this.observer = null;
    this.element.setAttribute("autocomplete", "off");
    Element.hide(this.update);
    Event.observe(this.element, "blur", this.onBlur.bindAsEventListener(this));
    Event.observe(this.element, "keydown", this.onKeyPress.bindAsEventListener(this));
  },
  show: function() {
    if (Element.getStyle(this.update, "display") == "none")
      this.options.onShow(this.element, this.update);
    if (!this.iefix && Prototype.Browser.IE && Element.getStyle(this.update, "position") == "absolute") {
      new Insertion.After(
        this.update,
        '<iframe id="' + this.update.id + '_iefix" style="display:none;position:absolute;filter:progid:DXImageTransform.Microsoft.Alpha(opacity=0);" src="javascript:false;" frameborder="0" scrolling="no"></iframe>'
      );
      this.iefix = $(this.update.id + "_iefix");
    }
    if (this.iefix)
      setTimeout(this.fixIEOverlapping.bind(this), 50);
  },
  fixIEOverlapping: function() {
    Position.clone(this.update, this.iefix, { setTop: !this.update.style.height });
    this.iefix.style.zIndex = 1;
    this.update.style.zIndex = 2;
    Element.show(this.iefix);
  },
  hide: function() {
    this.stopIndicator();
    if (Element.getStyle(this.update, "display") != "none")
      this.options.onHide(this.element, this.update);
    if (this.iefix)
      Element.hide(this.iefix);
  },
  startIndicator: function() {
    if (this.options.indicator)
      Element.show(this.options.indicator);
  },
  stopIndicator: function() {
    if (this.options.indicator)
      Element.hide(this.options.indicator);
  },
  onKeyPress: function(event) {
    if (this.active)
      switch (event.keyCode) {
        case Event.KEY_TAB:
        case Event.KEY_RETURN:
          this.selectEntry();
          Event.stop(event);
        case Event.KEY_ESC:
          this.hide();
          this.active = false;
          Event.stop(event);
          return;
        case Event.KEY_LEFT:
        case Event.KEY_RIGHT:
          return;
        case Event.KEY_UP:
          this.markPrevious();
          this.render();
          Event.stop(event);
          return;
        case Event.KEY_DOWN:
          this.markNext();
          this.render();
          Event.stop(event);
          return;
      }
    else if (event.keyCode == Event.KEY_TAB || event.keyCode == Event.KEY_RETURN || Prototype.Browser.WebKit > 0 && event.keyCode == 0)
      return;
    this.changed = true;
    this.hasFocus = true;
    if (this.observer)
      clearTimeout(this.observer);
    this.observer = setTimeout(this.onObserverEvent.bind(this), this.options.frequency * 1e3);
  },
  activate: function() {
    this.changed = false;
    this.hasFocus = true;
    this.getUpdatedChoices();
  },
  onHover: function(event) {
    var element = Event.findElement(event, "LI");
    if (this.index != element.autocompleteIndex) {
      this.index = element.autocompleteIndex;
      this.render();
    }
    Event.stop(event);
  },
  onClick: function(event) {
    var element = Event.findElement(event, "LI");
    this.index = element.autocompleteIndex;
    this.selectEntry();
    this.hide();
  },
  onBlur: function(event) {
    setTimeout(this.hide.bind(this), 250);
    this.hasFocus = false;
    this.active = false;
  },
  render: function() {
    if (this.entryCount > 0) {
      for (var i2 = 0; i2 < this.entryCount; i2++)
        this.index == i2 ? Element.addClassName(this.getEntry(i2), "selected") : Element.removeClassName(this.getEntry(i2), "selected");
      if (this.hasFocus) {
        this.show();
        this.active = true;
      }
    } else {
      this.active = false;
      this.hide();
    }
  },
  markPrevious: function() {
    if (this.index > 0)
      this.index--;
    else
      this.index = this.entryCount - 1;
    this.getEntry(this.index).scrollIntoView(true);
  },
  markNext: function() {
    if (this.index < this.entryCount - 1)
      this.index++;
    else
      this.index = 0;
    this.getEntry(this.index).scrollIntoView(false);
  },
  getEntry: function(index) {
    return this.update.firstChild.childNodes[index];
  },
  getCurrentEntry: function() {
    return this.getEntry(this.index);
  },
  selectEntry: function() {
    this.active = false;
    this.updateElement(this.getCurrentEntry());
  },
  updateElement: function(selectedElement) {
    if (this.options.updateElement) {
      this.options.updateElement(selectedElement);
      return;
    }
    var value = "";
    if (this.options.select) {
      var nodes = $(selectedElement).select("." + this.options.select) || [];
      if (nodes.length > 0)
        value = Element.collectTextNodes(nodes[0], this.options.select);
    } else
      value = Element.collectTextNodesIgnoreClass(selectedElement, "informal");
    var bounds = this.getTokenBounds();
    if (bounds[0] != -1) {
      var newValue = this.element.value.substr(0, bounds[0]);
      var whitespace = this.element.value.substr(bounds[0]).match(/^\s+/);
      if (whitespace)
        newValue += whitespace[0];
      this.element.value = newValue + value + this.element.value.substr(bounds[1]);
    } else {
      this.element.value = value;
    }
    this.oldElementValue = this.element.value;
    this.element.focus();
    if (this.options.afterUpdateElement)
      this.options.afterUpdateElement(this.element, selectedElement);
  },
  updateChoices: function(choices) {
    if (!this.changed && this.hasFocus) {
      this.update.innerHTML = choices;
      Element.cleanWhitespace(this.update);
      Element.cleanWhitespace(this.update.down());
      if (this.update.firstChild && this.update.down().childNodes) {
        this.entryCount = this.update.down().childNodes.length;
        for (var i2 = 0; i2 < this.entryCount; i2++) {
          var entry = this.getEntry(i2);
          entry.autocompleteIndex = i2;
          this.addObservers(entry);
        }
      } else {
        this.entryCount = 0;
      }
      this.stopIndicator();
      this.index = 0;
      if (this.entryCount == 1 && this.options.autoSelect) {
        this.selectEntry();
        this.hide();
      } else {
        this.render();
      }
    }
  },
  addObservers: function(element) {
    Event.observe(element, "mouseover", this.onHover.bindAsEventListener(this));
    Event.observe(element, "click", this.onClick.bindAsEventListener(this));
  },
  onObserverEvent: function() {
    this.changed = false;
    this.tokenBounds = null;
    if (this.getToken().length >= this.options.minChars) {
      this.getUpdatedChoices();
    } else {
      this.active = false;
      this.hide();
    }
    this.oldElementValue = this.element.value;
  },
  getToken: function() {
    var bounds = this.getTokenBounds();
    return this.element.value.substring(bounds[0], bounds[1]).strip();
  },
  getTokenBounds: function() {
    if (null != this.tokenBounds)
      return this.tokenBounds;
    var value = this.element.value;
    if (value.strip().empty())
      return [-1, 0];
    var diff = arguments.callee.getFirstDifferencePos(value, this.oldElementValue);
    var offset = diff == this.oldElementValue.length ? 1 : 0;
    var prevTokenPos = -1, nextTokenPos = value.length;
    var tp;
    for (var index = 0, l = this.options.tokens.length; index < l; ++index) {
      tp = value.lastIndexOf(this.options.tokens[index], diff + offset - 1);
      if (tp > prevTokenPos)
        prevTokenPos = tp;
      tp = value.indexOf(this.options.tokens[index], diff + offset);
      if (-1 != tp && tp < nextTokenPos)
        nextTokenPos = tp;
    }
    return this.tokenBounds = [prevTokenPos + 1, nextTokenPos];
  }
});
Autocompleter.Base.prototype.getTokenBounds.getFirstDifferencePos = function(newS, oldS) {
  var boundary = Math.min(newS.length, oldS.length);
  for (var index = 0; index < boundary; ++index)
    if (newS[index] != oldS[index])
      return index;
  return boundary;
};
Ajax.Autocompleter = Class.create(Autocompleter.Base, {
  initialize: function(element, update, url, options2) {
    this.baseInitialize(element, update, options2);
    this.options.asynchronous = true;
    this.options.onComplete = this.onComplete.bind(this);
    this.options.defaultParams = this.options.parameters || null;
    this.url = url;
  },
  getUpdatedChoices: function() {
    this.startIndicator();
    var entry = encodeURIComponent(this.options.paramName) + "=" + encodeURIComponent(this.getToken());
    this.options.parameters = this.options.callback ? this.options.callback(this.element, entry) : entry;
    if (this.options.defaultParams)
      this.options.parameters += "&" + this.options.defaultParams;
    new Ajax.Request(this.url, this.options);
  },
  onComplete: function(request) {
    this.updateChoices(request.responseText);
  }
});
Autocompleter.Local = Class.create(Autocompleter.Base, {
  initialize: function(element, update, array, options2) {
    this.baseInitialize(element, update, options2);
    this.options.array = array;
  },
  getUpdatedChoices: function() {
    this.updateChoices(this.options.selector(this));
  },
  setOptions: function(options2) {
    this.options = Object.extend({
      choices: 10,
      partialSearch: true,
      partialChars: 2,
      ignoreCase: true,
      fullSearch: false,
      selector: function(instance) {
        var ret = [];
        var partial = [];
        var entry = instance.getToken();
        var count = 0;
        for (var i2 = 0; i2 < instance.options.array.length && ret.length < instance.options.choices; i2++) {
          var elem = instance.options.array[i2];
          var foundPos = instance.options.ignoreCase ? elem.toLowerCase().indexOf(entry.toLowerCase()) : elem.indexOf(entry);
          while (foundPos != -1) {
            if (foundPos == 0 && elem.length != entry.length) {
              ret.push("<li><strong>" + elem.substr(0, entry.length) + "</strong>" + elem.substr(entry.length) + "</li>");
              break;
            } else if (entry.length >= instance.options.partialChars && instance.options.partialSearch && foundPos != -1) {
              if (instance.options.fullSearch || /\s/.test(elem.substr(foundPos - 1, 1))) {
                partial.push("<li>" + elem.substr(0, foundPos) + "<strong>" + elem.substr(foundPos, entry.length) + "</strong>" + elem.substr(
                  foundPos + entry.length
                ) + "</li>");
                break;
              }
            }
            foundPos = instance.options.ignoreCase ? elem.toLowerCase().indexOf(entry.toLowerCase(), foundPos + 1) : elem.indexOf(entry, foundPos + 1);
          }
        }
        if (partial.length)
          ret = ret.concat(partial.slice(0, instance.options.choices - ret.length));
        return "<ul>" + ret.join("") + "</ul>";
      }
    }, options2 || {});
  }
});
Field.scrollFreeActivate = function(field) {
  setTimeout(function() {
    Field.activate(field);
  }, 1);
};
Ajax.InPlaceEditor = Class.create({
  initialize: function(element, url, options2) {
    this.url = url;
    this.element = element = $(element);
    this.prepareOptions();
    this._controls = {};
    arguments.callee.dealWithDeprecatedOptions(options2);
    Object.extend(this.options, options2 || {});
    if (!this.options.formId && this.element.id) {
      this.options.formId = this.element.id + "-inplaceeditor";
      if ($(this.options.formId))
        this.options.formId = "";
    }
    if (this.options.externalControl)
      this.options.externalControl = $(this.options.externalControl);
    if (!this.options.externalControl)
      this.options.externalControlOnly = false;
    this._originalBackground = this.element.getStyle("background-color") || "transparent";
    this.element.title = this.options.clickToEditText;
    this._boundCancelHandler = this.handleFormCancellation.bind(this);
    this._boundComplete = (this.options.onComplete || Prototype.emptyFunction).bind(this);
    this._boundFailureHandler = this.handleAJAXFailure.bind(this);
    this._boundSubmitHandler = this.handleFormSubmission.bind(this);
    this._boundWrapperHandler = this.wrapUp.bind(this);
    this.registerListeners();
  },
  checkForEscapeOrReturn: function(e) {
    if (!this._editing || e.ctrlKey || e.altKey || e.shiftKey)
      return;
    if (Event.KEY_ESC == e.keyCode)
      this.handleFormCancellation(e);
    else if (Event.KEY_RETURN == e.keyCode)
      this.handleFormSubmission(e);
  },
  createControl: function(mode, handler, extraClasses) {
    var control = this.options[mode + "Control"];
    var text = this.options[mode + "Text"];
    if ("button" == control) {
      var btn = document.createElement("input");
      btn.type = "submit";
      btn.value = text;
      btn.className = "editor_" + mode + "_button";
      if ("cancel" == mode)
        btn.onclick = this._boundCancelHandler;
      this._form.appendChild(btn);
      this._controls[mode] = btn;
    } else if ("link" == control) {
      var link = document.createElement("a");
      link.href = "#";
      link.appendChild(document.createTextNode(text));
      link.onclick = "cancel" == mode ? this._boundCancelHandler : this._boundSubmitHandler;
      link.className = "editor_" + mode + "_link";
      if (extraClasses)
        link.className += " " + extraClasses;
      this._form.appendChild(link);
      this._controls[mode] = link;
    }
  },
  createEditField: function() {
    var text = this.options.loadTextURL ? this.options.loadingText : this.getText();
    var fld;
    if (1 >= this.options.rows && !/\r|\n/.test(this.getText())) {
      fld = document.createElement("input");
      fld.type = "text";
      var size = this.options.size || this.options.cols || 0;
      if (0 < size)
        fld.size = size;
    } else {
      fld = document.createElement("textarea");
      fld.rows = 1 >= this.options.rows ? this.options.autoRows : this.options.rows;
      fld.cols = this.options.cols || 40;
    }
    fld.name = this.options.paramName;
    fld.value = text;
    fld.className = "editor_field";
    if (this.options.submitOnBlur)
      fld.onblur = this._boundSubmitHandler;
    this._controls.editor = fld;
    if (this.options.loadTextURL)
      this.loadExternalText();
    this._form.appendChild(this._controls.editor);
  },
  createForm: function() {
    var ipe = this;
    function addText(mode, condition) {
      var text = ipe.options["text" + mode + "Controls"];
      if (!text || condition === false)
        return;
      ipe._form.appendChild(document.createTextNode(text));
    }
    ;
    this._form = $(document.createElement("form"));
    this._form.id = this.options.formId;
    this._form.addClassName(this.options.formClassName);
    this._form.onsubmit = this._boundSubmitHandler;
    this.createEditField();
    if ("textarea" == this._controls.editor.tagName.toLowerCase())
      this._form.appendChild(document.createElement("br"));
    if (this.options.onFormCustomization)
      this.options.onFormCustomization(this, this._form);
    addText("Before", this.options.okControl || this.options.cancelControl);
    this.createControl("ok", this._boundSubmitHandler);
    addText("Between", this.options.okControl && this.options.cancelControl);
    this.createControl("cancel", this._boundCancelHandler, "editor_cancel");
    addText("After", this.options.okControl || this.options.cancelControl);
  },
  destroy: function() {
    if (this._oldInnerHTML)
      this.element.innerHTML = this._oldInnerHTML;
    this.leaveEditMode();
    this.unregisterListeners();
  },
  enterEditMode: function(e) {
    if (this._saving || this._editing)
      return;
    this._editing = true;
    this.triggerCallback("onEnterEditMode");
    if (this.options.externalControl)
      this.options.externalControl.hide();
    this.element.hide();
    this.createForm();
    this.element.parentNode.insertBefore(this._form, this.element);
    if (!this.options.loadTextURL)
      this.postProcessEditField();
    if (e)
      Event.stop(e);
  },
  enterHover: function(e) {
    if (this.options.hoverClassName)
      this.element.addClassName(this.options.hoverClassName);
    if (this._saving)
      return;
    this.triggerCallback("onEnterHover");
  },
  getText: function() {
    return this.element.innerHTML.unescapeHTML();
  },
  handleAJAXFailure: function(transport2) {
    this.triggerCallback("onFailure", transport2);
    if (this._oldInnerHTML) {
      this.element.innerHTML = this._oldInnerHTML;
      this._oldInnerHTML = null;
    }
  },
  handleFormCancellation: function(e) {
    this.wrapUp();
    if (e)
      Event.stop(e);
  },
  handleFormSubmission: function(e) {
    var form = this._form;
    var value = $F(this._controls.editor);
    this.prepareSubmission();
    var params = this.options.callback(form, value) || "";
    if (Object.isString(params))
      params = params.toQueryParams();
    params.editorId = this.element.id;
    if (this.options.htmlResponse) {
      var options2 = Object.extend({ evalScripts: true }, this.options.ajaxOptions);
      Object.extend(options2, {
        parameters: params,
        onComplete: this._boundWrapperHandler,
        onFailure: this._boundFailureHandler
      });
      new Ajax.Updater({ success: this.element }, this.url, options2);
    } else {
      var options2 = Object.extend({ method: "get" }, this.options.ajaxOptions);
      Object.extend(options2, {
        parameters: params,
        onComplete: this._boundWrapperHandler,
        onFailure: this._boundFailureHandler
      });
      new Ajax.Request(this.url, options2);
    }
    if (e)
      Event.stop(e);
  },
  leaveEditMode: function() {
    this.element.removeClassName(this.options.savingClassName);
    this.removeForm();
    this.leaveHover();
    this.element.style.backgroundColor = this._originalBackground;
    this.element.show();
    if (this.options.externalControl)
      this.options.externalControl.show();
    this._saving = false;
    this._editing = false;
    this._oldInnerHTML = null;
    this.triggerCallback("onLeaveEditMode");
  },
  leaveHover: function(e) {
    if (this.options.hoverClassName)
      this.element.removeClassName(this.options.hoverClassName);
    if (this._saving)
      return;
    this.triggerCallback("onLeaveHover");
  },
  loadExternalText: function() {
    this._form.addClassName(this.options.loadingClassName);
    this._controls.editor.disabled = true;
    var options2 = Object.extend({ method: "get" }, this.options.ajaxOptions);
    Object.extend(options2, {
      parameters: "editorId=" + encodeURIComponent(this.element.id),
      onComplete: Prototype.emptyFunction,
      onSuccess: function(transport2) {
        this._form.removeClassName(this.options.loadingClassName);
        var text = transport2.responseText;
        if (this.options.stripLoadedTextTags)
          text = text.stripTags();
        this._controls.editor.value = text;
        this._controls.editor.disabled = false;
        this.postProcessEditField();
      }.bind(this),
      onFailure: this._boundFailureHandler
    });
    new Ajax.Request(this.options.loadTextURL, options2);
  },
  postProcessEditField: function() {
    var fpc = this.options.fieldPostCreation;
    if (fpc)
      $(this._controls.editor)["focus" == fpc ? "focus" : "activate"]();
  },
  prepareOptions: function() {
    this.options = Object.clone(Ajax.InPlaceEditor.DefaultOptions);
    Object.extend(this.options, Ajax.InPlaceEditor.DefaultCallbacks);
    [this._extraDefaultOptions].flatten().compact().each(function(defs) {
      Object.extend(this.options, defs);
    }.bind(this));
  },
  prepareSubmission: function() {
    this._saving = true;
    this.removeForm();
    this.leaveHover();
    this.showSaving();
  },
  registerListeners: function() {
    this._listeners = {};
    var listener;
    $H(Ajax.InPlaceEditor.Listeners).each(function(pair) {
      listener = this[pair.value].bind(this);
      this._listeners[pair.key] = listener;
      if (!this.options.externalControlOnly)
        this.element.observe(pair.key, listener);
      if (this.options.externalControl)
        this.options.externalControl.observe(pair.key, listener);
    }.bind(this));
  },
  removeForm: function() {
    if (!this._form)
      return;
    this._form.remove();
    this._form = null;
    this._controls = {};
  },
  showSaving: function() {
    this._oldInnerHTML = this.element.innerHTML;
    this.element.innerHTML = this.options.savingText;
    this.element.addClassName(this.options.savingClassName);
    this.element.style.backgroundColor = this._originalBackground;
    this.element.show();
  },
  triggerCallback: function(cbName, arg) {
    if ("function" == typeof this.options[cbName]) {
      this.options[cbName](this, arg);
    }
  },
  unregisterListeners: function() {
    $H(this._listeners).each(function(pair) {
      if (!this.options.externalControlOnly)
        this.element.stopObserving(pair.key, pair.value);
      if (this.options.externalControl)
        this.options.externalControl.stopObserving(pair.key, pair.value);
    }.bind(this));
  },
  wrapUp: function(transport2) {
    this.leaveEditMode();
    this._boundComplete(transport2, this.element);
  }
});
Object.extend(Ajax.InPlaceEditor.prototype, {
  dispose: Ajax.InPlaceEditor.prototype.destroy
});
Ajax.InPlaceCollectionEditor = Class.create(Ajax.InPlaceEditor, {
  initialize: function($super, element, url, options2) {
    this._extraDefaultOptions = Ajax.InPlaceCollectionEditor.DefaultOptions;
    $super(element, url, options2);
  },
  createEditField: function() {
    var list2 = document.createElement("select");
    list2.name = this.options.paramName;
    list2.size = 1;
    this._controls.editor = list2;
    this._collection = this.options.collection || [];
    if (this.options.loadCollectionURL)
      this.loadCollection();
    else
      this.checkForExternalText();
    this._form.appendChild(this._controls.editor);
  },
  loadCollection: function() {
    this._form.addClassName(this.options.loadingClassName);
    this.showLoadingText(this.options.loadingCollectionText);
    var options = Object.extend({ method: "get" }, this.options.ajaxOptions);
    Object.extend(options, {
      parameters: "editorId=" + encodeURIComponent(this.element.id),
      onComplete: Prototype.emptyFunction,
      onSuccess: function(transport) {
        var js = transport.responseText.strip();
        if (!/^\[.*\]$/.test(js))
          throw "Server returned an invalid collection representation.";
        this._collection = eval(js);
        this.checkForExternalText();
      }.bind(this),
      onFailure: this.onFailure
    });
    new Ajax.Request(this.options.loadCollectionURL, options);
  },
  showLoadingText: function(text) {
    this._controls.editor.disabled = true;
    var tempOption = this._controls.editor.firstChild;
    if (!tempOption) {
      tempOption = document.createElement("option");
      tempOption.value = "";
      this._controls.editor.appendChild(tempOption);
      tempOption.selected = true;
    }
    tempOption.update((text || "").stripScripts().stripTags());
  },
  checkForExternalText: function() {
    this._text = this.getText();
    if (this.options.loadTextURL)
      this.loadExternalText();
    else
      this.buildOptionList();
  },
  loadExternalText: function() {
    this.showLoadingText(this.options.loadingText);
    var options2 = Object.extend({ method: "get" }, this.options.ajaxOptions);
    Object.extend(options2, {
      parameters: "editorId=" + encodeURIComponent(this.element.id),
      onComplete: Prototype.emptyFunction,
      onSuccess: function(transport2) {
        this._text = transport2.responseText.strip();
        this.buildOptionList();
      }.bind(this),
      onFailure: this.onFailure
    });
    new Ajax.Request(this.options.loadTextURL, options2);
  },
  buildOptionList: function() {
    this._form.removeClassName(this.options.loadingClassName);
    this._collection = this._collection.map(function(entry) {
      return 2 === entry.length ? entry : [entry, entry].flatten();
    });
    var marker = "value" in this.options ? this.options.value : this._text;
    var textFound = this._collection.any(function(entry) {
      return entry[0] == marker;
    }.bind(this));
    this._controls.editor.update("");
    var option;
    this._collection.each(function(entry, index) {
      option = document.createElement("option");
      option.value = entry[0];
      option.selected = textFound ? entry[0] == marker : 0 == index;
      option.appendChild(document.createTextNode(entry[1]));
      this._controls.editor.appendChild(option);
    }.bind(this));
    this._controls.editor.disabled = false;
    Field.scrollFreeActivate(this._controls.editor);
  }
});
Ajax.InPlaceEditor.prototype.initialize.dealWithDeprecatedOptions = function(options2) {
  if (!options2)
    return;
  function fallback(name, expr) {
    if (name in options2 || expr === void 0)
      return;
    options2[name] = expr;
  }
  ;
  fallback("cancelControl", options2.cancelLink ? "link" : options2.cancelButton ? "button" : options2.cancelLink == options2.cancelButton == false ? false : void 0);
  fallback("okControl", options2.okLink ? "link" : options2.okButton ? "button" : options2.okLink == options2.okButton == false ? false : void 0);
  fallback("highlightColor", options2.highlightcolor);
  fallback("highlightEndColor", options2.highlightendcolor);
};
Object.extend(Ajax.InPlaceEditor, {
  DefaultOptions: {
    ajaxOptions: {},
    autoRows: 3,
    // Use when multi-line w/ rows == 1
    cancelControl: "link",
    // 'link'|'button'|false
    cancelText: "cancel",
    clickToEditText: "Click to edit",
    externalControl: null,
    // id|elt
    externalControlOnly: false,
    fieldPostCreation: "activate",
    // 'activate'|'focus'|false
    formClassName: "inplaceeditor-form",
    formId: null,
    // id|elt
    highlightColor: "#ffff99",
    highlightEndColor: "#ffffff",
    hoverClassName: "",
    htmlResponse: true,
    loadingClassName: "inplaceeditor-loading",
    loadingText: "Loading...",
    okControl: "button",
    // 'link'|'button'|false
    okText: "ok",
    paramName: "value",
    rows: 1,
    // If 1 and multi-line, uses autoRows
    savingClassName: "inplaceeditor-saving",
    savingText: "Saving...",
    size: 0,
    stripLoadedTextTags: false,
    submitOnBlur: false,
    textAfterControls: "",
    textBeforeControls: "",
    textBetweenControls: ""
  },
  DefaultCallbacks: {
    callback: function(form) {
      return Form.serialize(form);
    },
    onComplete: function(transport2, element) {
      new Effect.Highlight(element, {
        startcolor: this.options.highlightColor,
        keepBackgroundImage: true
      });
    },
    onEnterEditMode: null,
    onEnterHover: function(ipe) {
      ipe.element.style.backgroundColor = ipe.options.highlightColor;
      if (ipe._effect)
        ipe._effect.cancel();
    },
    onFailure: function(transport2, ipe) {
      alert("Error communication with the server: " + transport2.responseText.stripTags());
    },
    onFormCustomization: null,
    // Takes the IPE and its generated form, after editor, before controls.
    onLeaveEditMode: null,
    onLeaveHover: function(ipe) {
      ipe._effect = new Effect.Highlight(ipe.element, {
        startcolor: ipe.options.highlightColor,
        endcolor: ipe.options.highlightEndColor,
        restorecolor: ipe._originalBackground,
        keepBackgroundImage: true
      });
    }
  },
  Listeners: {
    click: "enterEditMode",
    keydown: "checkForEscapeOrReturn",
    mouseover: "enterHover",
    mouseout: "leaveHover"
  }
});
Ajax.InPlaceCollectionEditor.DefaultOptions = {
  loadingCollectionText: "Loading options..."
};
Form.Element.DelayedObserver = Class.create({
  initialize: function(element, delay, callback) {
    this.delay = delay || 0.5;
    this.element = $(element);
    this.callback = callback;
    this.timer = null;
    this.lastValue = $F(this.element);
    Event.observe(this.element, "keyup", this.delayedListener.bindAsEventListener(this));
  },
  delayedListener: function(event) {
    if (this.lastValue == $F(this.element))
      return;
    if (this.timer)
      clearTimeout(this.timer);
    this.timer = setTimeout(this.onTimerEvent.bind(this), this.delay * 1e3);
    this.lastValue = $F(this.element);
  },
  onTimerEvent: function() {
    this.timer = null;
    this.callback(this.element, $F(this.element));
  }
});
if (!Control)
  var Control = {};
Control.Slider = Class.create({
  initialize: function(handle, track, options2) {
    var slider = this;
    if (Object.isArray(handle)) {
      this.handles = handle.collect(function(e) {
        return $(e);
      });
    } else {
      this.handles = [$(handle)];
    }
    this.track = $(track);
    this.options = options2 || {};
    this.axis = this.options.axis || "horizontal";
    this.increment = this.options.increment || 1;
    this.step = parseInt(this.options.step || "1");
    this.range = this.options.range || $R(0, 1);
    this.value = 0;
    this.values = this.handles.map(function() {
      return 0;
    });
    this.spans = this.options.spans ? this.options.spans.map(function(s) {
      return $(s);
    }) : false;
    this.options.startSpan = $(this.options.startSpan || null);
    this.options.endSpan = $(this.options.endSpan || null);
    this.restricted = this.options.restricted || false;
    this.maximum = this.options.maximum || this.range.end;
    this.minimum = this.options.minimum || this.range.start;
    this.alignX = parseInt(this.options.alignX || "0");
    this.alignY = parseInt(this.options.alignY || "0");
    this.trackLength = this.maximumOffset() - this.minimumOffset();
    this.handleLength = this.isVertical() ? this.handles[0].offsetHeight != 0 ? this.handles[0].offsetHeight : this.handles[0].style.height.replace(/px$/, "") : this.handles[0].offsetWidth != 0 ? this.handles[0].offsetWidth : this.handles[0].style.width.replace(/px$/, "");
    this.active = false;
    this.dragging = false;
    this.disabled = false;
    if (this.options.disabled)
      this.setDisabled();
    this.allowedValues = this.options.values ? this.options.values.sortBy(Prototype.K) : false;
    if (this.allowedValues) {
      this.minimum = this.allowedValues.min();
      this.maximum = this.allowedValues.max();
    }
    this.eventMouseDown = this.startDrag.bindAsEventListener(this);
    this.eventMouseUp = this.endDrag.bindAsEventListener(this);
    this.eventMouseMove = this.update.bindAsEventListener(this);
    this.handles.each(function(h, i2) {
      i2 = slider.handles.length - 1 - i2;
      slider.setValue(parseFloat(
        (Object.isArray(slider.options.sliderValue) ? slider.options.sliderValue[i2] : slider.options.sliderValue) || slider.range.start
      ), i2);
      h.makePositioned().observe("mousedown", slider.eventMouseDown);
    });
    this.track.observe("mousedown", this.eventMouseDown);
    document.observe("mouseup", this.eventMouseUp);
    document.observe("mousemove", this.eventMouseMove);
    this.initialized = true;
  },
  dispose: function() {
    var slider = this;
    Event.stopObserving(this.track, "mousedown", this.eventMouseDown);
    Event.stopObserving(document, "mouseup", this.eventMouseUp);
    Event.stopObserving(document, "mousemove", this.eventMouseMove);
    this.handles.each(function(h) {
      Event.stopObserving(h, "mousedown", slider.eventMouseDown);
    });
  },
  setDisabled: function() {
    this.disabled = true;
  },
  setEnabled: function() {
    this.disabled = false;
  },
  getNearestValue: function(value) {
    if (this.allowedValues) {
      if (value >= this.allowedValues.max())
        return this.allowedValues.max();
      if (value <= this.allowedValues.min())
        return this.allowedValues.min();
      var offset = Math.abs(this.allowedValues[0] - value);
      var newValue = this.allowedValues[0];
      this.allowedValues.each(function(v) {
        var currentOffset = Math.abs(v - value);
        if (currentOffset <= offset) {
          newValue = v;
          offset = currentOffset;
        }
      });
      return newValue;
    }
    if (value > this.range.end)
      return this.range.end;
    if (value < this.range.start)
      return this.range.start;
    return value;
  },
  setValue: function(sliderValue, handleIdx) {
    if (!this.active) {
      this.activeHandleIdx = handleIdx || 0;
      this.activeHandle = this.handles[this.activeHandleIdx];
      this.updateStyles();
    }
    handleIdx = handleIdx || this.activeHandleIdx || 0;
    if (this.initialized && this.restricted) {
      if (handleIdx > 0 && sliderValue < this.values[handleIdx - 1])
        sliderValue = this.values[handleIdx - 1];
      if (handleIdx < this.handles.length - 1 && sliderValue > this.values[handleIdx + 1])
        sliderValue = this.values[handleIdx + 1];
    }
    sliderValue = this.getNearestValue(sliderValue);
    this.values[handleIdx] = sliderValue;
    this.value = this.values[0];
    this.handles[handleIdx].style[this.isVertical() ? "top" : "left"] = this.translateToPx(sliderValue);
    this.drawSpans();
    if (!this.dragging || !this.event)
      this.updateFinished();
  },
  setValueBy: function(delta, handleIdx) {
    this.setValue(
      this.values[handleIdx || this.activeHandleIdx || 0] + delta,
      handleIdx || this.activeHandleIdx || 0
    );
  },
  translateToPx: function(value) {
    return Math.round(
      (this.trackLength - this.handleLength) / (this.range.end - this.range.start) * (value - this.range.start)
    ) + "px";
  },
  translateToValue: function(offset) {
    return offset / (this.trackLength - this.handleLength) * (this.range.end - this.range.start) + this.range.start;
  },
  getRange: function(range) {
    var v = this.values.sortBy(Prototype.K);
    range = range || 0;
    return $R(v[range], v[range + 1]);
  },
  minimumOffset: function() {
    return this.isVertical() ? this.alignY : this.alignX;
  },
  maximumOffset: function() {
    return this.isVertical() ? (this.track.offsetHeight != 0 ? this.track.offsetHeight : this.track.style.height.replace(/px$/, "")) - this.alignY : (this.track.offsetWidth != 0 ? this.track.offsetWidth : this.track.style.width.replace(/px$/, "")) - this.alignX;
  },
  isVertical: function() {
    return this.axis == "vertical";
  },
  drawSpans: function() {
    var slider = this;
    if (this.spans)
      $R(0, this.spans.length - 1).each(function(r2) {
        slider.setSpan(slider.spans[r2], slider.getRange(r2));
      });
    if (this.options.startSpan)
      this.setSpan(
        this.options.startSpan,
        $R(0, this.values.length > 1 ? this.getRange(0).min() : this.value)
      );
    if (this.options.endSpan)
      this.setSpan(
        this.options.endSpan,
        $R(this.values.length > 1 ? this.getRange(this.spans.length - 1).max() : this.value, this.maximum)
      );
  },
  setSpan: function(span, range) {
    if (this.isVertical()) {
      span.style.top = this.translateToPx(range.start);
      span.style.height = this.translateToPx(range.end - range.start + this.range.start);
    } else {
      span.style.left = this.translateToPx(range.start);
      span.style.width = this.translateToPx(range.end - range.start + this.range.start);
    }
  },
  updateStyles: function() {
    this.handles.each(function(h) {
      Element.removeClassName(h, "selected");
    });
    Element.addClassName(this.activeHandle, "selected");
  },
  startDrag: function(event) {
    if (Event.isLeftClick(event)) {
      if (!this.disabled) {
        this.active = true;
        var handle = Event.element(event);
        var pointer = [Event.pointerX(event), Event.pointerY(event)];
        var track = handle;
        if (track == this.track) {
          var offsets = this.track.cumulativeOffset();
          this.event = event;
          this.setValue(this.translateToValue(
            (this.isVertical() ? pointer[1] - offsets[1] : pointer[0] - offsets[0]) - this.handleLength / 2
          ));
          var offsets = this.activeHandle.cumulativeOffset();
          this.offsetX = pointer[0] - offsets[0];
          this.offsetY = pointer[1] - offsets[1];
        } else {
          while (this.handles.indexOf(handle) == -1 && handle.parentNode)
            handle = handle.parentNode;
          if (this.handles.indexOf(handle) != -1) {
            this.activeHandle = handle;
            this.activeHandleIdx = this.handles.indexOf(this.activeHandle);
            this.updateStyles();
            var offsets = this.activeHandle.cumulativeOffset();
            this.offsetX = pointer[0] - offsets[0];
            this.offsetY = pointer[1] - offsets[1];
          }
        }
      }
      Event.stop(event);
    }
  },
  update: function(event) {
    if (this.active) {
      if (!this.dragging)
        this.dragging = true;
      this.draw(event);
      if (Prototype.Browser.WebKit)
        window.scrollBy(0, 0);
      Event.stop(event);
    }
  },
  draw: function(event) {
    var pointer = [Event.pointerX(event), Event.pointerY(event)];
    var offsets = this.track.cumulativeOffset();
    pointer[0] -= this.offsetX + offsets[0];
    pointer[1] -= this.offsetY + offsets[1];
    this.event = event;
    this.setValue(this.translateToValue(this.isVertical() ? pointer[1] : pointer[0]));
    if (this.initialized && this.options.onSlide)
      this.options.onSlide(this.values.length > 1 ? this.values : this.value, this);
  },
  endDrag: function(event) {
    if (this.active && this.dragging) {
      this.finishDrag(event, true);
      Event.stop(event);
    }
    this.active = false;
    this.dragging = false;
  },
  finishDrag: function(event, success) {
    this.active = false;
    this.dragging = false;
    this.updateFinished();
  },
  updateFinished: function() {
    if (this.initialized && this.options.onChange)
      this.options.onChange(this.values.length > 1 ? this.values : this.value, this);
    this.event = null;
  }
});
function QBuilder(nodeName, options2, children, ext) {
  if (Qualtrics.Browser.IE && Qualtrics.Browser.Version < 9 && (nodeName == "input" || nodeName == "textarea") || nodeName == "select") {
    var el = QInputBuilder(nodeName, options2, children);
  } else {
    var doc = document;
    if (options2 && options2.document) {
      doc = options2.document;
    }
    el = doc.createElement(nodeName);
    if (!children && typeof options2 != "object") {
      children = options2;
    } else {
      for (var nom in options2) {
        if (nom == "className") {
          el.className = options2.className;
        } else if (nom == "id") {
          el.id = options2.id;
        } else if (nom == "name") {
          el.name = options2.name;
        } else if (nom.substring(0, 2) == "on") {
          el[nom] = Function(options2[nom]);
        } else if (nom == "checked") {
          if (options2[nom]) {
            el.defaultChecked = true;
            el.setAttribute("checked", "checked");
          }
        } else if (nom == "disabled") {
          if (options2[nom]) {
            el.setAttribute("disabled", "disabled");
          }
        } else if (nom == "htmlFor") {
          el.htmlFor = options2[nom];
          el.setAttribute("for", options2[nom]);
        } else if (nom == "style") {
          $(el).setStyle(options2[nom]);
        } else if (typeof options2[nom] != "undefined" && nom != "document") {
          el.setAttribute(nom, options2[nom]);
        }
      }
    }
    if (children) {
      if (typeof children === "object") {
        if (children.length) {
          for (var i2 = 0, len2 = children.length; i2 < len2; ++i2) {
            var ch = children[i2];
            if (ch === void 0) {
              ch = "undefined";
            }
            if ((typeof ch == "string" || typeof ch == "number") && ch != "") {
              el.appendChild(doc.createTextNode(ch));
            } else if (ch) {
              if (ch.nodeType) {
                el.appendChild(ch);
              } else {
                el.appendChild(doc.createTextNode(String(ch)));
              }
            } else {
            }
          }
        }
      } else {
        var node;
        if (typeof children == "string" || typeof children == "number") {
          node = doc.createTextNode(children);
        } else {
          node = children;
        }
        el.appendChild(node);
      }
    }
  }
  if (ext && el)
    Object.extend(el, ext);
  return el;
}
function QInputBuilder(nodeName, options2, children) {
  var attr2 = "";
  var doc = document;
  if (options2 && options2.document) {
    doc = options2.document;
  }
  for (var nom in options2) {
    var val = options2[nom];
    var key = "";
    switch (nom) {
      case "className":
        key = "class";
        break;
      case "id":
        key = "id";
        break;
      case "checked":
        if (options2[nom]) {
          key = "checked";
        }
        break;
      case "htmlFor":
        key = "for";
        break;
      default:
        key = nom;
    }
    if (val != void 0) {
      attr2 += key + '="' + val + '" ';
    }
  }
  var parent = QBuilder("div");
  parent.innerHTML = "<" + nodeName + " " + attr2 + " />";
  var el = parent.firstChild.cloneNode(true);
  removeElement(parent);
  if (children) {
    var type = typeof children;
    if (type === "object") {
      for (var i2 = 0, len2 = children.length; i2 < len2; ++i2) {
        var ch = children[i2];
        var node;
        if (typeof ch == "string" || typeof ch == "number") {
          node = doc.createTextNode(ch);
        } else {
          node = ch;
        }
        if (node) {
          el.appendChild(node);
        }
      }
    } else if (type == "string" || type == "number") {
      el.appendChild(doc.createTextNode(children));
    }
  }
  return el;
}
function QEntity(str, mode) {
  str = str ? str : "";
  mode = mode ? mode : "string";
  var e = document.createElement("div");
  e.innerHTML = str;
  if (mode == "numeric") {
    return "&#" + e.innerHTML.charCodeAt(0) + ";";
  } else if (mode == "utf16") {
    var un = e.innerHTML.charCodeAt(0).toString(16);
    while (un.length < 4)
      un = "0" + un;
    return "\\u" + un;
  } else
    return e.innerHTML;
}
function makeSortable(listIds) {
  if (listIds.constructor != Array) {
    var listIds = [listIds];
  }
  for (var i2 = 0; i2 < listIds.length; i2++) {
    var listId = listIds[i2];
    Sortable.create(listId, {
      dropOnEmpty: true,
      containment: listIds,
      constraint: false,
      scroll: $("body"),
      onChange: function(o) {
        rankOrderAll(listIds, o);
        updateInputValues(listIds);
      },
      onUpdate: function(o) {
        updateInputValues(listIds);
        adjustCSS(listIds);
      }
    });
    if ("ontouchstart" in document.documentElement) {
      var ul = $(listId);
      var sortable = Sortable.sortables[listId];
      for (var x = 0, len2 = sortable.draggables.length; x < len2; ++x) {
        var draggable = sortable.draggables[x];
        var li = draggable.element;
        Event.observe(li, "touchstart", draggable.eventMouseDown);
        Event.observe(document, "touchend", Draggables.eventMouseUp);
        Event.observe(document, "touchmove", Draggables.eventMouseMove);
      }
    }
  }
}
function updateInputValues(listIds) {
  if (listIds.constructor != Array) {
    var listIds = [listIds];
  }
  for (var i2 = 0; i2 < listIds.length; i2++) {
    var listId = listIds[i2];
    var rank = "";
    var choice = "";
    var choiceId = "";
    list = $(listId);
    var groupId = list.getAttribute("rel");
    for (var j = 0; j < list.childNodes.length; j++) {
      var choiceItem = list.childNodes[j];
      if (choiceItem.nodeName != "LI")
        continue;
      choiceId = choiceItem.id;
      for (var ranki = 0; ranki < choiceItem.childNodes.length; ranki++) {
        if (choiceItem.childNodes[ranki].className == "rank") {
          rank = choiceItem.childNodes[ranki].innerHTML;
        }
      }
      for (var ranki = 0; ranki < choiceItem.childNodes.length; ranki++) {
        if (choiceItem.childNodes[ranki].className == "choice") {
          choice = choiceItem.childNodes[ranki].innerHTML;
        }
      }
      if ($(choiceId + "~Group")) {
        if (listId.indexOf("items") == -1) {
          if (list.getAttribute("maxChoices")) {
            if (list.childNodes.length > list.getAttribute("maxChoices")) {
              list.previous(1).addClassName("ValidationError");
              list.previous().innerHTML = maxChoicesMsg;
              list.previous().addClassName("ValidationError");
            } else {
              list.previous(1).removeClassName("ValidationError");
              list.previous().innerHTML = "";
              list.previous().removeClassName("ValidationError");
            }
          }
          $(choiceId + "~Group").value = groupId;
          $(choiceId + "~Rank").value = rank;
        } else {
          $(choiceId + "~Group").value = "";
          $(choiceId + "~Rank").value = "";
        }
      } else if ($(choiceId + "~Rank")) {
        $(choiceId + "~Rank").value = rank;
      } else {
        console.error("Error! there is no input: " + listId + "~Rank");
      }
    }
  }
}
function rankOrderAll(listIds, itemBeingDragged) {
  for (var i2 = 0; i2 < listIds.length; i2++) {
    var listId = listIds[i2];
    list = $(listId);
    if (!list.edited) {
      $(list).removeClassName("NotEdited");
      $(list).addClassName("Edited");
      list.edited = true;
    }
    rankOrder(list, itemBeingDragged);
  }
}
function rankOrder(list2, itemBeingDragged) {
  var rank = 0;
  var stacked = false;
  if ($(list2).getAttribute("stacked")) {
    stacked = true;
    var progressCounterID = list2.getAttribute("progressCounter");
    var itemCount = list2.getAttribute("itemCount");
    if ($(progressCounterID)) {
      $(progressCounterID).innerHTML = list2.childNodes.length + " / " + itemCount;
    }
  }
  for (var i2 = 0; i2 < list2.childNodes.length; i2++) {
    var listItem = list2.childNodes[i2];
    if (!listItem || listItem.nodeName != "LI") {
      continue;
    }
    if (stacked) {
      if ($(listItem).getAttribute("id") == $(itemBeingDragged).getAttribute("id")) {
      }
      var stackedClasses = "";
      if ($(listItem).hasClassName("last")) {
        stackedClasses += " last";
      }
      if ($(listItem).hasClassName("penultimate")) {
        stackedClasses += " penultimate";
      }
      if ($(listItem).hasClassName("antepenultimate")) {
        stackedClasses += " antepenultimate";
      }
    }
    rank++;
    if (i2 % 2 == 0) {
      listItem.className = "BorderColor " + list2.getAttribute("regularClass");
    } else {
      listItem.className = "BorderColor " + list2.getAttribute("altClass");
    }
    if (stacked) {
      listItem.className += " stack";
    }
    if (stacked) {
      listItem.className += stackedClasses;
      if ($(listItem).getAttribute("id") == $(itemBeingDragged).getAttribute("id")) {
      }
      if ($(listItem).getAttribute("id") != $(itemBeingDragged).getAttribute("id")) {
      }
    }
    var listItemContents = list2.childNodes[i2].childNodes;
    for (var j = 0; j < listItemContents.length; j++) {
      if (listItemContents[j].className == "rank") {
        listItemContents[j].innerHTML = rank;
      }
    }
  }
}
function adjustCSS(listIds) {
  for (var i2 = 0; i2 < listIds.length; i2++) {
    var listId = listIds[i2];
    list = $(listId);
    adjustListCSS(list);
  }
}
function adjustListCSS(list2) {
  var rank = 0;
  if ($(list2).getAttribute("stacked")) {
    for (var i2 = 0; i2 < list2.childNodes.length; i2++) {
      var listItem = list2.childNodes[i2];
      if (!listItem || listItem.nodeName != "LI")
        continue;
      rank++;
      $(listItem).removeClassName("antepenultimate");
      $(listItem).removeClassName("penultimate");
      if (list2.childNodes.length > 2) {
        if (i2 == list2.childNodes.length - 2) {
          $(listItem).addClassName("penultimate");
        } else if (i2 == list2.childNodes.length - 3) {
          $(listItem).addClassName("antepenultimate");
        }
      } else if (list2.childNodes.length == 2) {
        if (i2 == list2.childNodes.length - 1) {
          $(listItem).addClassName("penultimate");
        } else if (i2 == list2.childNodes.length - 2) {
          $(listItem).addClassName("antepenultimate");
        }
      } else if (list2.childNodes.length == 1) {
        $(listItem).addClassName("antepenultimate");
      }
    }
  }
}
if (window.Effect) {
  Effect.Scroll = Class.create();
  Object.extend(Object.extend(Effect.Scroll.prototype, Effect.Base.prototype), {
    initialize: function(element) {
      this.element = $(element);
      var options2 = Object.extend({
        x: 0,
        y: 0,
        mode: "absolute"
      }, arguments[1] || {});
      this.start(options2);
    },
    setup: function() {
      if (this.options.continuous && !this.element._ext) {
        this.element.cleanWhitespace();
        this.element._ext = true;
        this.element.appendChild(this.element.firstChild);
      }
      this.originalLeft = this.element.scrollLeft;
      this.originalTop = this.element.scrollTop;
      if (this.options.mode == "absolute") {
        this.options.x -= this.originalLeft;
        this.options.y -= this.originalTop;
      } else {
      }
    },
    update: function(position) {
      if (this.element.offsetWidth) {
        this.element.scrollLeft = this.options.x * position + this.originalLeft;
        this.element.scrollTop = this.options.y * position + this.originalTop;
      }
    }
  });
  Effect.ScrollContainerTo = Class.create();
  Object.extend(Object.extend(Effect.ScrollContainerTo.prototype, Effect.Scroll.prototype), {
    initialize: function(element, toElement) {
      this.element = $(element);
      Position.prepare();
      if (!toElement.parentNode || !element.parentNode) {
        return;
      }
      var element_y = Position.cumulativeOffset($(element))[1];
      var toElement_y = Position.cumulativeOffset($(toElement))[1];
      var y = toElement_y - element_y;
      var offset = 0;
      var options2 = arguments[2];
      if (options2 && options2.offset) {
        offset = options2.offset;
      }
      options2 = Object.extend({
        x: 0,
        y: y + offset,
        mode: "absolute"
      }, options2 || {});
      this.start(options2);
    }
  });
  Effect.ScrollToY = Class.create();
  Object.extend(Object.extend(Effect.ScrollToY.prototype, Effect.Base.prototype), {
    initialize: function(y) {
      this.y = y;
      this.start(arguments[1] || {});
    },
    setup: function() {
      Position.prepare();
      var offsets = [0, this.y];
      var max = window.innerHeight ? window.height - window.innerHeight : document.body.scrollHeight - (document.documentElement.clientHeight ? document.documentElement.clientHeight : document.body.clientHeight);
      this.scrollStart = Position.deltaY;
      this.delta = (offsets[1] > max ? max : offsets[1]) - this.scrollStart;
      if (!this.delta) {
        this.cancel();
      }
    },
    update: function(position) {
      Position.prepare();
      window.scrollTo(Position.deltaX, this.scrollStart + position * this.delta);
    }
  });
  Effect.OverlayHighlight = function(element, options2) {
    var overlayOptions = Object.extend({
      color: "#ffff99"
    }, arguments[1] || {});
    element = QualtricsCPTools.Highlighter.autoHighlight(element, overlayOptions).element;
    var oldOpacity = Element.getInlineOpacity(element);
    options2 = Object.extend({
      from: element.getOpacity() || 1,
      to: 0,
      afterFinishInternal: function(effect) {
        if (effect.options.to != 0)
          return;
        effect.element.hide().setStyle({ opacity: oldOpacity });
      }
    }, arguments[1] || {});
    return new Effect.Opacity(element, options2);
  };
}
Draggable.prototype.updateDrag = function(event, pointer) {
  if (!this.dragging)
    this.startDrag(event);
  var fixedOffset = [0, 0];
  if (this.options.fixedPosition) {
    fixedOffset = [getScrollInfo()[0], getScrollInfo()[1]];
  }
  if (!this.options.quiet) {
    Position.prepare();
    var point = pointer;
    point[0] -= fixedOffset[0];
    point[1] -= fixedOffset[1];
    Droppables.show(point, this.element);
  }
  pointer[0] += fixedOffset[0];
  pointer[1] += fixedOffset[1];
  Draggables.notify("onDrag", this, event);
  this.draw(pointer);
  if (this.options.change)
    this.options.change(this);
  if (this.options.scroll) {
    this.stopScrolling();
    var p;
    if (this.options.scroll == window) {
      with (this._getWindowScroll(this.options.scroll)) {
        p = [left, top, left + width, top + height];
      }
    } else {
      p = Position.page(this.options.scroll).toArray();
      p[0] += fixedOffset[0];
      p[1] += fixedOffset[1];
      p.push(p[0] + this.options.scroll.offsetWidth);
      p.push(p[1] + this.options.scroll.offsetHeight);
    }
    var speed = [0, 0];
    if (pointer[0] < p[0] + this.options.scrollSensitivity)
      speed[0] = pointer[0] - (p[0] + this.options.scrollSensitivity);
    if (pointer[1] < p[1] + this.options.scrollSensitivity)
      speed[1] = pointer[1] - (p[1] + this.options.scrollSensitivity);
    if (pointer[0] > p[2] - this.options.scrollSensitivity)
      speed[0] = pointer[0] - (p[2] - this.options.scrollSensitivity);
    if (pointer[1] > p[3] - this.options.scrollSensitivity)
      speed[1] = pointer[1] - (p[3] - this.options.scrollSensitivity);
    this.startScrolling(speed);
  }
  if (Prototype.Browser.WebKit && !Qualtrics.Browser.MobileWebKit)
    window.scrollBy(0, 0);
  var el = Event.element(event);
  if (el && el.getAttribute && el.getAttribute("distancedragged")) {
    if (!el.dragTracker) {
      el.dragTracker = [pointer[0], pointer[1]];
    }
    var distanceDragged = [Math.abs(pointer[0] - el.dragTracker[0]), Math.abs(pointer[1] - el.dragTracker[1])];
    el.setAttribute("distancedraggedx", distanceDragged[0]);
    el.setAttribute("distancedraggedy", distanceDragged[1]);
    el.setAttribute("distancedragged", distanceDragged[0] + distanceDragged[1]);
  }
  Event.stop(event);
};
Draggable.prototype._getWindowScroll = function(w) {
  var T, L, W, H;
  with (w.document) {
    if (w.document.documentElement && documentElement.scrollTop) {
      T = documentElement.scrollTop;
      L = documentElement.scrollLeft;
    } else if (w.document.body) {
      T = body.scrollTop || window.pageYOffset || 0;
      L = body.scrollLeft || window.pageXOffset || 0;
    }
    if (w.innerWidth) {
      W = w.innerWidth;
      H = w.innerHeight;
    } else if (w.document.documentElement && documentElement.clientWidth) {
      W = documentElement.clientWidth;
      H = documentElement.clientHeight;
    } else {
      W = body.offsetWidth;
      H = body.offsetHeight;
    }
  }
  return { top: T, left: L, width: W, height: H };
};
Draggable.prototype.scroll = function() {
  var current = /* @__PURE__ */ new Date();
  var delta = current - this.lastScrolled;
  this.lastScrolled = current;
  if (this.scrollSpeed[1] < 0 && this.options.scroll.scrollTop !== void 0 && this.options.scroll.scrollTop < 1) {
    return;
  }
  if (this.options.scroll == window) {
    with (this._getWindowScroll(this.options.scroll)) {
      if (this.scrollSpeed[0] || this.scrollSpeed[1]) {
        var d = delta / 1e3;
        this.options.scroll.scrollTo(left + d * this.scrollSpeed[0], top + d * this.scrollSpeed[1]);
      }
    }
  } else {
    this.options.scroll.scrollLeft += this.scrollSpeed[0] * delta / 1e3;
    this.options.scroll.scrollTop += this.scrollSpeed[1] * delta / 1e3;
  }
  Position.prepare();
  Droppables.show(Draggables._lastPointer, this.element);
  Draggables.notify("onDrag", this);
  if (this._isScrollChild) {
    Draggables._lastScrollPointer = Draggables._lastScrollPointer || $A(Draggables._lastPointer);
    Draggables._lastScrollPointer[0] += this.scrollSpeed[0] * delta / 1e3;
    Draggables._lastScrollPointer[1] += this.scrollSpeed[1] * delta / 1e3;
    if (Draggables._lastScrollPointer[0] < 0)
      Draggables._lastScrollPointer[0] = 0;
    if (Draggables._lastScrollPointer[1] < 0)
      Draggables._lastScrollPointer[1] = 0;
    this.draw(Draggables._lastPointer);
  }
  if (this.options.change)
    this.options.change(this);
};
Draggable.prototype.initDrag = function(event) {
  if (this.element.hasAttribute("grabClass"))
    $(this.element).addClassName(this.element.getAttribute("grabClass"));
  var trash = $("g" + this.element.parentNode.id);
  if (trash)
    QualtricsTools.fastDown($(trash), "icon").appear({ duration: 0.5 });
  if (!Object.isUndefined(Draggable._dragging[this.element]) && Draggable._dragging[this.element])
    return;
  if (Event.isLeftClick(event) || event.touches) {
    var src = Event.element(event);
    var el = Event.element(event);
    if (el) {
      el.dragTracker = null;
      el.setAttribute("distancedraggedx", "0");
      el.setAttribute("distancedraggedy", "0");
      el.setAttribute("distancedragged", "0");
    }
    if (src.getAttribute("preventDrag")) {
      return;
    }
    if ((tag_name = src.tagName.toUpperCase()) && (tag_name == "INPUT" || tag_name == "SELECT" || tag_name == "OPTION" || tag_name == "BUTTON" || tag_name == "TEXTAREA"))
      return;
    var pointer = [Event.pointerX(event), Event.pointerY(event)];
    var pos = Position.cumulativeOffset(this.element);
    this.offset = [0, 1].map(function(i2) {
      return pointer[i2] - pos[i2];
    });
    if (this.element.parentNode && !this.options.ignoreParentScrollTop) {
      this.offset[1] = this.offset[1] + this.element.parentNode.scrollTop;
    }
    Draggables.activate(this);
    Event.stop(event);
  }
};
Draggable.prototype.endDrag2 = Draggable.prototype.endDrag;
Draggable.prototype.endDrag = function(event) {
  if (this.element.hasAttribute("grabClass"))
    $(this.element).removeClassName(this.element.getAttribute("grabClass"));
  var trash = $("g" + this.element.parentNode.id);
  if (trash)
    QualtricsTools.fastDown($(trash), "icon").fade({ duration: 0.5 });
  this.endDrag2(event);
};
Droppables.isAffected2 = Droppables.isAffected;
Droppables.isAffectedScroll = function(point, element, drop) {
  return drop.element != element && (!drop._containers || this.isContained(element, drop)) && (!drop.accept || Element.classNames(element).detect(
    function(v) {
      return drop.accept.include(v);
    }
  )) && Position.withinIncludingScrolloffsets(drop.element, point[0], point[1]);
};
Droppables.isAffected = function(point, element, drop) {
  if (!drop.hasOwnProperty("isFixed"))
    drop.isFixed = QualtricsTools.isFixed(drop.element);
  if (drop.isFixed)
    point = [point[0] - scrollInfo[0], point[1] - scrollInfo[1]];
  if (element && element.parentElement && $(element.parentElement).retrieve("SortableMayScroll")) {
    return this.isAffectedScroll(point, element, drop);
  }
  return this.isAffected2(point, element, drop);
};
Effect.SlideRight = function(element) {
  element = $(element);
  Element.cleanWhitespace(element);
  var oldInnerRight = Element.getStyle(element.firstChild, "right");
  var elementDimensions = Element.getDimensions(element);
  return new Effect.Scale(
    element,
    100,
    Object.extend({
      scaleContent: false,
      scaleY: false,
      scaleFrom: 0,
      scaleMode: { originalHeight: elementDimensions.height, originalWidth: elementDimensions.width },
      restoreAfterFinish: true,
      afterSetup: function(effect) {
        with (Element) {
          makePositioned(effect.element);
          makePositioned(effect.element.firstChild);
          if (window.opera)
            setStyle(effect.element, { top: "" });
          makeClipping(effect.element);
          setStyle(effect.element, { width: "0px" });
          show(element);
        }
      },
      afterUpdateInternal: function(effect) {
        with (Element) {
          setStyle(effect.element.firstChild, { right: effect.dims[0] - effect.element.clientWidth + "px" });
        }
      },
      afterFinishInternal: function(effect) {
        with (Element) {
          undoClipping(effect.element);
          undoPositioned(effect.element.firstChild);
          undoPositioned(effect.element);
          setStyle(effect.element.firstChild, { right: oldInnerRight });
        }
      }
    }, arguments[1] || {})
  );
};
Effect.SlideLeft = function(element) {
  element = $(element);
  Element.cleanWhitespace(element);
  var oldInnerRight = Element.getStyle(element.firstChild, "right");
  return new Effect.Scale(
    element,
    0,
    Object.extend({
      scaleContent: false,
      scaleY: false,
      scaleMode: "box",
      scaleFrom: 100,
      restoreAfterFinish: true,
      beforeStartInternal: function(effect) {
        with (Element) {
          makePositioned(effect.element);
          makePositioned(effect.element.firstChild);
          if (window.opera)
            setStyle(effect.element, { top: "" });
          makeClipping(effect.element);
          show(element);
        }
      },
      afterUpdateInternal: function(effect) {
        with (Element) {
          setStyle(effect.element.firstChild, { right: effect.dims[0] - effect.element.clientWidth + "px" });
        }
      },
      afterFinishInternal: function(effect) {
        with (Element) {
          [hide, undoClipping].call(effect.element);
          undoPositioned(effect.element.firstChild);
          undoPositioned(effect.element);
          setStyle(effect.element.firstChild, { right: oldInnerRight });
        }
      }
    }, arguments[1] || {})
  );
};
Effect.BlindLeft = function(element) {
  element = $(element);
  element.makeClipping();
  return new Effect.Scale(
    element,
    0,
    Object.extend({
      scaleContent: false,
      scaleY: false,
      restoreAfterFinish: true,
      afterFinishInternal: function(effect) {
        effect.element.hide().undoClipping();
      }
    }, arguments[1] || {})
  );
};
Effect.BlindRight = function(element) {
  element = $(element);
  var elementDimensions = element.getDimensions();
  return new Effect.Scale(element, 100, Object.extend({
    scaleContent: false,
    scaleY: false,
    scaleFrom: 0,
    scaleMode: { originalHeight: elementDimensions.height, originalWidth: elementDimensions.width },
    restoreAfterFinish: true,
    afterSetup: function(effect) {
      effect.element.makeClipping().setStyle({ width: "0px" }).show();
    },
    afterFinishInternal: function(effect) {
      effect.element.undoClipping();
    }
  }, arguments[1] || {}));
};
Effect.Transitions.InQuad = function(x) {
  return x * x;
};
Effect.Transitions.OutQuad = function(x) {
  return -1 * x * (x - 2);
};
Effect.Transitions.InExpo = function(x) {
  return x == 0 ? 0 : Math.pow(2, 10 * (x - 1));
};
Effect.Transitions.Elastic = function(x) {
  if (x == 0 || x == 1)
    return x;
  var p = 0.3;
  var s = p / 4;
  return -(Math.pow(2, 10 * (x -= 1)) * Math.sin((x * 1 - s) * (2 * Math.PI) / p));
};
var INQUAD = Effect.Transitions.InQuad;
var OUTQUAD = Effect.Transitions.OutQuad;
var INEXPO = Effect.Transitions.InExpo;
var ELASTIC = Effect.Transitions.Elastic;
Effect.Transitions.Elastic = function(pos) {
  return -1 * Math.pow(4, -8 * pos) * Math.sin((pos * 6 - 1) * (2 * Math.PI) / 2) + 1;
};
Effect.Transitions.SwingFromTo = function(pos) {
  var s = 5.70158;
  if ((pos /= 0.5) < 1)
    return 0.5 * (pos * pos * (((s *= 1.525) + 1) * pos - s));
  return 0.5 * ((pos -= 2) * pos * (((s *= 1.525) + 1) * pos + s) + 2);
};
Effect.Transitions.SwingFrom = function(pos) {
  var s = 1.70158;
  return pos * pos * ((s + 1) * pos - s);
};
Effect.Transitions.SwingTo = function(pos) {
  var s = 1.70158;
  return (pos -= 1) * pos * ((s + 1) * pos + s) + 1;
};
Effect.Transitions.Bounce = function(pos) {
  if (pos < 1 / 2.75) {
    return 7.5625 * pos * pos;
  } else if (pos < 2 / 2.75) {
    return 7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75;
  } else if (pos < 2.5 / 2.75) {
    return 7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375;
  } else {
    return 7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375;
  }
};
Effect.Transitions.BouncePast = function(pos) {
  if (pos < 1 / 2.75) {
    return 7.5625 * pos * pos;
  } else if (pos < 2 / 2.75) {
    return 2 - (7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75);
  } else if (pos < 2.5 / 2.75) {
    return 2 - (7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375);
  } else {
    return 2 - (7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375);
  }
};
Effect.Transitions.EaseFromTo = function(pos) {
  if ((pos /= 0.5) < 1)
    return 0.5 * Math.pow(pos, 4);
  return -0.5 * ((pos -= 2) * Math.pow(pos, 3) - 2);
};
Effect.Transitions.EaseFrom = function(pos) {
  return Math.pow(pos, 4);
};
Effect.Transitions.EaseTo = function(pos) {
  return Math.pow(pos, 0.25);
};
Control.Slider.prototype.initialize = function(handle, track, options2) {
  var slider = this;
  if (Object.isArray(handle)) {
    this.handles = handle.collect(function(e) {
      return $(e);
    });
  } else {
    this.handles = [$(handle)];
  }
  this.track = $(track);
  this.options = options2 || {};
  this.axis = this.options.axis || "horizontal";
  this.increment = this.options.increment || 1;
  this.step = parseInt(this.options.step || "1");
  this.range = this.options.range || $R(0, 1);
  this.value = 0;
  this.values = this.handles.map(function() {
    return 0;
  });
  this.spans = this.options.spans ? this.options.spans.map(function(s) {
    return $(s);
  }) : false;
  this.options.startSpan = $(this.options.startSpan || null);
  this.options.endSpan = $(this.options.endSpan || null);
  this.restricted = this.options.restricted || false;
  this.maximum = this.options.maximum || this.range.end;
  this.minimum = this.options.minimum || this.range.start;
  this.alignX = parseInt(this.options.alignX || "0");
  this.alignY = parseInt(this.options.alignY || "0");
  this.trackLength = this.maximumOffset() - this.minimumOffset();
  this.handleLength = this.isVertical() ? this.handles[0].offsetHeight != 0 ? this.handles[0].offsetHeight : this.handles[0].style.height.replace(/px$/, "") : this.handles[0].offsetWidth != 0 ? this.handles[0].offsetWidth : this.handles[0].style.width.replace(/px$/, "");
  this.active = false;
  this.dragging = false;
  this.disabled = false;
  if (this.options.disabled)
    this.setDisabled();
  this.allowedValues = this.options.values ? this.options.values.sortBy(Prototype.K) : false;
  if (this.allowedValues) {
    this.minimum = this.allowedValues.min();
    this.maximum = this.allowedValues.max();
  }
  this.eventMouseDown = this.startDrag.bindAsEventListener(this);
  this.eventMouseUp = this.endDrag.bindAsEventListener(this);
  this.eventMouseMove = this.update.bindAsEventListener(this);
  this.handles.each(function(h, i2) {
    i2 = slider.handles.length - 1 - i2;
    slider.setValue(parseFloat(
      (Object.isArray(slider.options.sliderValue) ? slider.options.sliderValue[i2] : slider.options.sliderValue) || slider.range.start
    ), i2);
    h.makePositioned().observe("mousedown", slider.eventMouseDown);
  });
  this.track.observe("mousedown", this.eventMouseDown);
  document.observe("mouseup", this.eventMouseUp);
  document.observe("mousemove", this.eventMouseMove);
  this.track.observe("touchstart", this.eventMouseDown);
  document.observe("touchend", this.eventMouseUp);
  document.observe("touchmove", this.eventMouseMove);
  this.initialized = true;
};
Control.Slider.prototype.update = function(event) {
  if (this.active) {
    if (!this.dragging)
      this.dragging = true;
    this.draw(event);
    if (Prototype.Browser.WebKit && !event.touches)
      window.scrollBy(0, 0);
    Event.stop(event);
  }
};
Control.Slider.prototype.startDrag = function(event) {
  if (Event.isLeftClick(event) || event.touches) {
    if (!this.disabled) {
      this.active = true;
      var handle = Event.element(event);
      var pointer = [Event.pointerX(event), Event.pointerY(event)];
      var track = handle;
      if (track == this.track) {
        var offsets = Element.cumulativeOffset(this.track);
        this.event = event;
        if (Qualtrics.Browser.IE == true && Qualtrics.Browser.Version <= 7 && $(document.body).getStyle("direction") === "rtl") {
          this.setValue(this.translateToValue(
            (this.isVertical() ? pointer[1] - offsets[1] : pointer[0] - offsets[0]) - this.handleLength * 2
          ));
        } else {
          this.setValue(this.translateToValue(
            (this.isVertical() ? pointer[1] - offsets[1] : pointer[0] - offsets[0]) - this.handleLength / 2
          ));
        }
        offsets = Position.cumulativeOffset(this.activeHandle);
        this.offsetX = pointer[0] - offsets[0];
        this.offsetY = pointer[1] - offsets[1];
      } else {
        while (this.handles.indexOf(handle) == -1 && handle.parentNode)
          handle = handle.parentNode;
        if (this.handles.indexOf(handle) != -1) {
          this.activeHandle = handle;
          this.activeHandleIdx = this.handles.indexOf(this.activeHandle);
          this.updateStyles();
          offsets = Position.cumulativeOffset(this.activeHandle);
          this.offsetX = pointer[0] - offsets[0];
          this.offsetY = pointer[1] - offsets[1];
        }
      }
      this.draw(event);
    }
    Event.stop(event);
  }
};
Effect.MorphClip = Class.create();
Object.extend(Object.extend(Effect.MorphClip.prototype, Effect.Base.prototype), {
  initialize: function(element) {
    this.element = $(element);
    if (!this.element)
      throw Effect._elementDoesNotExistError;
    var options2 = Object.extend({
      style: {}
    }, arguments[1] || {});
    this.clip = options2.clip;
    this.start(options2);
  },
  setup: function() {
    this.transform = {
      originalValue: this.parseCSSClip(this.element.getStyle("clip")),
      targetValue: this.parseCSSClip(this.clip)
    };
  },
  parseCSSClip: function(str) {
    var regex = /rect\(([\d|.]+)px,*\s*([\d|.]+)px,*\s*([\d|.]+)px,*\s*([\d|.]+)px\)/;
    var matches = str.match(regex);
    return { top: matches[1] * 1, right: matches[2] * 1, bottom: matches[3] * 1, left: matches[4] * 1 };
  },
  update: function(position) {
    var o = this.transform.originalValue;
    var t = this.transform.targetValue;
    var top2 = o.top + Math.round((t.top - o.top) * position * 1e3) / 1e3;
    var right = o.right + Math.round((t.right - o.right) * position * 1e3) / 1e3;
    var bottom = o.bottom + Math.round((t.bottom - o.bottom) * position * 1e3) / 1e3;
    var left2 = o.left + Math.round((t.left - o.left) * position * 1e3) / 1e3;
    var style = {
      clip: "rect(" + top2 + "px," + right + "px," + bottom + "px," + left2 + "px)"
    };
    this.element.setStyle(style, true);
  }
});
Effect.Opacity = Class.create(Effect.Base, {
  initialize: function(element) {
    this.element = $(element);
    if (!this.element)
      throw Effect._elementDoesNotExistError;
    if (Prototype.Browser.IE && (this.element.currentStyle && !this.element.currentStyle.hasLayout))
      this.element.setStyle({ zoom: 1 });
    var options2 = Object.extend({
      from: this.element.getOpacity() || 0,
      to: 1
    }, arguments[1] || {});
    this.start(options2);
  },
  update: function(position) {
    this.element.setOpacity(position);
  }
});
Object.extend(Qualtrics, {
  Browser: {
    IE: !!(window.attachEvent && !window.opera),
    Opera: !!window.opera,
    WebKit: navigator.userAgent.indexOf("AppleWebKit/") > -1,
    Safari: navigator.userAgent.indexOf("Safari/") > -1,
    MobileWebKit: navigator.userAgent.indexOf("AppleWebKit/") > -1 && navigator.userAgent.indexOf("Mobile/") > -1,
    Gecko: navigator.userAgent.indexOf("Gecko") > -1 && navigator.userAgent.indexOf("KHTML") == -1,
    Firefox: navigator.userAgent.indexOf("Firefox") > -1,
    Version: null,
    Features: null,
    getVersion: function() {
      var ua = navigator.userAgent.toLowerCase();
      var v = "99";
      if (Qualtrics.Browser.Firefox) {
        v = ua.substring(ua.lastIndexOf("firefox/") + 8, ua.lastIndexOf("firefox/") + 10);
      } else if (Qualtrics.Browser.WebKit) {
        v = ua.substring(ua.indexOf("applewebkit/") + 12, ua.indexOf(" (khtml"));
      } else if (Qualtrics.Browser.IE) {
        v = ua.substring(ua.indexOf("msie ") + 5, ua.indexOf("; w"));
      }
      if (v.indexOf(".") != -1) {
        v = v.substring(0, v.indexOf("."));
      }
      return Number(v);
    },
    getFeatures: function() {
      var b = Qualtrics.Browser;
      var f = {
        onPaste: !(b.Firefox && b.Version < 3 || b.Opera)
      };
      return f;
    }
  },
  Error: function(msg) {
    QError(msg);
    if (window.customErrorHandler) {
      window.customErrorHandler(msg);
    }
  },
  /**
  * Tells you if an object is empty even if its an array.
  */
  isEmpty: function(obj) {
    if (Object.isArray(obj)) {
      if (!obj.length)
        return true;
    } else if (!Object.values(obj).length) {
      return true;
    }
    return false;
  },
  getArrayValues: function(obj) {
    if (Object.isArray(obj)) {
      return obj;
    } else {
      return Object.values(obj);
    }
  },
  isNumericKey: function(evt) {
    return evt.keyCode >= 48 && evt.keyCode <= 57 || evt.keyCode >= 96 && evt.keyCode <= 105 || evt.keyCode == 8 || //BackSpace
    evt.keyCode == 9 || //Tab
    evt.keyCode == 12 || //Clear
    evt.keyCode == 27 || //Escape
    evt.keyCode == 37 || //Left
    evt.keyCode == 39 || //Right
    evt.keyCode == 46 || //Delete
    evt.keyCode == 190 && !evt.shiftKey || evt.keyCode == 110 && !evt.shiftKey || //period
    evt.keyCode == 188 && !evt.shiftKey || //comma
    evt.keyCode == 109 && !evt.shiftKey || // - for negatives
    evt.keyCode == 189 && !evt.shiftKey || evt.metaKey || evt.ctrlKey || evt.altKey;
  },
  //if it's a comma or period
  isNumberFormatKey: function(evt) {
    return evt.keyCode == 190 && !evt.shiftKey || evt.keyCode == 110 && !evt.shiftKey || //period
    evt.keyCode == 188 && !evt.shiftKey;
  },
  alphaNumericValidation: function(el, evt) {
    if (el.getAttribute("validation")) {
      var validation = el.getAttribute("validation");
      if (validation == "Number" || validation == "AlphaNumeric" || validation == "Integer") {
        if (this.isNumericKey(evt)) {
          if (validation == "Integer" && this.isNumberFormatKey(evt)) {
            Event.stop(evt);
            return false;
          }
        } else {
          if (validation == "Number" || validation == "Integer") {
            if (evt.keyCode == 173) {
            } else {
              Event.stop(evt);
              return false;
            }
          }
          if (validation == "AlphaNumeric") {
            if (evt.keyCode >= 65 && evt.keyCode <= 90) {
            } else {
              Event.stop(evt);
              return false;
            }
          }
        }
      }
    }
    return true;
  },
  alphaNumbericInputFilter: function(evt, el) {
    var validation = el.getAttribute("validation");
    if (validation == "Number") {
      var testStr = el.value.replace(/[^0-9\.\-\,\%]+/g, "");
      if (testStr !== el.value && el.getAttribute("autoclear") != el.value) {
        el.value = testStr;
      }
    } else if (validation == "AlphaNumeric") {
      el.value = el.value.replace(/[^0-9a-zA-Z\.\-\,]+/g, "");
    } else if (validation == "CharacterSet") {
      var regex = el.getAttribute("charSet");
      if (regex) {
        regex = regex.replace("[", "[^") + "+";
        el.value = el.value.replace(new RegExp(regex, "g"), "");
      }
    }
  },
  /**
  * Qualtrics.getInputValue
  * @param {domNode} input
  */
  getInputValue: function(input) {
    var val = input.value, autoclear = input.getAttribute("autoclear");
    if (autoclear && val == autoclear)
      val = "";
    return val;
  },
  /**
  * Qualtrics.Cache
  **/
  Cache: {
    cache: {},
    set: function(key, val) {
      this.cache[key] = val;
    },
    get: function(key) {
      if (this.cache[key] !== null && typeof this.cache[key] != "undefined")
        return this.cache[key];
      else
        return null;
    },
    unset: function(key) {
      delete this.cache[key];
    }
  },
  /**
  * returns messages out of the Messages.xml file.
  * takes a variable amount of params
  * you can just give 1 param and it will look in the 'Javascript' section
  * if you give 2 params then the 1st param is the section and the 2nd is the tag
  * more than 2 params will define replacement parameters %1 %2 and so on
  */
  getMessage: function(var_args) {
    var sectionName = "Javascript", params = null, tag = arguments[1] || arguments[0];
    if (arguments[1]) {
      sectionName = arguments[0];
      params = Array.prototype.slice.call(arguments, 2);
    }
    var messages = window.javascriptMessages;
    if (window.javascriptMessages) {
      if (tag && messages && window.javascriptMessages[sectionName]) {
        var message = window.javascriptMessages[sectionName][tag];
        if (message) {
          if (Qualtrics && Qualtrics.System && Qualtrics.System.productName == "ThreeSixty" && Qualtrics.ThreeSixty && Qualtrics.ThreeSixty.section != "AssessmentPortal") {
            var ignoredTags = ["Survey", "Survey1", "Survey2", "Survey3", "Form", "Form1", "Form2", "Form3", "Assessment", "Assessment1", "Assessment2", "Assessment3", "Project", "Project1", "Project2", "Project3"];
            if (ignoredTags.indexOf(tag) === -1) {
              if (Qualtrics.ThreeSixty.currentType == "EE") {
                message = message.replace(new RegExp("\\b" + getMessage("SiteWide", "Form") + "\\b"), getMessage("SiteWide", "Survey"));
                message = message.replace(new RegExp("\\b" + getMessage("SiteWide", "Form1") + "\\b"), getMessage("SiteWide", "Survey1"));
                message = message.replace(new RegExp("\\b" + getMessage("SiteWide", "Form2") + "\\b"), getMessage("SiteWide", "Survey2"));
                message = message.replace(new RegExp("\\b" + getMessage("SiteWide", "Form3") + "\\b"), getMessage("SiteWide", "Survey3"));
                message = message.replace(getMessage("SiteWide", "Assessment"), getMessage("SiteWide", "Project"));
                message = message.replace(getMessage("SiteWide", "Assessment1"), getMessage("SiteWide", "Project1"));
                message = message.replace(getMessage("SiteWide", "Assessment2"), getMessage("SiteWide", "Project2"));
                message = message.replace(getMessage("SiteWide", "Assessment3"), getMessage("SiteWide", "Project3"));
              } else {
                message = message.replace(getMessage("SiteWide", "Survey"), getMessage("SiteWide", "Form"));
                message = message.replace(getMessage("SiteWide", "Survey1"), getMessage("SiteWide", "Form1"));
                message = message.replace(getMessage("SiteWide", "Survey2"), getMessage("SiteWide", "Form2"));
                message = message.replace(getMessage("SiteWide", "Survey3"), getMessage("SiteWide", "Form3"));
              }
            }
          }
          if (params && params.length) {
            for (i = 0, len = params.length; i < len; ++i) {
              var re = new RegExp("%" + (i + 1), "g");
              message = message.replace(re, params[i]);
            }
          }
          return message;
        }
      }
    }
    return "#" + tag;
  },
  /**
  * parses JSON with some safe guards so you dont fatal error if you get bad json
  */
  parseJSON: function(json, opt_silent) {
    try {
      if (json) {
        if (typeof json == "string") {
          var parsed = json.evalJSON();
          return parsed;
        } else if (typeof json == "object") {
          return json;
        }
      }
    } catch (e) {
      if (!opt_silent)
        console.error(e);
    }
    return false;
  },
  /**
   * Wraps Object.toJSON in a try-catch, in case of circular references
   * @return {string} json, or false on failure.
   */
  toJSON: function(object, opt_silent) {
    var json;
    try {
      json = Object.toJSON(object);
    } catch (e) {
      if (!opt_silent)
        console.error(e);
      json = false;
    }
    return json;
  },
  getHashCode: function(str) {
    var hash1 = (5381 << 16) + 5381;
    var hash2 = hash1;
    var hashPos = 0;
    while (hashPos < str.length) {
      hash1 = (hash1 << 5) + hash1 + (hash1 >> 27) ^ str.charCodeAt(hashPos);
      if (hashPos == str.length - 1) {
        break;
      }
      hash2 = (hash2 << 5) + hash2 + (hash2 >> 27) ^ str.charCodeAt(hashPos + 1);
      hashPos += 2;
    }
    return hash1 + hash2 * 1566083941;
  },
  /**
  * Qualtrics.arrayCast
  * forces an object to be an array and will leave an array alone
  * @param {Array|Object|null} - an array or object or that you want to come out as an array
  *							  null will come out as an empty array
  **/
  arrayCast: function(object) {
    if (!object) {
      return [];
    }
    if (object.length !== void 0 && object.push) {
      return object;
    }
    var array = [];
    for (var key in object) {
      array.push(object[key]);
    }
    return array;
  }
});
Qualtrics.Browser.Version = Qualtrics.Browser.getVersion();
Qualtrics.Browser.Features = Qualtrics.Browser.getFeatures();
var OverRegistry = [];
var dragInProgress = false;
var suspendOvers = false;
function clearOverRegistry() {
  if (suspendOvers)
    return;
  for (i = 0; i < OverRegistry.length; i++) {
    var elem = OverRegistry[i];
    var cn = Element.classNames(elem);
    cn.remove("Over");
  }
  OverRegistry.clear();
}
function AddOver(el, options2) {
  if (!el)
    return;
  if (window.dragInProgress != void 0) {
    if (window.dragInProgress)
      return;
    if (window.suspendOvers)
      return;
  }
  var className = options2 && options2.className || "Over";
  $(el).addClassName(className);
  OverRegistry.push(el);
  if (options2 && options2.onComplete) {
    options2.onComplete(el, options2);
  }
}
function RemoveOver(el, options2) {
  if (window.dragInProgress != void 0) {
    if (window.dragInProgress)
      return;
    if (window.suspendOvers)
      return;
  }
  var className = options2 && options2.className || "Over";
  $(el).removeClassName(className);
  clearOverRegistry();
  if (options2 && options2.onComplete) {
    options2.onComplete(el, options2);
  }
}
function getOverClosure(type, opt_options) {
  return function(evt) {
    evt = evt || window.event;
    if (evt) {
      var el = opt_options && opt_options.element || Event.element(evt);
      if (window[type]) {
        window[type](el, opt_options);
      }
    }
  };
}
function AddOverHelper(el) {
  if (!el.overAdded) {
    el.overAdded = true;
    Event.observe(el, "mouseover", function() {
      AddOver(el);
    });
    Event.observe(el, "mouseout", function() {
      RemoveOver(el);
    });
  }
}
var translationTip = {
  originalText: "",
  suggestionText: "",
  section: "",
  item: "",
  userLang: "",
  userID: "",
  span: "",
  event: "",
  keepTip: false,
  off: function() {
    if ($("translationTip")) {
      setTimeout(translationTip.removeTip, 750);
    }
  },
  on: function(el, ev, section, item, lang, userID) {
    if ($("translationTip"))
      return;
    this.span = el;
    this.event = ev;
    this.section = section;
    this.item = item;
    this.userLang = lang;
    this.userID = userID;
    setTimeout(translationTip.addTip, 750);
  },
  keepAlive: function(value) {
    this.keepTip = value;
    if (value == false)
      this.off();
  },
  removeTip: function(override) {
    if (!this.keepTip && $("translationTip") && !$("suggestionText").value || override) {
      $("translationTip").remove();
    }
  },
  addTip: function() {
    var el = this.span;
    var coordinates = Element.positionedOffset(el);
    var event = this.event;
    if (!event)
      event = window.event;
    var mouseCoordinates = getMousePosition(event);
    this.originalText = el.innerHTML;
    var x = mouseCoordinates[0];
    var y = mouseCoordinates[1];
    var stripped = this.originalText.replace(/(<([^>]+)>)/ig, "");
    var translationTip2 = QBuilder("div", { id: "translationTip", onmouseover: "translationTip.keepAlive(true)", onmouseout: "translationTip.keepAlive(false)", style: "left:" + x + "px; top:" + y + "px;" }, [
      QBuilder("div", { className: "header" }, [
        QBuilder("h3", {}, [getMessage("SiteWide", "SuggestTranslation")])
      ]),
      QBuilder("div", { className: "content" }, [
        QBuilder("div", { id: "translationTipContent" }, [
          QBuilder("div", {}, [getMessage("SiteWide", "CurrentText")]),
          QBuilder("div", {}, [this.originalText])
        ]),
        QBuilder("div", {}, [
          getMessage("SiteWide", "BetterSuggestion")
        ]),
        QBuilder("input", { type: "text", id: "suggestionText" }, [])
      ]),
      QBuilder("div", { className: "footer" }, [
        QBuilder("div", { className: "translationTipButton", id: "submitTranslation", onclick: "translationTip.submitSuggestion()" }, [getMessage("SiteWide", "Submit")]),
        QBuilder("div", { className: "translationTipButton", onclick: "translationTip.removeTip(true)" }, [getMessage("SiteWide", "Close")]),
        QBuilder("div", { className: "clear" }, [])
      ])
    ]);
    $("body").appendChild(translationTip2);
  },
  submitSuggestion: function() {
    if ($("submitTranslation") && $("submitTranslation").hasClassName("disabled"))
      return;
    $("submitTranslation").addClassName("disabled");
    if ($("suggestionText") && $("suggestionText").value)
      this.suggestionText = $("suggestionText").value;
    else {
      $("translationTipContent").innerHTML = getMessage("SiteWide", "NoSuggestion");
      this.off();
      return;
    }
    var url = "http://reporting.qualtrics.com/projects/translations.php?userID=" + this.userID + "&suggestion=" + this.suggestionText + "&sectionTag=" + this.section + "&messageTag=" + this.item + "&language=" + this.userLang;
    new Ajax.Request(url, {
      params: {
        userID: this.userID,
        translation: this.suggestionText,
        sectionTag: this.section,
        messageTag: this.item,
        language: this.userLang
      },
      onSuccess: function() {
        $("translationTipContent").innerHTML = getMessage("SiteWide", "TranslationReceived");
        this.off();
      },
      onFailure: function() {
        $("translationTipContent").innerHTML = getMessage("SiteWide", "TranslationNotReceived");
        this.off();
      }
    });
  }
};
Cookie = {
  createCookie: function(name, value, days) {
    if (days) {
      var date = /* @__PURE__ */ new Date();
      date.setTime(date.getTime() + days * 24 * 60 * 60 * 1e3);
      var expires = "; expires=" + date.toGMTString();
    } else
      expires = "";
    document.cookie = name + "=" + value + expires + "; path=/";
  },
  readCookie: function(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(";");
    for (var i2 = 0; i2 < ca.length; i2++) {
      var c = ca[i2];
      while (c.charAt(0) == " ")
        c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) == 0)
        return c.substring(nameEQ.length, c.length);
    }
    return null;
  },
  readCookieNames: function() {
    var cookies = [];
    var ca = document.cookie.split(";");
    ca.each(function(item) {
      var index = item.indexOf("=");
      cookies.push(item.substring(0, index));
    });
    return cookies;
  },
  eraseCookie: function(name) {
    Cookie.createCookie(name, "", -1);
  },
  acceptsCookies: function() {
    if (typeof navigator.cookieEnabled == "boolean") {
      return navigator.cookieEnabled;
    }
    Cookie.createCookie("_test", "1");
    var val = Cookie.readCookie("_test");
    Cookie.eraseCookie("_test");
    return val == "1";
  }
};
function stopEnterSubmit(evt) {
  if (evt.keyCode == Event.KEY_RETURN) {
    Event.stop(evt);
    return false;
  }
}
function pressSubmitButtonOnEnter(evt, id) {
  if (evt.keyCode == Event.KEY_RETURN) {
    Event.stop(evt);
    $(id).click();
    return false;
  }
}
function number_format(number, decimals, dec_point, thousands_sep, pad_right) {
  if (!decimals || decimals > 0) {
    var decimalPos = String(number).indexOf(".");
    if (decimalPos === -1 && !pad_right) {
      decimals = 0;
    } else {
      var numOfCharactersAfterDecimal = String(number).substring(decimalPos + 1).length;
      if (decimals) {
        decimals = pad_right ? decimals : Math.min(numOfCharactersAfterDecimal, decimals);
      } else {
        decimals = numOfCharactersAfterDecimal;
      }
    }
  }
  var n = number;
  var c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
  var d = dec_point == void 0 ? "." : dec_point;
  var t = thousands_sep == void 0 ? "," : thousands_sep;
  var s = n < 0 ? "-" : "";
  var i2 = parseInt(n = Math.abs(+n || 0).toFixed(c)) + "";
  var j = (j = i2.length) > 3 ? j % 3 : 0;
  var finalNum = s + (j ? i2.substr(0, j) + t : "") + i2.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i2).toFixed(c).slice(2) : "");
  return finalNum;
}
function trim(str) {
  return str.replace(/^\s+|\s+$/g, "");
}
function UpdateCSTotal(CSQuestion, DesiredSum) {
  var displayOrderEl = $("QR~" + CSQuestion + "~DisplayOrder");
  var displayedChoices = displayOrderEl ? displayOrderEl.value.split("|") : [];
  var TotalCount = 0;
  for (var i2 = 0; i2 < displayedChoices.length; i2++) {
    var CurrentChoice = "QR~" + CSQuestion + "~" + displayedChoices[i2];
    var choiceEl = $(CurrentChoice);
    if (choiceEl) {
      var num = Number(choiceEl.value.replace(/,/g, ""));
      if (!isNaN(num)) {
        TotalCount += num;
      }
    }
  }
  if (TotalCount == DesiredSum || DesiredSum == -1)
    $(CSQuestion + "_Total").style.color = "";
  else
    $(CSQuestion + "_Total").style.color = "red";
  TotalCount = number_format(TotalCount);
  $(CSQuestion + "_Total").value = TotalCount;
}
function UpdateMatrixCSTotal(Question, choiceId, desiredSum) {
  if (!desiredSum)
    desiredSum = -1;
  var questionId = Question;
  if (questionId.indexOf("~") != -1) {
    choiceId = questionId.substring(questionId.indexOf("~") + 1);
    questionId = questionId.substring(0, questionId.indexOf("~"));
  }
  var displayOrderEl = $("QR~" + questionId + "~AnswerDisplayOrder");
  var displayedAnswers = displayOrderEl ? displayOrderEl.value.split("|") : [];
  var TotalCount = 0;
  for (var i2 = 0; i2 < displayedAnswers.length; i2++) {
    var CurrentAnswer = "QR~" + questionId + "~" + choiceId + "~" + displayedAnswers[i2];
    var answerEl = $(CurrentAnswer);
    if (answerEl) {
      TotalCount += Number(answerEl.value.replace(/,/g, ""));
    }
  }
  var OutputCell = questionId + "~" + choiceId + "_Total";
  if (TotalCount == desiredSum || desiredSum == -1)
    $(OutputCell).style.color = "";
  else
    $(OutputCell).style.color = "red";
  TotalCount = number_format(TotalCount);
  $(OutputCell).value = TotalCount;
}
function UpdateMatrixCSTotalVert(Question, answerId, desiredSum) {
  if (!desiredSum)
    desiredSum = -1;
  var questionId = Question;
  if (questionId.indexOf("~") != -1) {
    answerId = questionId.substring(questionId.indexOf("~") + 1);
    questionId = questionId.substring(0, questionId.indexOf("~"));
  }
  var displayOrderEl = $("QR~" + questionId + "~DisplayOrder");
  var displayedChoices = displayOrderEl ? displayOrderEl.value.split("|") : [];
  var TotalCount = 0;
  for (var i2 = 0; i2 < displayedChoices.length; i2++) {
    var CurrentAnswer = "QR~" + questionId + "~" + displayedChoices[i2] + "~" + answerId;
    var answerEl = $(CurrentAnswer);
    if (answerEl) {
      TotalCount += Number(answerEl.value.replace(/,/g, ""));
    }
  }
  var OutputCell = questionId + "~" + answerId + "_Total";
  if (TotalCount == desiredSum || desiredSum == -1)
    $(OutputCell).style.color = "";
  else
    $(OutputCell).style.color = "red";
  TotalCount = number_format(TotalCount);
  $(OutputCell).value = TotalCount;
}
function updateConjointTotal(prefix, total_levels) {
  var conjoint_level = 1;
  var total_count = 0;
  var features = $("featuresShown").value.split(",");
  for (var i2 = 0; i2 < features.length; i2++) {
    conjoint_level = features[i2];
    level_element = prefix + "~" + conjoint_level + "~UCS";
    if ($(level_element))
      total_count += Number($(level_element).value);
    conjoint_level++;
  }
  var output_element = prefix + "~Total";
  if (total_count == 100)
    document.Page.elements[output_element].style.color = "";
  else
    document.Page.elements[output_element].style.color = "red";
  document.Page.elements[output_element].value = total_count;
}
function SBChangeOrder(selectionID, offset) {
  offset = Number(offset);
  var element = $(selectionID);
  if (offset != -1 && offset != 1 || element == null)
    return;
  var index = element.selectedIndex;
  if (index == -1 || index + offset < 0 || index + offset >= element.options.length)
    return;
  var optionA = new Option(element.options[index].text, element.options[index].value, 0, 1);
  optionA.nomove = element.options[index].nomove;
  var optionB = new Option(element.options[index + offset].text, element.options[index + offset].value);
  optionB.nomove = element.options[index + offset].nomove;
  element.options[index] = optionB;
  element.options[index + offset] = optionA;
  element.focus();
}
function moveItemToSelectionBox(oldSelectionBoxID, newSelectionBoxID, deleteOption) {
  var old_element = $(oldSelectionBoxID);
  var new_element = $(newSelectionBoxID);
  if (old_element == null || new_element == null) {
    return;
  }
  var old_element_length = old_element.options.length;
  for (var index = 0; index < old_element_length; index++) {
    if (old_element.options[index].selected) {
      var option = old_element.options[index];
      option = new Option(option.text, option.value);
      option.referer = oldSelectionBoxID;
      if (deleteOption) {
        old_element.options[index--] = null;
        old_element_length = old_element.options.length;
      }
      new_element.options.add(option);
    }
  }
  old_element.focus();
}
function deleteItemFromSelectionBox(selectionBoxID) {
  var element = $(selectionBoxID);
  if (element == null) {
    return;
  }
  var index = element.selectedIndex;
  if (index == -1)
    return;
  var newSelected = index - 1;
  var element_length = element.options.length;
  for (index = 0; index < element_length; index++) {
    if (element.options[index].selected) {
      element.options[index--] = null;
      element_length = element.options.length;
      if (index < 0)
        index = 0;
    }
  }
  if (newSelected >= 0)
    element.options[newSelected].selected = true;
  else
    element.options[0].selected = true;
  element.focus();
}
function updateDrillDown(selectPrefix, answerMap, answers, depth, maxDepth, value) {
  var hasAnswerMap = false;
  for (var test in answerMap) {
    hasAnswerMap = true;
    break;
  }
  if (!hasAnswerMap || depth > maxDepth) {
    return;
  }
  var questionId = selectPrefix.split("~")[0];
  var choices = $$("[posttag=" + questionId + "] .drillDownSelectDropDown");
  choices.unshift(null);
  var selectedAnswer = parseValue(value);
  var currentSelect = choices[depth];
  var nextSelect = choices[depth + 1];
  if (currentSelect && selectedAnswer) {
    var selectValue = "QR~" + choices[depth].id + "~" + selectedAnswer;
    currentSelect.value = selectValue;
    var options2 = currentSelect.select("option");
    options2.each(function(option) {
      if (option.value == selectValue) {
        option.setAttribute("selected", "selected");
      }
    });
  }
  if (nextSelect) {
    nextSelect.disabled = true;
    nextSelect.options.length = 0;
    if (selectedAnswer || depth == 0) {
      var valuePrefix = nextSelect.name + "~";
      var newAnswers = createDDAnswers(answerMap, answers, selectedAnswer, depth);
      var i2 = 0;
      nextSelect.options[i2++] = new Option("", "");
      for (var answerID in newAnswers) {
        nextSelect.options[i2++] = new Option(newAnswers[answerID], valuePrefix + answerID);
      }
      if (!Element.hasClassName(nextSelect, "disabled")) {
        nextSelect.disabled = false;
      }
    }
    for (i2 = depth + 2; i2 <= maxDepth; i2++) {
      if (choices[i2] != null) {
        var select = choices[i2];
        select.options.length = 0;
        select.disabled = true;
      }
    }
  }
}
function parseValue(value) {
  if (value == false || value.indexOf("~") == -1)
    return value;
  var startIndex = value.lastIndexOf("~") + 1;
  var endIndex = value.length;
  return value.substring(startIndex, endIndex);
}
function createDDAnswers(answerMap, DDanswers, selectedAnswer, depth) {
  var answerArray = getAnswerArray(answerMap, selectedAnswer, depth);
  var answers = new Object();
  for (var answerID in answerArray) {
    answers[answerID] = DDanswers[answerID].substring(DDanswers[answerID].lastIndexOf("~ ") + 1);
  }
  return answers;
}
function getAnswerArray(answerMap, selectedAnswer, depth) {
  if (answerMap == "")
    return false;
  if (depth == 0)
    return answerMap;
  for (var answerID in answerMap) {
    if (answerID == selectedAnswer)
      return answerMap[answerID];
    var answerArray = getAnswerArray(answerMap[answerID], selectedAnswer);
    if (answerArray != false)
      return answerArray;
  }
  return false;
}
function validateNumber(event) {
  var keyCode = event.keyCode;
  if (keyCode == 8 || keyCode == 9 || keyCode == 35 || keyCode == 36 || keyCode == 37 || keyCode == 39 || keyCode == 46)
    return true;
  if (keyCode == 0)
    keyCode = event.which;
  if (keyCode == 46)
    return true;
  if (keyCode == 45)
    return true;
  if (keyCode >= 48 && keyCode <= 57 || keyCode <= 97 && keyCode >= 122)
    return true;
  return false;
}
function noneOfTheAboveCheck(postTag, choiceId, notAChoice, thisID) {
  if (choiceId == "")
    var items = document.Page.elements[postTag + "~DisplayOrder"].value.split("|");
  else {
    items = document.Page.elements[postTag + "~AnswerDisplayOrder"].value.split("|");
    postTag = postTag + "~" + choiceId;
  }
  if (thisID == notAChoice) {
    var thisCheckBox = $(postTag + "~" + thisID);
    if (thisCheckBox.checked) {
      for (var i2 = 0; i2 < items.length; i2++) {
        var checkBox = $(postTag + "~" + items[i2]);
        if (thisID == items[i2] || !checkBox)
          continue;
        checkBox.checked = false;
      }
    }
  } else {
    var notAChoiceCheckBox = $(postTag + "~" + notAChoice);
    notAChoiceCheckBox.checked = false;
  }
}
function exclusiveAnswerCheck(postTag, group, elementId) {
  try {
    if ($(postTag + "~AnswerDisplayOrder"))
      var displayedChoices = $F(postTag + "~AnswerDisplayOrder").split("|");
    else if ($(postTag + "~DisplayOrder"))
      displayedChoices = $F(postTag + "~DisplayOrder").split("|");
    else
      return;
  } catch (e) {
    console.log(e);
  }
  var isExclusive = $(group + "~" + elementId).getAttribute("exclusive");
  for (var i2 = 0; i2 < displayedChoices.length; i2++) {
    var checkBox = $(group + "~" + displayedChoices[i2]);
    var id = displayedChoices[i2];
    if (isExclusive == 1) {
      if (elementId == id || !checkBox)
        continue;
      checkBox.checked = false;
    } else {
      if (checkBox && checkBox.getAttribute("exclusive") == 1)
        checkBox.checked = false;
    }
  }
}
function exclusiveChoiceCheck(postTag, group, choiceId, elementId) {
  try {
    if ($(postTag + "~DisplayOrder"))
      var displayedChoices = $F(postTag + "~DisplayOrder").split("|");
    else
      return;
  } catch (e) {
    console.log(e);
  }
  var isExclusive = $(group + "~" + elementId).getAttribute("choiceexclusive");
  for (var i2 = 0; i2 < displayedChoices.length; i2++) {
    var checkBox = $(postTag + "~" + displayedChoices[i2] + "~" + elementId);
    var id = displayedChoices[i2];
    if (isExclusive == 1) {
      if (choiceId == id || !checkBox) {
        continue;
      }
      checkBox.checked = false;
    } else {
      if (checkBox && checkBox.getAttribute("choiceexclusive") == 1)
        checkBox.checked = false;
    }
  }
}
function rankOrderRadioCheck(colId, selectedRow, numRows) {
  for (var row = 0; row < numRows; row++) {
    if (row == selectedRow)
      continue;
    var radio = $(colId + "~" + row);
    if (radio.checked == true)
      radio.checked = false;
  }
}
function getTimeArray(d) {
  d = Number(d);
  return {
    h: Math.floor(d / 3600),
    m: Math.floor(d % 3600 / 60),
    s: Math.floor(d % 3600 % 60)
  };
}
function startTimer(tId) {
  $(tId + "Timer").timer = setInterval(function() {
    var t = $(tId + "Timer");
    var i2 = parseInt(t.getAttribute("time"));
    var e = i2 - parseInt(t.getAttribute("endTime"));
    if (e == 0) {
      clearInterval(t.timer);
      return;
    }
    var j = i2 - e / Math.abs(e);
    t.setAttribute("time", j);
    $("TimerClock" + tId + "Time").setValue(j);
    i2 = getTimeArray(i2);
    j = getTimeArray(j);
    flipNumber(i2.s, j.s, tId + "S");
    if (i2.m != j.m)
      flipNumber(i2.m, j.m, tId + "M");
    if (i2.h != j.h)
      flipNumber(i2.h, j.h, tId + "H");
  }.bind(null, tId), 1e3);
}
function flipNumber(i2, j, hms) {
  var flip = function(i3, j2, n) {
    $("TimerClock" + n).setValue(j2);
    if (!(Qualtrics.Browser.WebKit || Qualtrics.Browser.Firefox)) {
      $(n).down(".Number").update(j2);
      return;
    }
    var field = QBuilder("fieldset", {}, [
      QBuilder("span", { className: "Change B" }, j2 + ""),
      QBuilder("span", { className: "Change TF" }, i3 + ""),
      QBuilder("span", { className: "Change TB" }, j2 + "")
    ]);
    $(n).appendChild(field);
    (function(n2) {
      n2.className += " Flip";
    }).delay(0.05, field);
    setTimeout(
      function(n2, j3) {
        $(n2).down(".Number").update(j3);
        $(n2).down(".Flip").hide();
      }.curry(n, j2),
      800
    );
  };
  if (i2 % 10 != j % 10) {
    flip(i2 % 10, j % 10, hms + "2");
  }
  i2 = Math.max(Math.floor(i2 / 10), 0);
  j = Math.max(Math.floor(j / 10), 0);
  if (i2 != j) {
    flip(i2, j, hms + "1");
  }
}
function InsertSlider(SliderName, Direction, min, max, DefaultValue, GraphicDirectory, SliderValue) {
  var html = generateSliderDOM(SliderName, Direction, min, max, DefaultValue, GraphicDirectory, SliderValue);
  var SliderParentId = "SSParent~" + SliderName;
  $(SliderParentId).appendChild(html);
  createSlider.defer(SliderName, Direction, min, max, DefaultValue, GraphicDirectory, SliderValue);
}
function generateSliderDOM(SliderName, Direction, min, max, DefaultValue, GraphicDirectory, SliderValue) {
  if (SliderValue !== void 0 && SliderValue !== null && SliderValue !== "" && SliderValue >= min && SliderValue <= max)
    DefaultValue = SliderValue;
  var SliderNM = SliderName;
  var SliderImage = SliderName + "_Image";
  var sliderPath = "/WRQualtricsShared/SlidingScales/" + GraphicDirectory + "/";
  var ssImages = QBuilder("div", { className: "SSImage" });
  for (var i2 = min; i2 <= max; i2++) {
    var display = i2 == DefaultValue ? "block" : "none";
    var img = QBuilder("img", { src: sliderPath + i2 + ".gif", id: "Image_" + SliderName + "@" + i2 });
    $(img).setStyle({ display: display });
    $(ssImages).appendChild(img);
  }
  var track = QBuilder("a", { className: "SSTrack", id: "DV_" + SliderName }, [
    QBuilder("span", { className: "handle", id: "H_" + SliderName })
  ]);
  var ret = QBuilder("div");
  if (Direction == "vertical") {
    ret.appendChild(
      QBuilder("table", { className: "SSDisplay " + Direction + "bar" }, [
        QBuilder("tbody", {}, [
          QBuilder("tr", {}, [
            QBuilder("td", {}, [ssImages]),
            QBuilder("td", {}, [track])
          ])
        ])
      ])
    );
  } else {
    ret.appendChild(
      QBuilder("table", { className: "SSDisplay " + Direction + "bar" }, [
        QBuilder("tbody", {}, [
          QBuilder("tr", {}, [
            QBuilder("td", {}, [ssImages])
          ]),
          QBuilder("tr", {}, [
            QBuilder("td", {}, [track])
          ])
        ])
      ])
    );
  }
  var opts = { "type": "hidden", id: SliderName, "name": SliderName };
  if (SliderValue !== void 0 && SliderValue !== null && SliderValue !== "" && SliderValue >= min && SliderValue <= max)
    opts["value"] = SliderValue;
  ret.appendChild(Builder.node("input", opts));
  return ret;
}
function createSlider(SliderName, Direction, min, max, DefaultValue, GraphicDirectory, SliderValue) {
  var slider = "DV_" + SliderName;
  var handle = "H_" + SliderName;
  var range = $R(parseInt(min), parseInt(max));
  var activated = false;
  if (SliderValue !== void 0 && SliderValue !== null && SliderValue !== "" && SliderValue >= min && SliderValue <= max) {
    DefaultValue = SliderValue;
    activated = true;
    $(slider).addClassName("activated");
  }
  var defValue = DefaultValue;
  if (Direction == "vertical") {
    DefaultValue = range.end - DefaultValue + parseInt(min);
  }
  var mySlider = new Control.Slider(handle, slider, {
    range: range,
    values: $A(range),
    axis: Direction,
    sliderValue: DefaultValue,
    onSlide: function(value) {
      if (!this.value && this.value != 0) {
        this.value = defValue;
      }
      if (this.axis == "vertical")
        value = this.range.end - value + this.range.start;
      if ($("Image_" + SliderName + "@" + this.value))
        $("Image_" + SliderName + "@" + this.value).setStyle({ display: "none" });
      if ($("Image_" + SliderName + "@" + value))
        $("Image_" + SliderName + "@" + value).setStyle({ display: "block" });
      this.value = value;
    },
    onChange: function(value) {
      if (!activated) {
        activated = true;
        $(slider).addClassName("activated");
      }
      if (this.axis == "vertical")
        value = this.range.end - value + this.range.start;
      $(SliderName).value = value;
    }
  });
}
function submitForm(formID) {
  var form = $(formID);
  if (form) {
    Event.fire(form, "submit");
    if (form.onsubmit)
      form.onsubmit();
    if (form.submit)
      form.submit();
    return true;
  }
}
function submitFormJumpTo(formID, jumpTo) {
  $(formID).action = jumpTo;
  submitForm(formID);
}
function getMousePosition(e) {
  if (e.pageX && e.pageY) {
    posx = e.pageX;
    posy = e.pageY;
  } else if (e.clientX && e.clientY) {
    posx = e.clientX + window.scrollInfo[0];
    posy = e.clientY + window.scrollInfo[1];
  }
  return [posx, posy];
}
function setPosition(obj, newX, newY) {
  $(obj).setStyle({ top: newY + "px", left: newX + "px" });
}
function findPosX(obj) {
  var curleft = 0;
  if (obj.offsetParent) {
    while (obj.offsetParent) {
      curleft += obj.offsetLeft;
      obj = obj.offsetParent;
    }
  } else if (obj.x)
    curleft += obj.x;
  return curleft;
}
function findPosY(obj, opt_UseScrollOffset) {
  var curtop = 0;
  if (obj.offsetParent) {
    while (obj.offsetParent) {
      curtop += obj.offsetTop;
      if (opt_UseScrollOffset) {
        curtop -= obj.scrollTop;
      }
      obj = obj.offsetParent;
    }
  } else if (obj.y)
    curtop += obj.y;
  return curtop;
}
function autoCheck(id, text) {
  var el = $(id);
  if (el == null)
    return;
  if (el && el.id != id)
    return;
  var type = el.getAttribute("type");
  if (type == "checkbox" || type == "radio") {
    if (text == "" || text == null)
      el.checked = false;
    else
      el.checked = true;
  }
  if ($(el).onclick)
    $(el).onclick();
  if (Qualtrics.syncLabelsAndInputs) {
    Qualtrics.syncLabelsAndInputs(false);
  }
}
var SEonSubmit = {
  add: function(onSubmitFunction) {
    Event.observe("Page", "submit", onSubmitFunction);
  }
};
var SEonClick = {
  add: function(onClickFunction) {
    Event.observe("Page", "click", onClickFunction);
  }
};
var SEonMouseDown = {
  add: function(onMouseDownFunction) {
    Event.observe("Page", "mouseup", onMouseDownFunction);
    Event.observe("Page", "touchend", onMouseDownFunction);
  }
};
var IeFixFlashFixOnload = function() {
};
function refreshPage() {
}
function SlideToggle(el, options2) {
  if (el.inAction != true) {
    el.inAction = true;
    if (options2 && options2.onStart) {
      options2.onStart();
    }
    if (Element.getStyle(el, "display") == "block") {
      if (options2 && options2.ExpandOnly == true) {
        el.inAction = false;
        if (options2 && options2.onExit) {
          options2.onExit();
        }
        return;
      }
      if (options2 && options2.toggleArrow) {
        ArrowToggle(options2.toggleArrow, { ContractOnly: true });
      }
      new Effect.BlindUp(
        el,
        {
          duration: options2.duration || 0.15,
          afterFinish: function() {
            el.inAction = false;
            if (refreshPage) {
              refreshPage();
            }
            if (options2 && options2.onContract) {
              options2.onContract();
            }
            if (options2 && options2.onFinish) {
              options2.onFinish();
            }
            if (options2 && options2.onExit) {
              options2.onExit();
            }
          }
        }
      );
    } else {
      if (options2 && options2.ContractOnly == true) {
        el.inAction = false;
        if (options2 && options2.onExit) {
          options2.onExit();
        }
        return;
      }
      if (options2 && options2.toggleArrow) {
        ArrowToggle(options2.toggleArrow, { ExpandOnly: true });
      }
      if (options2 && options2.beforeExpand) {
        options2.beforeExpand();
      }
      new Effect.BlindDown(
        el,
        {
          duration: options2.duration || 0.15,
          afterFinish: function() {
            el.inAction = false;
            if (refreshPage) {
              refreshPage();
            }
            if (options2 && options2.onExpand) {
              options2.onExpand();
            }
            if (options2 && options2.onFinish) {
              options2.onFinish();
            }
            if (options2 && options2.onExit) {
              options2.onExit();
            }
          }
        }
      );
    }
  }
}
function ArrowToggle(TitleDiv, options2) {
  if (options2 && options2.ContractOnly) {
    $(TitleDiv).addClassName("Collapsed");
    return;
  }
  if (options2 && options2.ExpandOnly) {
    $(TitleDiv).removeClassName("Collapsed");
    return;
  }
  if (Element.hasClassName(TitleDiv, "Collapsed")) {
    $(TitleDiv).removeClassName("Collapsed");
  } else {
    $(TitleDiv).addClassName("Collapsed");
  }
}
function HelpToggle() {
  SlideToggle(
    $("HelpContent"),
    {
      onContract: function() {
        Element.setStyle($("HelpButton"), { borderBottom: "1px solid #FCD570" });
        $("GapCloser").hide();
      },
      beforeExpand: function() {
        Element.setStyle($("HelpButton"), { borderBottom: "none" });
        $("GapCloser").show();
      }
    }
  );
}
function fillVerticalSpace(element, container) {
  try {
    if (element) {
      if (!container || container.tagName == "body")
        fillBody = true;
      else
        fillBody = false;
      var newHeight = 0;
      var headerAndFooterHeight = 0;
      var mainContentDiv = $("mainContentDiv");
      if (mainContentDiv) {
        if (fillBody) {
          headerAndFooterHeight += Position.cumulativeOffset(mainContentDiv)[1];
        } else if ($("popupMainHeaderDiv")) {
          headerAndFooterHeight += Position.cumulativeOffset(mainContentDiv)[1] - Position.cumulativeOffset($("popupMainHeaderDiv"))[1];
        }
      }
      var topOfFooterDiv = $("topOfFooter");
      var botOfFooterDiv = $("bottomOfFooter");
      var footerDiv = $("popupMainFooterDiv");
      if (topOfFooterDiv && botOfFooterDiv) {
        var footerHeight = Position.cumulativeOffset(botOfFooterDiv)[1] - Position.cumulativeOffset(topOfFooterDiv)[1];
        headerAndFooterHeight += footerHeight;
      } else if (footerDiv) {
        footerHeight = footerDiv.offsetHeight;
        headerAndFooterHeight += footerHeight;
      }
      if (fillBody) {
        if (window.innerHeight) {
          newHeight = window.innerHeight - headerAndFooterHeight;
        } else {
          newHeight = document.documentElement.clientHeight - headerAndFooterHeight;
        }
      } else {
        newHeight = $(container).offsetHeight - headerAndFooterHeight;
      }
      element.style.height = newHeight + "px";
    }
  } catch (e) {
    console.error(e);
  }
}
function resizedWindow() {
  fillVerticalSpace($("mainContentDiv"));
}
function removeElement(element) {
  if (!element)
    return;
  var garbageBin = $("IELeakGarbageBin");
  if (!garbageBin) {
    garbageBin = QBuilder("DIV");
    garbageBin.id = "IELeakGarbageBin";
    garbageBin.style.display = "none";
    document.body.appendChild(garbageBin);
  }
  garbageBin.appendChild(element);
  garbageBin.innerHTML = "";
}
function getMessage(msg) {
  return "#" + msg;
}
var QualtricsTools = {
  /**
  * QualtricsTools.createNewId
  */
  createNewId: function(prefix) {
    var number;
    try {
      if (typeof Uint32Array !== "undefined" && window.crypto && window.crypto.getRandomValues) {
        var numbers = new Uint32Array(1);
        window.crypto.getRandomValues(numbers);
        var numberString = numbers[0].toString();
        var padding = "00000000";
        var paddedNumber = padding + numberString;
        number = paddedNumber.substring(paddedNumber.length - 8, paddedNumber.length);
      }
    } finally {
      if (!number) {
        number = Math.round(Math.random() * 1e8);
      }
    }
    return prefix + "_" + number;
  },
  /*
  * Note: this is not a real guid, it just mimmics a real one. This should NOT be used to store unique sitewide ids
  * use it sparingly as it is expensive!
  */
  createFauxGUID: function(prefix) {
    var S = function() {
      return "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(Math.floor(Math.random() * 59));
    };
    return prefix + "_" + S() + S() + S() + S() + S() + S() + S() + S() + S() + S() + S() + S() + S() + S() + S();
  },
  /*
   *Used to clear selected text that you don't want selected
   */
  clearSelection: function() {
    if (window.getSelection) {
      if (window.getSelection().empty) {
        window.getSelection().empty();
      } else if (window.getSelection().removeAllRanges) {
        window.getSelection().removeAllRanges();
      } else if (document.selection) {
        document.selection.empty();
      }
    }
  },
  /**
  * QualtricsTools.focusInput
  * does a better job at focusing in ie6
  * @param {HTMLInputNode | HTMLTextareaNode} - the node you want to focus
  */
  focusInput: function(el, opt_pos) {
    if (opt_pos == void 0) {
      $(el).focus();
      return;
    }
    if (el && el.createTextRange) {
      var range = el.createTextRange();
      if (range) {
        range.collapse(true);
        range.moveStart("character", opt_pos);
        range.moveEnd("character", opt_pos);
        try {
          range.select();
        } catch (e) {
        }
      }
    } else if (el) {
      if ($(el).focus) {
        $(el).focus();
        if (el.setSelectionRange) {
          try {
            el.setSelectionRange(opt_pos, opt_pos);
          } catch (e) {
          }
        }
      }
    }
  },
  /**
  * QualtricsTools.getPageSize
  * get page size
  */
  getPageSize: function() {
    var xScroll, yScroll;
    if (window.innerHeight && window.scrollMaxY) {
      xScroll = document.body.scrollWidth;
      yScroll = window.innerHeight + window.scrollMaxY;
    } else if (document.body.scrollHeight > document.body.offsetHeight) {
      xScroll = document.body.scrollWidth;
      yScroll = document.body.scrollHeight;
    } else {
      xScroll = document.body.offsetWidth;
      yScroll = document.body.offsetHeight;
    }
    var windowWidth, windowHeight;
    if (self.innerHeight) {
      windowWidth = self.innerWidth;
      windowHeight = self.innerHeight;
    } else if (document.documentElement && document.documentElement.clientHeight) {
      windowWidth = document.documentElement.clientWidth;
      windowHeight = document.documentElement.clientHeight;
    } else if (document.body) {
      windowWidth = document.body.clientWidth;
      windowHeight = document.body.clientHeight;
    }
    if (yScroll < windowHeight) {
      pageHeight = windowHeight;
    } else {
      pageHeight = yScroll;
    }
    if (xScroll < windowWidth) {
      pageWidth = windowWidth;
    } else {
      pageWidth = xScroll;
    }
    var arrayPageSize = { pageWidth: pageWidth, pageHeight: pageHeight, windowWidth: windowWidth, windowHeight: windowHeight, 0: pageWidth, 1: pageHeight, 2: windowWidth, 3: windowHeight };
    return arrayPageSize;
  },
  getScrollInfo: function() {
    if (document.viewport.getScrollOffsets) {
      var scrollOffsets = document.viewport.getScrollOffsets();
      return [scrollOffsets.left, scrollOffsets.top];
    }
    return [0, 0];
  },
  /**
  * QualtricsTools.getInstanceHelper
  * a lot of objects need to find instances of themselves by the id.
  * so this function just returns the function that does that so we dont have to duplicate it all over the place.
  * @param {Array} registry - the list of objects to search.
  * @param {String} idString - the name of the id attribute to search on.
  * @return {Object|undefined} - the found object instance.
  */
  getInstanceHelper: function(registry, idString) {
    return function(id) {
      if (registry.push) {
        for (var i2 = 0, len2 = registry.length; i2 < len2; ++i2) {
          if (registry[i2][idString] == id) {
            return registry[i2];
          }
        }
      } else {
        if (registry[id]) {
          return registry[id];
        }
      }
      return void 0;
    };
  },
  /*
   * Creates a protected intance registry that can do some cool stuff
   * instead of having a getInstance on every class, you can just create a registry on a base class, then register all of your instances with that
   * There is a convenient deregister function that will remove the item from the registry, which you should call when the item is destroyed
   */
  createInstanceRegistry: function() {
    var _reg = {};
    return {
      /*
       * Assigns an id to obj, and places it in the registry
       * @param {Object} obj - the object to register
       * @param {String} prefix - the prefix to use to register the object with
       */
      register: function(obj, prefix) {
        obj.id = obj.id || QualtricsTools.createNewId(prefix);
        _reg[obj.id] = obj;
      },
      /*
       * Removes a registered object from the registry
       * @param {Object} obj - the object to deregister
       */
      deregister: function(obj) {
        _reg[obj.id] = null;
        delete _reg[obj.id];
      },
      /*
       * deletes all items out of the registry
       * could potentially just set _reg = {}, though I'm not sure about the memory implicaions
       */
      clearRegistry: function() {
        for (var i2 in _reg) {
          _reg[i2] = null;
          delete _reg[i2];
        }
      },
      /*
       * Returns an instance of the object
       */
      getInstance: function(id) {
        return _reg[id];
      },
      /*
       *  Will return all instances that match search
       */
      getInstancesLike: function(search) {
        var ret = [];
        for (var i2 in _reg) {
          if (i2.indexOf(search) !== -1) {
            ret.push(_reg[i2]);
          }
        }
        return ret;
      },
      /*
       * runs a callback on each function in the registry
       */
      executeOnAll: function(func) {
        for (var i2 in _reg) {
          if (typeof _reg[i2][func] == "function")
            _reg[i2][func]();
        }
      }
    };
  },
  sortByKey: function(array, key) {
    return array.sort(function(a, b) {
      var x = a[key];
      var y = b[key];
      return x < y ? -1 : x > y ? 1 : 0;
    });
  },
  /**
  * QualtricsTools.fastDown finds an child node with the specified class name.
  * NOTE: this is NOT AN COMPLETE SEARCH, it only goes down direct levels, meaning it searches every FIRST CHILD.
  * if the thing you are searching for needs to branch from a sibling this will be VERY SLOW in IE.
  * @param Node startNode - the node to start from.
  * @param String className - the class name you are searching for
  * @param Int maxDepth - the number of levels to search before giving up
  */
  fastDown: function(startNode, className, maxDepth) {
    if ($(startNode).hasClassName(className)) {
      return startNode;
    }
    var parentNode = startNode;
    var lastRealNode = null;
    if (maxDepth == void 0) {
      maxDepth = 10;
    }
    for (var i2 = 0; i2 < maxDepth; ++i2) {
      if (!parentNode.firstChild) {
        break;
      }
      var child = parentNode.firstChild;
      if (child && child.nodeType == 3 && child.nextSibling) {
        child = child.nextSibling;
      }
      if (child) {
        if (child.nodeType == 1) {
          if ($(child).hasClassName(className)) {
            return child;
          } else if (child.nextSibling && child.nextSibling.nodeType == 1 && $(child.nextSibling).hasClassName(className)) {
            return child.nextSibling;
          }
          parentNode = child;
        }
      }
    }
    if (!className)
      return child;
    return $(startNode).down("." + className);
  },
  /**
  * fastUp finds an ancestor node with the specified class name.
  * @param Node startNode - the node to start from.
  * @param String className - the class name you are searching for
  * @param Int maxDepth - the number of levels to search before giving up
  */
  fastUp: function(startNode, className, maxDepth) {
    if (!$(startNode))
      return null;
    if ($(startNode).hasClassName && $(startNode).hasClassName(className)) {
      return startNode;
    }
    var thisNode = startNode;
    if (maxDepth == void 0) {
      maxDepth = 10;
    }
    for (var i2 = 0; i2 < maxDepth; ++i2) {
      var parent = thisNode.parentNode;
      if (parent) {
        if (parent.nodeType == 1) {
          if ($(parent).hasClassName && $(parent).hasClassName(className)) {
            return parent;
          }
          thisNode = parent;
        }
      }
    }
    if ($(startNode).up)
      return $(startNode).up("." + className);
    else
      return null;
  },
  /**
   * An object that can get information about the browser.
   * NOTE: this is used for the browser question type to report browser info to the user
   * it should not be used for code branching because it will return things like Safari instead of webkit.
   */
  BrowserInfo: {
    /** A cache of the browser's information so we don't repeat work. */
    cachedBrowserInfo: null,
    // Flash Player Version Detection - Rev 1.6
    // Detect Client Browser type
    // Copyright(c) 2005-2006 Adobe Macromedia Software, LLC. All rights reserved.
    // Taken from AC_OETags.js - http://www.adobe.com/products/flashplayer/download/detection_kit/
    Flash: {
      isIE: navigator.appVersion.indexOf("MSIE") != -1 ? true : false,
      isWin: navigator.appVersion.toLowerCase().indexOf("win") != -1 ? true : false,
      isOpera: navigator.userAgent.indexOf("Opera") != -1 ? true : false,
      ControlVersion: function() {
        var version;
        var axo;
        var e;
        try {
          axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.7");
          version = axo.GetVariable("$version");
        } catch (e2) {
        }
        if (!version) {
          try {
            axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.6");
            version = "WIN 6,0,21,0";
            axo.AllowScriptAccess = "always";
            version = axo.GetVariable("$version");
          } catch (e2) {
          }
        }
        if (!version) {
          try {
            axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.3");
            version = axo.GetVariable("$version");
          } catch (e2) {
          }
        }
        if (!version) {
          try {
            axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.3");
            version = "WIN 3,0,18,0";
          } catch (e2) {
          }
        }
        if (!version) {
          try {
            axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash");
            version = "WIN 2,0,0,11";
          } catch (e2) {
            version = -1;
          }
        }
        return version;
      },
      // JavaScript helper required to detect Flash Player PlugIn version information
      GetSwfVer: function() {
        var flashVer = -1;
        if (navigator.plugins != null && navigator.plugins.length > 0) {
          if (navigator.plugins["Shockwave Flash 2.0"] || navigator.plugins["Shockwave Flash"]) {
            var swVer2 = navigator.plugins["Shockwave Flash 2.0"] ? " 2.0" : "";
            var flashDescription = navigator.plugins["Shockwave Flash" + swVer2].description;
            var descArray = flashDescription.split(" ");
            var tempArrayMajor = descArray[2].split(".");
            var versionMajor = tempArrayMajor[0];
            var versionMinor = tempArrayMajor[1];
            var versionRevision = descArray[3];
            if (versionRevision == "") {
              versionRevision = descArray[4];
            }
            if (versionRevision[0] == "d") {
              versionRevision = versionRevision.substring(1);
            } else if (versionRevision[0] == "r") {
              versionRevision = versionRevision.substring(1);
              if (versionRevision.indexOf("d") > 0) {
                versionRevision = versionRevision.substring(0, versionRevision.indexOf("d"));
              }
            }
            flashVer = versionMajor + "." + versionMinor + "." + versionRevision;
          }
        } else if (navigator.userAgent.toLowerCase().indexOf("webtv/2.6") != -1)
          flashVer = 4;
        else if (navigator.userAgent.toLowerCase().indexOf("webtv/2.5") != -1)
          flashVer = 3;
        else if (navigator.userAgent.toLowerCase().indexOf("webtv") != -1)
          flashVer = 2;
        else if (this.isIE && this.isWin && !this.isOpera) {
          flashVer = this.ControlVersion();
        }
        return flashVer;
      }
    },
    /** Parses the user agent string and gets the information about the browser */
    _parseUserAgent: function(userAgent) {
      var agentString = userAgent || (typeof navigator !== "undefined" ? navigator.userAgent : "");
      var browserInfo = {
        ua: agentString,
        browser: ""
      };
      var rvPattern = /rv:([\d+\.]+)/;
      var uaPattern = /(([^\/\s]*)\/([^\s;]*))/;
      var pattern;
      var ua = agentString;
      var matches = true;
      while (matches) {
        matches = uaPattern.exec(ua);
        if (matches) {
          ua = RegExp.rightContext;
          if (matches[2] && matches[2].toLowerCase) {
            switch (matches[2].toLowerCase()) {
              case "chrome":
                browserInfo.browser = matches[2];
                browserInfo.version = matches[3];
                if (ua.toLowerCase().indexOf("edge") === -1) {
                  matches = false;
                }
                break;
              case "trident":
                if (parseFloat(matches[3]) >= 7) {
                  var versionMatches = rvPattern.exec(ua);
                  if (versionMatches) {
                    browserInfo.browser = "MSIE";
                    browserInfo.version = versionMatches[1];
                    matches = false;
                  }
                }
                break;
              case "edge":
              case "firefox":
              case "netscape":
              case "safari":
              case "camino":
              case "mosaic":
              case "galeon":
              case "opera":
              case "mozilla":
              case "konqueror":
              case "applewebkit":
              case "nintendobrowser":
                browserInfo.browser = matches[2];
                browserInfo.version = matches[3];
            }
          }
        }
      }
      if (browserInfo.browser == "Mozilla") {
        if (browserInfo.browser == "Mozilla" && agentString.indexOf("(compatible;") != -1) {
          pattern = /\(compatible; ([^ ]*)[ \/]([^;]*).*/;
          matches = pattern.exec(agentString);
          if (matches) {
            browserInfo.browser = matches[1];
            browserInfo.version = matches[2];
          }
        }
      }
      function handleDefaultOS() {
        pattern = /U;\s*([^;\)]*)/;
        matches = pattern.exec(agentString);
        if (matches) {
          browserInfo.os = matches[1];
        } else {
          pattern = /\(([^)]*)\)/;
          matches = pattern.exec(agentString);
          if (matches) {
            matches = matches[1].split(";");
            if (matches[0][0] == "X") {
              browserInfo.os = matches[1];
            } else if (matches[0] == "Mobile" && matches[1]) {
              browserInfo.os = matches[1];
            } else if (matches[0] == "Linux" && matches[1] && matches[1].indexOf("Android") !== -1) {
              browserInfo.os = matches[1];
            } else {
              browserInfo.os = matches[0];
            }
          }
        }
        if (browserInfo.os) {
          browserInfo.os = browserInfo.os.trim();
        }
      }
      handleDefaultOS();
      if (browserInfo.os == "iPad" || browserInfo.os == "iPhone") {
        browserInfo.browser = "Safari";
        browserInfo.version = "Unknown";
      }
      switch (browserInfo.browser.toLowerCase()) {
        case "msie":
          pattern = /\(compatible;[^;]*;\s*([^;\)]*)/;
          matches = pattern.exec(agentString);
          if (matches) {
            browserInfo.os = matches[1];
          } else {
            handleDefaultOS();
          }
          break;
        case "opera":
          pattern = /\(([^;\)]*)/;
          matches = pattern.exec(agentString);
          browserInfo.os = matches[1];
          break;
        case "konqueror":
          pattern = /Konqueror[^;]*;\s*([^;\)]*)/;
          matches = pattern.exec(agentString);
          browserInfo.os = matches[1];
          break;
        case "safari":
          pattern = /Version\/([^ ]*)/;
          matches = pattern.exec(agentString);
          if (matches && matches[1]) {
            matches = pattern.exec(agentString);
            browserInfo.version = matches && matches[1];
          } else {
            pattern = /CriOS\/([^ ]*)/;
            matches = pattern.exec(agentString);
            if (matches && matches[1]) {
              matches = pattern.exec(agentString);
              browserInfo.version = matches && matches[1];
              browserInfo.browser = "Chrome";
            }
          }
          if (agentString.indexOf("iPhone") != -1) {
            browserInfo.browser += " iPhone";
          }
          if (agentString.indexOf("iPad") != -1) {
            browserInfo.browser += " iPad";
          }
        case "firefox":
        default:
          handleDefaultOS();
          break;
      }
      if (browserInfo.os) {
        browserInfo.os = browserInfo.os.replace(/^\s+|\s+$/g, "");
      }
      browserInfo.resolution = { x: screen.width, y: screen.height };
      browserInfo.java = navigator.javaEnabled() ? 1 : 0;
      browserInfo.flashVersion = this.Flash.GetSwfVer();
      if (browserInfo.flashVersion && browserInfo.flashVersion.replace) {
        browserInfo.flashVersion = browserInfo.flashVersion.replace(/,/g, ".");
        browserInfo.flashVersion = browserInfo.flashVersion.replace(/WIN /g, "");
      }
      return browserInfo;
    },
    /** Returns the browser's information */
    getBrowserInfo: function() {
      if (!this.cachedBrowserInfo)
        this.cachedBrowserInfo = this._parseUserAgent();
      return this.cachedBrowserInfo;
    },
    /**
     * We make a high accuracy request and then try a medium accuracy call incase they have separate permissions
     * Cross browser code modified from https://github.com/estebanav/javascript-mobile-desktop-geolocation
     */
    getCurrentPosition: function(callback) {
      var timeout = 1e4;
      var maximumAge = 6e4;
      var highAccuracyOpts = {
        enableHighAccuracy: true,
        timeout: timeout,
        maximumAge: maximumAge
      };
      var mediumAccuracyOpts = {
        enableHighAccuracy: false,
        timeout: timeout,
        maximumAge: maximumAge
      };
      var mediumAccuracySuccess = function(pos) {
        var returnData = {
          accuracy: pos.coords.accuracy || -1,
          latitude: pos.coords.latitude,
          longitude: pos.coords.longitude
        };
        this.getBrowserInfo();
        this.cachedBrowserInfo.locationaccuracy = returnData.accuracy;
        this.cachedBrowserInfo.latitude = returnData.latitude;
        this.cachedBrowserInfo.longitude = returnDataos.longitude;
        if (callback)
          callback(returnData);
      }.bind(this);
      var mediumAccuracyError = function(pos) {
        this.getBrowserInfo();
        this.cachedBrowserInfo.locationerror = pos.code;
        if (callback)
          callback({ error: pos.code });
      }.bind(this);
      var highAccuracySuccess = function(pos) {
        var returnData = {
          accuracy: pos.coords.accuracy || -1,
          latitude: pos.coords.latitude,
          longitude: pos.coords.longitude
        };
        this.getBrowserInfo();
        this.cachedBrowserInfo.locationaccuracy = returnData.accuracy;
        this.cachedBrowserInfo.latitude = returnData.latitude;
        this.cachedBrowserInfo.longitude = returnData.longitude;
        if (callback)
          callback(returnData);
      }.bind(this);
      var highAccuracyError = function(pos) {
        this.geoPosition.getCurrentPosition(mediumAccuracySuccess, mediumAccuracyError, mediumAccuracyOpts);
      }.bind(this);
      if (!this.geoPosition.getCurrentPosition(highAccuracySuccess, highAccuracyError, highAccuracyOpts)) {
        this.getBrowserInfo();
        this.cachedBrowserInfo.locationerror = 1;
        callback({ locationerror: 1 });
      }
    },
    geoPosition: function() {
      var pub = {};
      var provider = null;
      var u = "undefined";
      var getCurrentPosition;
      pub.getCurrentPosition = function(success, error, opts) {
        try {
          var hasGeolocation = typeof navigator.geolocation != u;
          if (!hasGeolocation) {
            if (!confirm("Qualtrics wants to use your location.\nDo you want to allow it?")()) {
              return false;
            }
          }
          if (typeof geoPositionSimulator != u && geoPositionSimulator.length > 0) {
            provider = geoPositionSimulator;
          } else if (typeof bondi != u && typeof bondi.geolocation != u) {
            provider = bondi.geolocation;
          } else if (hasGeolocation) {
            provider = navigator.geolocation;
            getCurrentPosition = function(success2, error2, opts2) {
              function _success(p) {
                var params;
                if (typeof p.latitude != u) {
                  params = {
                    timestamp: p.timestamp,
                    coords: {
                      latitude: p.latitude,
                      longitude: p.longitude
                    }
                  };
                } else {
                  params = p;
                }
                success2(params);
              }
              provider.getCurrentPosition(_success, error2, opts2);
            };
          } else if (typeof window.blackberry != u && blackberry.location.GPSSupported) {
            if (typeof blackberry.location.setAidMode == u) {
              return false;
            }
            blackberry.location.setAidMode(2);
            getCurrentPosition = function(success2, error2, opts2) {
              var bb = {
                success: 0,
                error: 0,
                blackberryTimeoutId: -1
              };
              function handleBlackBerryLocationTimeout() {
                if (bb.blackberryTimeoutId != -1) {
                  bb.error({
                    message: "Timeout error",
                    code: 3
                  });
                }
              }
              bb.success = success2;
              bb.error = error2;
              if (opts2["timeout"]) {
                bb.blackberryTimeoutId = setTimeout(handleBlackBerryLocationTimeout, opts2["timeout"]);
              } else {
                bb.blackberryTimeoutId = setTimeout(handleBlackBerryLocationTimeout, 6e4);
              }
              blackberry.location.onLocationUpdate(function() {
                clearTimeout(bb.blackberryTimeoutId);
                bb.blackberryTimeoutId = -1;
                if (bb.success && bb.error) {
                  if (blackberry.location.latitude == 0 && blackberry.location.longitude == 0) {
                    bb.error({ message: "Position unavailable", code: 2 });
                  } else {
                    var timestamp = null;
                    if (blackberry.location.timestamp) {
                      timestamp = new Date(blackberry.location.timestamp);
                    }
                    bb.success({
                      timestamp: timestamp,
                      coords: {
                        latitude: blackberry.location.latitude,
                        longitude: blackberry.location.longitude
                      }
                    });
                  }
                  bb.success = null;
                  bb.error = null;
                }
              });
              blackberry.location.refreshLocation();
            };
            provider = blackberry.location;
          } else if (typeof Mojo != u && typeof Mojo.Service.Request != "Mojo.Service.Request") {
            provider = true;
            getCurrentPosition = function(success2, error2, opts2) {
              parameters = {};
              if (opts2) {
                if (opts2.enableHighAccuracy && opts2.enableHighAccuracy == true) {
                  parameters.accuracy = 1;
                }
                if (opts2.maximumAge) {
                  parameters.maximumAge = opts2.maximumAge;
                }
                if (opts2.responseTime) {
                  if (pts.responseTime < 5) {
                    parameters.responseTime = 1;
                  } else if (opts2.responseTime < 20) {
                    parameters.responseTime = 2;
                  } else {
                    parameters.timeout = 3;
                  }
                }
              }
              r = new Mojo.Service.Request("palm://com.palm.location", {
                method: "getCurrentPosition",
                parameters: parameters,
                onSuccess: function(p) {
                  success2({
                    timestamp: p.timestamp,
                    coords: {
                      latitude: p.latitude,
                      longitude: p.longitude,
                      heading: p.heading
                    }
                  });
                },
                onFailure: function(e) {
                  if (e.errorCode == 1) {
                    error2({
                      code: 3,
                      message: "Timeout"
                    });
                  } else if (e.errorCode == 2) {
                    error2({
                      code: 2,
                      message: "Position unavailable"
                    });
                  } else {
                    error2({
                      code: 0,
                      message: "Unknown Error: webOS-code" + errorCode
                    });
                  }
                }
              });
            };
          } else if (typeof device != u && typeof device.getServiceObject != u) {
            provider = device.getServiceObject("Service.Location", "ILocation");
            getCurrentPosition = function(success2, error2, opts2) {
              function callback(transId, eventCode, result) {
                if (eventCode == 4) {
                  error2({ message: "Position unavailable", code: 2 });
                } else {
                  success2({
                    timestamp: null,
                    coords: {
                      latitude: result.ReturnValue.Latitude,
                      longitude: result.ReturnValue.Longitude,
                      altitude: result.ReturnValue.Altitude,
                      heading: result.ReturnValue.Heading
                    }
                  });
                }
              }
              var criteria = new Object();
              criteria.LocationInformationClass = "BasicLocationInformation";
              provider.ILocation.GetLocation(criteria, callback);
            };
          } else {
            provider = false;
          }
          if (provider && getCurrentPosition) {
            getCurrentPosition(success, error, opts);
            return true;
          } else {
            return false;
          }
        } catch (e) {
          if (typeof console != u)
            console.log(e);
          return false;
        }
        return provider != null;
      };
      return pub;
    }()
  },
  /**
   * QualtricsTools.cumulativeScrollOffset
   * just like the prototype Element.cumulativeScrollOffset
   * except it doesnt include the page scroll values
   * I find this to be more useful.
   *
   * @param {Node} element
   * @return {Array} [x, y]
   */
  cumulativeScrollOffset: function(element) {
    var scrollElement = element;
    var scrollOffset = [0, 0];
    do {
      if (scrollElement.nodeName !== "HTML" && scrollElement.nodeName !== "BODY") {
        scrollOffset[0] += scrollElement.scrollLeft || 0;
        scrollOffset[1] += scrollElement.scrollTop || 0;
      }
      scrollElement = scrollElement.parentNode;
    } while (scrollElement);
    return scrollOffset;
  },
  /**
   * Checks to see if an element is fixed position, or if any of it's ancestors are fixed position
   * @param {Node} element
   * @returns {Boolean}
   */
  isFixed: function(element) {
    try {
      var position = $(element).getStyle("position");
    } catch (e) {
      position = element.style.position;
    }
    try {
      var offsetParent = element.offsetParent;
    } catch (e) {
      offsetParent = document.body;
    }
    return !!element && (element.style && position == "fixed" || offsetParent && QualtricsTools.isFixed(offsetParent));
  },
  /*
   * will add an element to the hidden helper so you can do cool stuff with it
   * Like get the size before you actually append it to something
   * Or make a sortable before the sortable is even returned :)
   */
  addToHiddenHelper: function(element) {
    var hidden = $("QHiddenHelper");
    if (!hidden) {
      hidden = QBuilder("div", { id: "QHiddenHelper" });
      document.body.appendChild(hidden);
    }
    hidden.appendChild($(element));
  },
  getSurveySelectMenu: function(opt_filter, opt_action) {
    opt_filter = opt_filter === "" ? void 0 : opt_filter;
    if (!opt_action) {
      opt_action = "URLTools.post(setActiveSurvey, $surveyId)";
    }
    var items = [];
    if (Qualtrics.folders && opt_filter === void 0 && !Object.isArray(Qualtrics.folders["SurveyFolders"])) {
      folderOrdering = [];
      for (var folderId in Qualtrics.folders["SurveyFolders"]) {
        folderOrdering.push({ "id": folderId, "name": Qualtrics.folders["SurveyFolders"][folderId] });
      }
      folderOrdering.sort(function(a, b) {
        var lowerA = a["name"].toLowerCase();
        var lowerB = b["name"].toLowerCase();
        if (lowerA < lowerB)
          return -1;
        if (lowerA == lowerB)
          return 0;
        if (lowerA > lowerB)
          return 1;
      });
      for (var i2 = 0; i2 < folderOrdering.length; ++i2) {
        var folderId = folderOrdering[i2]["id"];
        var subMenuItems = [];
        for (var surveyId in Qualtrics.folders["Surveys"]) {
          if (typeof Qualtrics.folders["Surveys"][surveyId] == "function") {
            continue;
          }
          var containingFolderId = Qualtrics.folders["Surveys"][surveyId];
          if (folderId == containingFolderId && Qualtrics.surveys[surveyId]) {
            var current_action = opt_action.replace("$surveyId", surveyId);
            subMenuItems.push({
              label: Qualtrics.surveys[surveyId],
              action: current_action,
              className: "Survey",
              defer: true
            });
          }
        }
        var item = {
          label: Qualtrics.folders["SurveyFolders"][folderId],
          className: "Folder",
          submenu: {
            items: subMenuItems
          }
        };
        items.push(item);
      }
      items.push({ separator: true });
    }
    for (surveyId in Qualtrics.surveys) {
      if (!Qualtrics.surveys.hasOwnProperty(surveyId)) {
        continue;
      }
      var inFolder = Qualtrics.folders && Qualtrics.folders["Surveys"] && Qualtrics.folders["Surveys"][surveyId];
      var showMenu = !inFolder;
      if (opt_filter !== void 0) {
        showMenu = Qualtrics.surveys[surveyId].toLowerCase().indexOf(opt_filter.toLowerCase()) != -1;
      }
      if (showMenu) {
        var current_action = opt_action.replace("$surveyId", surveyId);
        item = {
          label: Qualtrics.surveys[surveyId],
          action: current_action,
          className: "Survey",
          defer: true
        };
        items.push(item);
      }
    }
    var searchValue = opt_filter || getMessage("EditSection", "SearchExistingSurveys") + "...";
    var surveySelectMenuDef = {
      items: items,
      searchText: searchValue,
      search: "QualtricsTools.getSurveySelectMenu($search, " + opt_action + ")"
    };
    return surveySelectMenuDef;
  },
  surveySelectKeyDownHandler: function(el, evt, callback) {
    if (Qualtrics.Navigation.subSection == "Blocks") {
      if (evt && evt.shiftKey && (evt.ctrlKey || evt.metaKey)) {
        if (evt.preventDefault)
          evt.preventDefault();
        return QModules.loadModule("supportmode.js");
      }
    }
    Qualtrics.Menu.showMenu(callback, el, null, evt);
  },
  /**
   *  color conversion helpers
   *  ---'hex string' refers to colors in the format '#DF93AF'
   *  ---'dec' refers to ints or hex numeric values
   */
  decToHexString: function(dec, includeHash) {
    if (typeof dec == "string" && dec.substr(0, 1) == "#") {
      return dec;
    }
    var hex = dec.toString(16);
    hex = QualtricsTools.leftPadString(hex, "0", 6);
    return (includeHash === false ? "" : "#") + hex.toUpperCase();
  },
  hexStringToDec: function(hex) {
    return parseInt(QualtricsTools.stripHash(hex), 16);
  },
  hexStringToRgb: function(hex) {
    hex = QualtricsTools.stripHash(hex);
    var splitHex = hex.match(/.{1,2}/g);
    var rgb = [];
    for (var i2 = 0; i2 < splitHex.length; i2++) {
      rgb.push(parseInt(splitHex[i2], 16));
    }
    return rgb;
  },
  //takes an array of rgb values
  rgbToHexString: function(rgb, includeHash) {
    var hex = includeHash === false ? "" : "#";
    for (var i2 = 0; i2 < rgb.length; i2++) {
      var val = Math.round(rgb[i2]);
      if (val < 0)
        val = 0;
      else if (val > 255)
        val = 255;
      val = QualtricsTools.leftPadString(val.toString(16), "0", 2);
      hex += val.toUpperCase();
    }
    return hex;
  },
  hexStringToHsv: function(hex) {
    var rgb = QualtricsTools.hexStringToRgb(hex);
    return QualtricsTools.rgbToHsv(rgb);
  },
  hsvToHexString: function(hsv, includeHash) {
    var rgb = QualtricsTools.hsvToRgb(hsv);
    return QualtricsTools.rgbToHexString(rgb, includeHash);
  },
  hsvToRgb: function(hsv) {
    var rgb = [0, 0, 0];
    if (hsv[2] != 0) {
      var i2 = Math.floor(hsv[0] * 6);
      var f = hsv[0] * 6 - i2;
      var p = hsv[2] * (1 - hsv[1]);
      var q = hsv[2] * (1 - hsv[1] * f);
      var t = hsv[2] * (1 - hsv[1] * (1 - f));
      switch (i2) {
        case 1:
          rgb[0] = q;
          rgb[1] = hsv[2];
          rgb[2] = p;
          break;
        case 2:
          rgb[0] = p;
          rgb[1] = hsv[2];
          rgb[2] = t;
          break;
        case 3:
          rgb[0] = p;
          rgb[1] = q;
          rgb[2] = hsv[2];
          break;
        case 4:
          rgb[0] = t;
          rgb[1] = p;
          rgb[2] = hsv[2];
          break;
        case 5:
          rgb[0] = hsv[2];
          rgb[1] = p;
          rgb[2] = q;
          break;
        case 6:
        case 0:
          rgb[0] = hsv[2];
          rgb[1] = t;
          rgb[2] = p;
          break;
      }
    }
    for (var index = 0; index < rgb.length; index++) {
      rgb[index] *= 256;
    }
    return rgb;
  },
  rgbToHsv: function(rgb) {
    var max = rgb.max();
    var min = rgb.min();
    var hsv = [0, 0, max / 256];
    if (min != max) {
      var delta = max - min;
      hsv[1] = delta / max;
      if (rgb[0] == max) {
        hsv[0] = (rgb[1] - rgb[2]) / delta;
      } else if (rgb[1] == max) {
        hsv[0] = 2 + (rgb[2] - rgb[0]) / delta;
      } else {
        hsv[0] = 4 + (rgb[0] - rgb[1]) / delta;
      }
      hsv[0] /= 6;
      if (hsv[0] < 0) {
        hsv[0] += 1;
      }
      if (hsv[0] > 1) {
        hsv[0] -= 1;
      }
    }
    return hsv;
  },
  /**
   * darkens a hex color
   * @param {String} hex - a hex color with or without the #
   * @param {Number} amount is a scale from 0 to 1
   **/
  darkenColor: function(hex, amount) {
    var rgb = QualtricsTools.hexStringToRgb(hex);
    var hsv = QualtricsTools.rgbToHsv(rgb);
    var hueAdjustment = 0;
    if (hsv[0] < 0.15) {
      hueAdjustment = hsv[0] / 2;
      hsv[0] -= hueAdjustment;
    }
    var valueFactor = amount;
    hsv[2] = hsv[2] - valueFactor + hueAdjustment;
    if (hsv[2] < 0) {
      hsv[2] = 0;
    }
    rgb = QualtricsTools.hsvToRgb(hsv);
    return QualtricsTools.rgbToHexString(rgb, true);
  },
  /**
   * lightens a hex color
   * @param {String} hex - a hex color with or without the #
   * @param {Number} amount is a scale from 0 to 1
   **/
  lightenColor: function(hex, amount) {
    var rgb = QualtricsTools.hexStringToRgb(hex);
    var hsv = QualtricsTools.rgbToHsv(rgb);
    var hueAdjustment = 0;
    if (hsv[0] < 0.15) {
      hueAdjustment = hsv[0] / 2;
      hsv[0] -= hueAdjustment;
    }
    var valueFactor = Number(amount);
    hsv[2] = hsv[2] + valueFactor + hueAdjustment;
    if (hsv[2] > 1) {
      hsv[2] = 1;
    }
    rgb = QualtricsTools.hsvToRgb(hsv);
    return QualtricsTools.rgbToHexString(rgb, true);
  },
  fadeColor: function(hex, amount) {
    var rgb = QualtricsTools.hexStringToRgb(hex);
    var hsv = QualtricsTools.rgbToHsv(rgb);
    var hueAdjustment = 0;
    if (hsv[0] < 0.15) {
      hueAdjustment = hsv[0] / 2;
      hsv[0] -= hueAdjustment;
    }
    var saturationFactor = 1 - amount;
    hsv[1] = hsv[1] - saturationFactor;
    if (hsv[1] < 0) {
      hsv[1] = 0;
    }
    var valueFactor = Number(amount);
    hsv[2] = hsv[2] + valueFactor;
    if (hsv[2] > 1) {
      hsv[2] = 1;
    }
    rgb = QualtricsTools.hsvToRgb(hsv);
    return QualtricsTools.rgbToHexString(rgb, true);
  },
  stripHash: function(hex) {
    return hex.substr(0, 1) == "#" ? hex = hex.substr(1) : hex;
  },
  leftPadString: function(string, pad, length) {
    while (string.length < length) {
      string = pad + string;
    }
    return string;
  },
  //returns a color that would look good on another color
  getColorComplement: function(color) {
    if (typeof color == "number") {
      color = QualtricsTools.decToHexString(color, true);
    }
    var hasHash = color.substr(0, 1) == "#";
    var hsv = QualtricsTools.hexStringToHsv(color);
    if (hsv[2] == 0) {
      hsv[2] = 0.999;
    } else if (hsv[2] < 0.3) {
      hsv[2] *= 1.8;
    } else {
      hsv[2] *= 0.2;
    }
    return QualtricsTools.hsvToHexString(hsv, hasHash);
  },
  getQueryVariable: function(URL, paramToFind) {
    var questionMark = URL.split("?");
    if (questionMark.length != 2)
      return null;
    var vars = questionMark[1].split("&");
    for (var i2 = 0; i2 < vars.length; i2++) {
      var pair = vars[i2].split("=");
      if (decodeURIComponent(pair[0]) === paramToFind)
        return decodeURIComponent(pair[1]);
    }
    return null;
  },
  isArray: function(v, opt_andNotEmpty) {
    return v && Object.prototype.toString.call(v) === "[object Array]" && (!opt_andNotEmpty || v.length);
  },
  isObject: function(v, opt_andNotEmpty) {
    return v && Object.prototype.toString.call(v) === "[object Object]" && (!opt_andNotEmpty || Object.keys(v).length);
  },
  arraySum: function(arrayOfNumbers) {
    if (!QualtricsTools.isArray(arrayOfNumbers))
      return false;
    if (!arrayOfNumbers.length)
      return 0;
    if (arrayOfNumbers.length == 1)
      return arrayOfNumbers[0];
    var len2 = arrayOfNumbers.length, sum = 0;
    for (var i2 = 0; i2 < len2; ++i2) {
      sum += arrayOfNumbers[i2];
    }
    return sum;
  },
  arrayMean: function(arrayOfNumbers) {
    if (!QualtricsTools.isArray(arrayOfNumbers))
      return false;
    if (!arrayOfNumbers.length)
      return 0;
    if (arrayOfNumbers.length == 1)
      return arrayOfNumbers[0];
    return QualtricsTools.arraySum(arrayOfNumbers) / arrayOfNumbers.length;
  },
  arrayMedian: function(arrayOfNumbers) {
    if (!QualtricsTools.isArray(arrayOfNumbers))
      return false;
    if (!arrayOfNumbers.length)
      return 0;
    if (arrayOfNumbers.length == 1)
      return arrayOfNumbers[0];
    var arr = $(arrayOfNumbers).clone().sort(function(a, b) {
      return a - b;
    });
    var medIndex = (arr.length - 1) / 2;
    var flr = Math.floor(medIndex);
    return medIndex === flr ? arr[flr] : (arr[flr] + arr[flr + 1]) / 2;
  },
  arrayVariance: function(arrayOfNumbers) {
    if (!QualtricsTools.isArray(arrayOfNumbers))
      return false;
    if (!arrayOfNumbers.length || arrayOfNumbers.length == 1)
      return 0;
    var mean = QualtricsTools.arrayMean(arrayOfNumbers);
    var i2 = arrayOfNumbers.length, v = 0;
    while (i2--) {
      v += Math.pow(arrayOfNumbers[i2] - mean, 2);
    }
    return v / arrayOfNumbers.length;
  },
  arrayStdDev: function(arrayOfNumbers) {
    if (!QualtricsTools.isArray(arrayOfNumbers))
      return false;
    if (!arrayOfNumbers.length || arrayOfNumbers.length == 1)
      return 0;
    return Math.sqrt(QualtricsTools.arrayVariance(arrayOfNumbers));
  },
  /**
   * Merges any number of arrays, ensuring unique entries.
   * The order of the resulting array will be maintained according to the order
   * of arrays passed as arguments
   *
   * NOTE: this uses $({array}).indexOf to compare uniqueness of array entries
   * @return  {Array} the merged array with unique
   */
  arrayMerge: function() {
    var arrays = Array.prototype.slice.call(arguments);
    var a = [];
    for (var i2 = 0, len2 = arrays.length; i2 < len2; ++i2) {
      var array = arrays[i2];
      for (var j = 0, jlen = array.length; j < jlen; ++j) {
        if ($(a).indexOf(array[j]) === -1) {
          a.push(array[j]);
        }
      }
    }
    return a;
  },
  /**
   * QualtricsTools.filterForDisplay
   * Attempts to filter strings so that javascript is not immediately run and there is no bad behavior
   */
  filterForDisplay: function(value) {
    if (typeof value == "string") {
      var text = value;
      text = text.stripScripts();
      text = text.replace(/<meta\s[^>]*>/g, "");
      text = this.removeInlineJavascript(text, "onclick");
      text = this.removeInlineJavascript(text, "onload");
      text = this.removeInlineJavascript(text, "onerror");
      return text;
    } else {
      return value;
    }
  },
  removeInlineJavascript: function(text, attribute2) {
    var regexWithQuotes = new RegExp("(<\\w+[^>]*" + attribute2 + "\\s*=\\s*)(\"|')((?:[^\\2\\\\]|\\\\.)*?)\\2([^>]*>)", "gi");
    var regexWithOutQuotes = new RegExp("(<\\w+[^>]*" + attribute2 + "\\s*=\\s*)[^\\s>]+([^>]*>)", "gi");
    return text.replace(regexWithQuotes, "$1$2$2$4").replace(regexWithOutQuotes, '$1""$2');
  }
};
window.getPageSize = QualtricsTools.getPageSize;
function deleteChildren(node) {
  if (node) {
    if (!Qualtrics.Browser.IE) {
      node.innerHTML = "";
    } else {
      for (var x = node.childNodes.length - 1; x >= 0; --x) {
        var childNode = node.childNodes[x];
        if (childNode.onmouseover) {
          childNode.onmouseover = null;
        }
        if (childNode.onmouseout) {
          childNode.onmouseout = null;
        }
        if (childNode.onmousedown) {
          childNode.onmousedown = null;
        }
        if (childNode.onclick) {
          childNode.onclick = null;
        }
        if (childNode.hasChildNodes()) {
          deleteChildren(childNode);
        }
        node.removeChild(childNode);
        if (childNode.outerHTML) {
          childNode.outerHTML = "";
        }
        childNode = null;
      }
      node = null;
    }
  }
}
var QualtricsSETools = {
  highlightOn: false,
  killHighlight: false,
  highlightRegistry: [],
  unHighlightAll: function() {
    for (var i2 = 0, len2 = QualtricsSETools.highlightRegistry.length; i2 < len2; ++i2) {
      var questionNode = QualtricsSETools.highlightRegistry[i2];
      $(questionNode).removeClassName("Highlight");
      questionNode = null;
    }
    QualtricsSETools.highlightRegistry = [];
  },
  highlightHandler: function(evt) {
    QualtricsSETools.unHighlightAll();
    if (QualtricsSETools.highlightOn == true) {
      var clickedEl = Event.element(evt);
      var questionNode = QualtricsTools.fastUp(clickedEl, "QuestionOuter");
      if (questionNode) {
        QualtricsSETools.highlightRegistry.push(questionNode);
        $(questionNode).addClassName("Highlight");
      }
      questionNode = null;
      clickedEl = null;
    }
  },
  //use like this: QualtricsSETools.questionHighlighter();
  questionHighlighter: function() {
    if (!this.highlightOn) {
      Event.observe(document, "mousedown", QualtricsSETools.highlightHandler);
      if (!this.killHighlight)
        this.highlightOn = true;
    }
  },
  killHighlighter: function() {
    this.killHighlight = true;
  },
  scrollToDiv: function(id) {
    new Effect.ScrollTo(id, {
      afterFinish: function() {
        try {
          var p = $(id);
          found = false;
          while (!found) {
            p = $(p.nextSibling);
            if (p == null)
              found = true;
            else if (p.hasClassName && p.hasClassName("QuestionOuter"))
              found = true;
          }
          if (p) {
            new Effect.Highlight(p);
          }
        } catch (e) {
          console.error(e);
        }
      }
    });
  },
  /** Replaces the simple buttons with more advanced buttons that can be styled better */
  replaceButtons: function() {
    var next = $("NextButton");
    var save = $("SaveButton");
    var prev = $("PreviousButton");
    var jump = $("JumpButton");
    var parentNode = next ? next.parentNode : prev ? prev.parentNode : null;
    if (parentNode) {
      var innerHTML = "<input type=hidden id='buttonPressed' name='' value='1' />";
      if (next) {
        innerHTML += "<button style=\"display: none;\" id=\"submitPageFeauBTN\" type=\"submit\"></button><div tabindex='0' id='NextButton' role='button' aria-labelledby='NextLabel' onkeypress=\"if(!this.disabled){Qualtrics.SurveyEngine.navEnter(arguments[0],this, 'NextButton'); };  \" onclick=\"if(!this.disabled){Qualtrics.SurveyEngine.navClick(this, 'NextButton'); };  \"><label id='NextLabel' class='offScreen'>Next</label><span class='ButtonLeft'></span><span class='ButtonText' id='NextButtonText'>" + next.value + "</span><span class='ButtonRight'></span></div>";
      }
      if (save) {
        innerHTML += "<button style=\"display: none;\" id=\"submitPageFeauBTN\" type=\"submit\"></button><div tabindex='0' id='SaveButton' role='button' aria-labelledby='SaveLabel' onkeypress=\"if(!this.disabled){Qualtrics.SurveyEngine.navEnter(arguments[0],this, 'SavePageButton'); };  \" onclick=\"if(!this.disabled){Qualtrics.SurveyEngine.navClick(this, 'SavePageButton'); };  \"><label id='SaveLabel' class='offScreen'>Save</label><span class='ButtonLeft'></span><span class='ButtonText' id='SaveButtonText'>" + save.value + "</span><span class='ButtonRight'></span></div>";
      }
      if (prev) {
        innerHTML += "<button style=\"display: none;\" id=\"submitPageFeauBTN\" type=\"submit\"></button><div tabindex='0' id='PreviousButton' role='button' aria-labelledby='PreviousLabel' onkeypress=\"if(!this.disabled){Qualtrics.SurveyEngine.navEnter(arguments[0],this, 'PreviousButton'); };  \" onclick=\"if(!this.disabled){Qualtrics.SurveyEngine.navClick(this, 'PreviousButton');};  \"><label id='PreviousLabel' class='offScreen' >Previous</label><span class='ButtonLeft'></span><span class='ButtonText' id='PreviousButtonText'>" + prev.value + "</span><span class='ButtonRight'></span></div>";
      }
      if (jump) {
        innerHTML += '<button style="display: none;" id="submitPageFeauBTN" type="submit"></button><div tabindex=\'0\' class=\'' + jump.className + "' id='JumpButton' role='button' aria-labelledby='JumpLabel' onkeypress=\"if(!this.disabled){Qualtrics.SurveyEngine.navEnter(arguments[0],this, 'JumpButton'); };  \" onclick=\"if(!this.disabled){Qualtrics.SurveyEngine.navClick(this, 'JumpButton'); };  \"><label id='JumpLabel' class='offScreen'>Table of Contents</label><span class='ButtonLeft'></span><span class='ButtonText' id='JumpButtonText'>" + jump.value + "</span><span class='ButtonRight'></span></div>";
        innerHTML += "<input type='hidden' value='' name='JumpIndex' id='JumpIndex'>";
      }
      parentNode.innerHTML = innerHTML;
      return;
      if (next) {
        parentNode.removeChild(next);
        var newNext = QBuilder("button", { type: "submit", id: "NextButton" }, [
          QBuilder("span", { className: "ButtonLeft" }),
          QBuilder("span", { className: "ButtonText" }, [next.value]),
          QBuilder("span", { className: "ButtonRight" })
        ]);
        parentNode.appendChild(newNext);
        newNext.onclick = function() {
          $("buttonPressed").name = "NextButton";
        };
      }
      if (prev) {
        parentNode.removeChild(prev);
        var newPrev = QBuilder("button", { type: "submit", id: "PreviousButton" }, [
          QBuilder("span", { className: "ButtonLeft" }),
          QBuilder("span", { className: "ButtonText" }, [prev.value]),
          QBuilder("span", { className: "ButtonRight" })
        ]);
        parentNode.appendChild(newPrev);
        newPrev.onclick = function() {
          $("buttonPressed").name = "PreviousButton";
        };
      }
    }
  }
};
var QHeatMap = Class.create({
  clickedPoint: null,
  clickCounter: 1,
  clickHistory: 1,
  maxClicks: 1,
  id: null,
  showRegions: false,
  _imgWidth: null,
  _imgHeight: null,
  initialize: function(id, opt_maxClicks, opt_showRegions, opt_regions) {
    this.id = id;
    var that = this;
    if (opt_maxClicks)
      this.maxClicks = opt_maxClicks;
    this.showRegions = opt_showRegions || false;
    this.regions = opt_regions;
    this.clickdownFunction = this.clickdown.bind(this);
    this.clickupFunction = this.clickup.bind(this);
    Event.observe($(this.id + "_Container"), "mousedown", that.clickdownFunction);
    Event.observe($(this.id + "_Container"), "mouseup", that.clickupFunction);
    this.imageContainer = $(this.id + "_Container");
    this.image = $(this.id);
    var imageLoaded = false;
    var tempImage = new Image();
    tempImage.src = this.image.src;
    var tempImageLoaded = false;
    var imageLoadedCallback = function() {
      if (imageLoaded && tempImageLoaded) {
        this.imageLoaded();
      }
    }.bind(this);
    if (this.image.complete) {
      imageLoaded = true;
      imageLoadedCallback();
    } else {
      this.image.onload = function() {
        imageLoaded = true;
        imageLoadedCallback();
      };
    }
    if (tempImage.complete) {
      tempImageLoaded = true;
      this._imgWidth = tempImage.width;
      this._imgHeight = tempImage.height;
      imageLoadedCallback();
    } else {
      tempImage.onload = function() {
        tempImageLoaded = true;
        this._imgWidth = tempImage.width;
        this._imgHeight = tempImage.height;
        imageLoadedCallback();
      }.bind(this);
    }
  },
  imageLoaded: function() {
    try {
      if ($F(this.id + "_ClickY") && $F(this.id + "_ClickX")) {
        this.presetPoint($F(this.id + "_ClickX"), $F(this.id + "_ClickY"));
      }
    } catch (e) {
    }
    try {
      for (var click = 1; click <= this.maxClicks; click++) {
        if ($F(this.id + "_Click_" + click)) {
          var xy = $F(this.id + "_Click_" + click).split(",");
          this.presetPoint(xy[0], xy[1]);
        }
      }
    } catch (e) {
    }
    if (this.showRegions) {
      this.renderRegions();
    }
  },
  renderRegions: function() {
    var options2 = {
      selectable: false,
      enableDescriptions: false,
      style: {}
    };
    var regionContainer = $(this.id + "_Regions");
    regionContainer.setStyle({
      width: $(this.image).getWidth() + "px",
      height: $(this.image).getHeight() + "px"
    });
    QModules.loadModule("QRegion.js");
    var ret = new Qualtrics.RegionEditor(
      $(this.id + "_Regions"),
      null,
      this.regions,
      options2
    );
    if (!window.Raphael || !Raphael.type)
      ret.element.setStyle({ display: "block" });
    ret.render();
  },
  clickdown: function(event) {
    Event.stop(event);
  },
  drawCrossHair: function() {
    var height2 = $(this.image).offsetHeight;
    var width2 = $(this.image).offsetWidth;
    var horiz = QBuilder("div", { id: this.id + "_chh_" + this.clickCounter, className: "chh" }, " ");
    var vert = QBuilder("div", { id: this.id + "_chv_" + this.clickCounter, className: "chv" }, " ");
    $(horiz).setStyle({
      width: width2 + "px",
      top: "0px",
      left: "0px",
      opacity: 0.6
    });
    $(vert).setStyle({
      height: height2 + "px",
      top: "0px",
      left: "0px",
      opacity: 0.6
    });
    $(this.imageContainer).appendChild(horiz);
    $(this.imageContainer).appendChild(vert);
  },
  setPoint: function(event) {
    if (!event)
      event = window.event;
    var pointerX = event.offsetX || event.layerX;
    var pointerY = event.offsetY || event.layerY;
    var element = Event.element(event);
    if (element.id.startsWith(this.id + "_chh")) {
      pointerY = element.offsetTop;
    }
    if (element.id.startsWith(this.id + "_chv")) {
      pointerX = element.offsetLeft;
    }
    var pointID = this.id + "_Point_" + this.clickCounter;
    var realX = pointerX;
    var realY = pointerY;
    this.clickedPoint = this.generatePoint(pointID, realX, realY);
    this.imageContainer.appendChild(this.clickedPoint);
    return [realX, realY];
  },
  generatePoint: function(id, x, y) {
    if (!$(id)) {
      var point = QBuilder("div", { id: id, className: "point" });
      this.imageContainer.appendChild(point);
    } else {
      point = $(id);
    }
    point.setStyle({
      top: y - 2 + "px",
      left: x - 2 + "px"
    });
    point.setAttribute("x", x);
    point.setAttribute("y", y);
    return point;
  },
  presetPoint: function(x, y) {
    var pointID = this.id + "_Point_" + this.clickCounter;
    var xy = this.translateCoordinates(x, y);
    var realX = xy.x;
    var realY = xy.y;
    this.clickedPoint = this.generatePoint(pointID, realX, realY);
    var loc = [realX, realY];
    if (!$(this.id + "_chh_" + this.clickCounter)) {
      this.drawCrossHair();
    }
    new Effect.Morph(this.id + "_chh_" + this.clickCounter, { transition: this.EaseFrom, duration: 0.5, style: { top: loc[1] + "px" } });
    new Effect.Morph(this.id + "_chv_" + this.clickCounter, { transition: this.EaseFrom, duration: 0.5, style: { left: loc[0] + "px" } });
    this.recordClick();
    this.clickCounter = this.clickCounter % this.maxClicks + 1;
    this.clickedPoint = null;
  },
  clickup: function(event) {
    if (!event)
      event = window.event;
    var element = Event.element(event);
    if (this.isValidClick(element)) {
      var loc = this.setPoint(event);
      if (!$(this.id + "_chh_" + this.clickCounter)) {
        this.drawCrossHair();
      }
      new Effect.Morph(this.id + "_chh_" + this.clickCounter, { transition: this.EaseFrom, duration: 0.5, style: { top: loc[1] + "px" } });
      new Effect.Morph(this.id + "_chv_" + this.clickCounter, { transition: this.EaseFrom, duration: 0.5, style: { left: loc[0] + "px" } });
      this.recordClick();
      this.clickCounter = this.clickCounter % this.maxClicks + 1;
      this.clickedPoint = null;
    }
  },
  isValidClick: function(element) {
    var isValid = false;
    if (element == this.image && this._imgWidth && this._imgHeight)
      isValid = true;
    else if (element.id.indexOf("chh") !== -1 || element.id.indexOf("chv") !== -1)
      isValid = true;
    return isValid;
  },
  EaseFrom: function(pos) {
    return Math.pow(pos, 2);
  },
  translateCoordinates: function(x, y, getOriginal) {
    var op = function(a, b) {
      return a * b;
    };
    if (getOriginal) {
      op = function(a, b) {
        return a / b;
      };
    }
    x = Math.round(op(x, this._getRatioX()));
    y = Math.round(op(y, this._getRatioY()));
    return { x: x, y: y };
  },
  /**
   * Get original image width. If the definition is bad and does not have the original,
   * then the displayed width is assumed the original
   */
  _getImgWidth: function() {
    if (!this._imgWidth) {
      return this.image.getWidth();
    }
    return this._imgWidth;
  },
  /**
   * Get original image height. If the definition is bad and does not have the original,
   * then the displayed height is assumed the original
   */
  _getImgHeight: function() {
    if (!this._imgHeight) {
      return this.image.getHeight();
    }
    return this._imgHeight;
  },
  _getRatioX: function() {
    return this.image.getWidth() / this._getImgWidth();
  },
  _getRatioY: function() {
    return this.image.getHeight() / this._getImgHeight();
  },
  recordClick: function() {
    if (this.clickedPoint) {
      var x = this.clickedPoint.getAttribute("x");
      var y = this.clickedPoint.getAttribute("y");
      var xy = this.translateCoordinates(x, y, true);
      x = xy.x;
      y = xy.y;
      try {
        var clickData = $(this.id + "_Click_" + this.clickCounter);
        clickData.value = x + "," + y;
      } catch (e) {
        var clickX = $(this.id + "_ClickX");
        var clickY = $(this.id + "_ClickY");
        clickX.value = x;
        clickY.value = y;
      }
    }
  }
});
var QHotSpot = {
  selectRegion: function(selector, postTagChoiceId) {
    if (selector == "OnOff") {
      if ($(postTagChoiceId).value == 1) {
        $(postTagChoiceId).value = 2;
        $(postTagChoiceId + "-Region").addClassName("Like");
      } else {
        $(postTagChoiceId).value = 1;
        $(postTagChoiceId + "-Region").removeClassName("Like");
      }
    } else if (selector == "LikeDislike") {
      $(postTagChoiceId + "-Region").removeClassName("Like");
      $(postTagChoiceId + "-Region").removeClassName("Dislike");
      if ($(postTagChoiceId).value == 1) {
        $(postTagChoiceId).value = 2;
      } else if ($(postTagChoiceId).value == 2) {
        $(postTagChoiceId).value = 3;
        $(postTagChoiceId + "-Region").addClassName("Like");
      } else {
        $(postTagChoiceId).value = 1;
        $(postTagChoiceId + "-Region").addClassName("Dislike");
      }
    } else {
      console.log("WARNING: HotSpot.tpl::Unknown selector: '+selector+'");
    }
  },
  autoSizeRegions: function(imgId) {
    var img = $(imgId);
    if (img) {
      var hotSpotContainer = img.parentNode;
      if (hotSpotContainer && hotSpotContainer.getAttribute("hotspotwidth")) {
        var originalDimensions = [hotSpotContainer.getAttribute("hotspotwidth"), hotSpotContainer.getAttribute("hotspotheight")];
        var currentDimensions = [img.offsetWidth, img.offsetHeight];
        var ratio = [currentDimensions[0] / originalDimensions[0], currentDimensions[1] / originalDimensions[1]];
        if (ratio[0] != 1 || ratio[1] != 1) {
          var children = $(hotSpotContainer).childElements();
          var regions = [];
          for (var i2 = 0, len2 = children.length; i2 < len2; ++i2) {
            if (children[i2].nodeName == "A") {
              regions.push(children[i2]);
              QHotSpot.adjustRegion(children[i2], ratio);
            }
          }
        }
      }
    }
  },
  adjustRegion: function(regionNode, ratio) {
    $(regionNode).setStyle({ left: regionNode.offsetLeft * ratio[0] + "px", top: regionNode.offsetTop * ratio[1] + "px" });
    var innerInner = $(regionNode).down(".RegionInnerInner");
    if (innerInner) {
      $(innerInner).setStyle({ width: innerInner.offsetWidth * ratio[0] + "px", height: innerInner.offsetHeight * ratio[1] + "px" });
    }
  }
};
var QHotSpot2 = {
  createRegionEditor: function(holderEl, regions, postTag, selector, visibility, size) {
    var options2 = {
      selectable: true,
      enableDescriptions: false,
      onSelect: QHotSpot2.selectRegion,
      style: {}
    };
    if (selector == "OnOff") {
      options2.selectionStates = [
        { fill: "rgb(0, 0, 0)", "fill-opacity": 0, iconSrc: null },
        { fill: "rgb(0%, 100%, 0%)", "fill-opacity": 0.3, iconSrc: null }
      ];
    } else {
      options2.selectionStates = [
        { fill: "rgb(100%, 0%, 0%)", "fill-opacity": 0.3, iconSrc: "/WRQualtricsShared/Graphics/icons/x_trans.png" },
        { fill: "rgb(0, 0, 0)", "fill-opacity": 0, iconSrc: null },
        { fill: "rgb(0%, 100%, 0%)", "fill-opacity": 0.3, iconSrc: "/WRQualtricsShared/Graphics/icons/check_trans.png" }
      ];
    }
    if (visibility == "HiddenUntilHover" || !visibility) {
      options2.style.shape = {
        stroke: "none",
        "stroke-opacity": 0,
        //stupid IE needs this. Apperently stroke "none" means "show it anyway"
        "stroke-width": 0.75,
        fill: "none"
      };
      options2.style.shapeHover = {
        stroke: "#000",
        "stroke-opacity": 1,
        "stroke-width": 1.5
      };
      options2.style.shapeGlowOpacity = 0;
    }
    QModules.loadModule("QRegion.js");
    var ret = new Qualtrics.RegionEditor(
      holderEl,
      null,
      regions,
      options2
    );
    ret.postTag = postTag;
    if (!window.Raphael || !Raphael.type)
      ret.element.setStyle({ display: "block" });
    ret.render();
    var image = $("HotSpot_" + postTag + "_Image");
    if (image.complete) {
      QHotSpot2.renderRegion.defer(postTag, size);
    } else {
      Event.observe(image, "load", QHotSpot2.renderRegion.curry(postTag, size));
    }
    this.readSelectionsFromInputs(ret);
    return ret;
  },
  /** Reads the input fields for the regions and updates the display to reflect the selection. */
  readSelectionsFromInputs: function(editor) {
    var regions = editor.getRegions();
    for (var regionId = 0; regionId < regions.length; ++regionId) {
      var v = +$("QR~" + editor.postTag + "~" + regions[regionId].ChoiceID).value;
      editor.selectRegion(regionId, v - 1);
    }
  },
  renderRegion: function(postTag, originalSize) {
    var re = window.regionEditors[postTag];
    var img = $("HotSpot_" + postTag + "_Image");
    var layout = new Element.Layout(img);
    re.element.setStyle(layout.toCSS());
    re.rescaleRegions(originalSize, { w: layout.get("width"), h: layout.get("height") });
    re.render();
    re.element.setStyle({ display: "block" });
  },
  selectRegion: function(editor, regionId) {
    var choiceId = editor.getRegionProperty(regionId, "ChoiceID");
    $("QR~" + editor.postTag + "~" + choiceId).value = editor.selectedRegions[regionId] + 1;
  }
};
if (Qualtrics.ofcData == void 0)
  Qualtrics.ofcData = {};
if (Qualtrics.ofcImages == void 0)
  Qualtrics.ofcImages = {};
Qualtrics.ofcGetData = function(id) {
  return Qualtrics.ofcData[id];
};
function ofc_ready(chart_id) {
  Element.fire(document, "OFC:ofc_ready_" + chart_id[0]);
}
function ofc_stoped_animating(chart_id) {
  Element.fire(document, "Event:ofc_stoped_animating_" + chart_id[0]);
}
function html5Store(key, item) {
  if ("localStorage" in window && window.localStorage !== null) {
    window.localStorage[key] = Object.toJSON(item);
    return true;
  }
  return false;
}
function html5Retrieve(key, opt_default) {
  var item = opt_default;
  if ("localStorage" in window && window.localStorage !== null && key in window.localStorage)
    item = Qualtrics.parseJSON(window.localStorage[key], true);
  return item;
}
function saveFlashImages(options2) {
  if (!options2)
    options2 = {};
  if (Object.keys(Qualtrics.ofcImages).size() <= 0) {
    if (options2 && options2.onComplete)
      options2.onComplete();
  }
}
function changePagePosition(foreward, pageCount) {
  if (!Qualtrics.currentReportPage) {
    Qualtrics.currentReportPage = 0;
  }
  var curPage = Qualtrics.currentReportPage;
  $("page" + curPage).toggleClassName("visible");
  if (foreward) {
    curPage = curPage < pageCount - 1 ? curPage + 1 : 0;
  } else {
    curPage = curPage > 0 ? curPage - 1 : pageCount - 1;
  }
  $("page" + curPage).toggleClassName("visible");
  $("pageNumberDisplay").update(curPage + 1);
  Qualtrics.currentReportPage = curPage;
}
function addReportNavigator(pageCount) {
  return QBuilder("div", { id: "ReportNavigator" }, [QBuilder("div", {}, [
    QBuilder("a", { className: "qbutton", clickcallback: "changePagePosition", p1: false, p2: pageCount }, [
      QBuilder("span", { className: "icon previous" })
    ]),
    QBuilder("span", { id: "pageNumberDisplay" }, 1),
    QBuilder("a", { className: "qbutton", clickcallback: "changePagePosition", p1: true, p2: pageCount }, [
      QBuilder("span", { className: "icon next" })
    ])
  ])]);
}
FileUploader = {
  prevFileID: "",
  // Have we already uploaded a file with this ID? We may need to overwrite a thumbnail
  buildFileUploadIFrame: function(qID, maxSize) {
    var iframe = Builder.node("iframe", {
      id: "FileUploader",
      scrolling: "no",
      name: "FileUploader",
      frameBorder: 0,
      src: "/WRQualtricsShared/blank.html"
    });
    $(iframe).setStyle({
      width: "0px",
      height: "0px"
    });
    var fileField = QBuilder("input", { id: "fileField", type: "file", size: "48", name: "fileField", autocomplete: "off", qid: qID });
    var form = QBuilder("form", { id: "fileUploadForm", enctype: "multipart/form-data", method: "post", action: URLTools.getAjaxURL("uploadRFile"), target: "FileUploader" }, [
      QBuilder("div", { className: "inputContainer" }, [
        QBuilder("div", { className: "fileInputContainer", id: "fileInputContainer" }, [
          QBuilder("input", { type: "hidden", value: maxSize, name: "MAX_FILE_SIZE" }),
          QBuilder("input", { type: "hidden", value: $("SurveyID").value, name: "SurveyID" }),
          QBuilder("input", { type: "hidden", value: $("SessionID").value, name: "SessionID" }),
          fileField
        ])
      ]),
      QBuilder("input", { type: "hidden", id: "QID", name: "QID", value: qID })
    ]);
    var frameDiv = QBuilder("div", {}, [form, iframe]);
    $("fIFrame~" + qID).contentWindow.document.write(frameDiv.innerHTML);
    $("fIFrame~" + qID).contentWindow.document.body.style.background = "transparent";
    new Form.Element.Observer($("fIFrame~" + qID).contentWindow.document.getElementById("fileField"), 0.2, FileUploader.clearOldAndSubmit);
  },
  clearOldAndSubmit: function(el, value) {
    var qid = el.getAttribute("qid");
    if ($("fileInfo~" + qid))
      $("fileInfo~" + qid).remove();
    $("Filename~" + qid).value = "";
    $("TmpFilepath~" + qid).value = "";
    $("FileType~" + qid).value = "";
    $("Size~" + qid).value = "";
    $("loadingImage~" + qid).show();
    $("loadingError~" + qid).hide();
    $("fileInfoCont~" + qid).hide();
    if (value != "") {
      $("fIFrame~" + qid).contentWindow.document.getElementById("fileUploadForm").submit();
      if (/AppleWebKit|MSIE/.test(navigator.userAgent)) {
        new Ajax.Request("/WRQualtricsShared/blank.html", { asynchronous: false });
      }
    }
  },
  fail: function(qid, errorMsg) {
    $("fileInfoCont~" + qid).hide();
    if ($("fileInfo~" + qid))
      $("fileInfo~" + qid).remove();
    if (errorMsg)
      $("loadingError~" + qid).innerHTML = errorMsg;
    $("loadingImage~" + qid).hide();
    $("loadingError~" + qid).show();
    $("Filename~" + qid).value = "";
    $("TmpFilepath~" + qid).value = "";
    $("FileType~" + qid).value = "";
    $("Size~" + qid).value = "";
  },
  uploadOnload: function(qID, fileData) {
    if (fileData.errors && fileData.errors != "") {
      this.fail(qID, fileData.errors);
      return;
    }
    $("loadingImage~" + qID).hide();
    $("loadingError~" + qID).hide();
    $("Filename~" + qID).value = fileData.origFilename;
    $("TmpFilepath~" + qID).value = fileData.fullpath;
    $("FileType~" + qID).value = fileData.type;
    $("Size~" + qID).value = fileData.size;
    $("fileInfoCont~" + qID).show();
    $("FILE~" + qID).value = fileData.fileId || $("FILE~" + qID).value;
    var fileURL = "/WRQualtricsControlPanel/File.php?F=" + (fileData.fileId || fileData.fullpath) + "&filePreview=true&PrevID=" + this.prevFileID;
    var filePreview = QBuilder("tr", { id: "filePreviewRow~" + qID }, [
      QBuilder("td", { className: "right" }, [
        QBuilder("img", {
          id: "imagePreviewRow~" + qID,
          src: fileURL,
          className: "filePreview",
          onerror: "$(this).hide();"
        })
      ])
    ]);
    var nameInfo = QBuilder("tr", { id: "filenameInfoRow~" + qID }, [
      QBuilder("td", { className: "right" }, fileData.origFilename)
    ]);
    var size = fileData.size;
    var sizeTag = "B";
    if (size > 1024) {
      size /= 1024;
      sizeTag = "KB";
    }
    if (size > 1024) {
      size /= 1024;
      sizeTag = "MB";
    }
    var sizeInfo = QBuilder("tr", { id: "sizeInfoRow~" + qID }, [
      QBuilder("td", { className: "right" }, Math.round(size * 10) / 10 + sizeTag)
    ]);
    var typeInfo = QBuilder("tr", { id: "typeInfoRow~" + qID }, [
      QBuilder("td", { className: "right" }, fileData.type)
    ]);
    var fileInfo = QBuilder("table", { className: "fileInfo", id: "fileInfo~" + qID }, [
      QBuilder("tbody", {}, [
        filePreview,
        nameInfo,
        sizeInfo,
        typeInfo
      ])
    ]);
    $("fileInfoCont~" + qID).appendChild(fileInfo);
  }
};
Qualtrics.objToHideButton = function(o, header) {
  if (!header)
    header = "";
  var showButton = QBuilder("input", {
    type: "button",
    value: "show"
  });
  var hideButton = QBuilder("input", {
    type: "button",
    value: "hide"
  });
  var obj = QBuilder("div", {}, [QBuilder("pre", {}, Qualtrics.objToString(o))]);
  var inner = QBuilder("div", {}, [header, obj, hideButton]);
  $(inner).hide();
  Event.observe(hideButton, "click", function() {
    $(inner).hide();
    showButton.value = "show";
  });
  Event.observe(showButton, "click", function() {
    if (showButton.value == "show") {
      showButton.value = "hide";
      $(inner).show();
    } else {
      showButton.value = "show";
      $(inner).hide();
    }
  });
  var container = QBuilder("div", {}, [showButton, inner]);
  return container;
};
Qualtrics.objToString = function(obj, tab) {
  tab = tab || 0;
  var ret = "";
  if (Object.isArray(obj))
    obj = obj.toObject();
  for (var id in obj) {
    ret += "	".times(tab);
    ret += id + " => ";
    if (typeof obj[id] == "object") {
      ret += "\n";
      ret += Qualtrics.objToString(obj[id], tab + 1);
    } else {
      ret += String(obj[id]);
    }
    ret += "\n";
  }
  return ret;
};
function isNumeric(input) {
  input = input.replace(/,/g, "");
  return input - 0 == input && input.length > 0;
}
Qualtrics.pluralize = function(string) {
  var len2 = string.length;
  var lastChar = string[len2 - 1];
  if (lastChar == "y") {
    return string.substr(0, len2 - 1) + "ies";
  }
  return string + "s";
};
Qualtrics.noop = function() {
};
Qualtrics.isFeatureEnabled = function(feature, callback) {
  new Ajax.CachedRequest(URLTools.getAjaxURL("FeatureIsEnabled"), {
    parameters: { Feature: feature },
    onSuccess: function(resp) {
      var results = resp.responseText.evalJSON();
      callback(results.enabled);
    }
  });
};
Qualtrics.SurveyEngine = {
  /**
   * @property {Object} registry
   * @private
   */
  registry: {},
  /**
   * @method getInstance
   * @param {string} id
   * @private
   */
  getInstance: function(id) {
    return this.registry[id];
  },
  /**
   * @method addOnload
   *	@param {function} f - the function to execute on load
   *
   */
  addOnload: function(f) {
    if ($("body") && $("body").hasClassName("EditSection"))
      return;
    try {
      var obj = new Qualtrics.SurveyEngine.QuestionData();
      obj.onload = f;
      Event.observe(window, "load", obj.onload.bind(obj));
    } catch (e) {
      console.error("SE API Error: " + e);
    }
  },
  /**
   * @method addOnReady
   *	@param {function} f - the function to execute when page is loaded and ready
   *
   */
  addOnReady: function(f) {
    if ($("body") && $("body").hasClassName("EditSection"))
      return;
    try {
      var obj = new Qualtrics.SurveyEngine.QuestionData();
      obj.onload = f;
      Event.observe(window, "load", function() {
        setTimeout(obj.onload.bind(obj), 0);
      });
    } catch (e) {
      console.error("SE API Error: " + e);
    }
  },
  /**
   * @method addOnUnload
   *	@param {function} f - the function to execute when page is unloaded
   *
   */
  addOnUnload: function(f) {
    if ($("body") && $("body").hasClassName("EditSection"))
      return;
    try {
      var obj = new Qualtrics.SurveyEngine.QuestionData();
      obj.onload = f;
      Event.observe(window, "unload", obj.onload.bind(obj));
    } catch (e) {
      console.error("SE API Error: " + e);
    }
  },
  /**
   * Changes the Skin of the Survey to one that is Accessible
   * @method setAccessibleSkin
   * @private
   */
  setAccessibleSkin: function() {
    this.addEmbeddedData("ED~Q_Skin", "Qualtrics|MQ|Accessible");
    window.noSEAutoSave = true;
    submitForm("Page");
  },
  /**
   * Adds embedded data to the page
   * @method addEmbeddedData
   * @param {string} key - the embedded data key
   * @param {string} value - the value of the embedded data
   */
  addEmbeddedData: function(key, value) {
    $("Page").appendChild(QBuilder("input", { type: "hidden", name: key, value: value }));
  },
  /**
   * Sets embedded data to the page, or adds it if the ED key is not on the page already
   * @method setEmbeddedData
   * @param {string} key - the embedded data key
   * @param {string} value - the new value of the embedded data
   */
  setEmbeddedData: function(key, value) {
    var fieldName = "ED~" + key;
    if ($(fieldName)) {
      $(fieldName).value = value;
    } else {
      $("Header").appendChild(QBuilder("input", { type: "hidden", id: fieldName, name: fieldName, value: value }));
    }
  },
  /**
   * Gets embedded data from the page
   * @param {string} key - the embedded data key
   * @return {string} value - the value of the embedded data or null if not found.
   */
  getEmbeddedData: function(key) {
    var fieldName = "ED~" + key;
    if ($(fieldName)) {
      return $(fieldName).value;
    }
  },
  /**
   * The top level keydown event handler
   * @method globalKeyDownHandler
   * @private
   */
  globalKeyDownHandler: function(evt) {
    if (document.body.id == "SurveyEngineBody") {
      if (!evt) {
        evt = window.event;
      }
      var el = Event.element(evt);
      if (el && el.getAttribute)
        Qualtrics.alphaNumericValidation(el, evt);
      var isButton = el.tagName == "BUTTON" || el.tagName == "INPUT" && el.type == "button" || (el.id == "NextButton" || el.id == "PreviousButton");
      if (evt.keyCode == Event.KEY_RETURN && el.tagName != "TEXTAREA" && !isButton) {
        Event.stop(evt);
      }
    }
  },
  /**
   * The top level keyup event handler
   * @method globalKeyUpHandler
   * @private
   */
  globalKeyUpHandler: function(evt) {
    if (!evt) {
      evt = window.event;
    }
    var el = Event.element(evt);
    if (el.getAttribute("validation")) {
      Qualtrics.alphaNumbericInputFilter(evt, el);
    }
  },
  /**
   *	Displays an error message
   *	@method displayErrorMessage
   *	@param {string} msg - the message to be displayed
   */
  displayErrorMessage: function(msg) {
    alert(msg);
  },
  /**
  * Qualtrics.SurveyEngine.navEnter
  * This is responsible for submitting the form which advances them through the survey. This only should be called onkeypress for the nav buttons.
  * It simply checks that the key was enter then calls Qualtrics.SurveyEngine.navClick
  * @method navEnter
  * @param {event} e
  * @param {HTMLElement} el
  * @param {string} [opt_buttonName]
  * @param {boolean} [opt_confirmValidation] - this is true if they have seen the validation message and wish to continue without answering
  * @param {integer} [jumpIndex]
   * @private
  */
  navEnter: function(e, el, opt_buttonName, opt_confirmValidation, jumpIndex) {
    e = e || window.event;
    if (e.keyCode == Event.KEY_RETURN || e.charCode == 32) {
      Qualtrics.SurveyEngine.navClick(el, opt_buttonName, opt_confirmValidation, jumpIndex);
    }
  },
  /**
  * Qualtrics.SurveyEngine.navClick
  * This is responsible for submitting the form which advances them through the survey
  * @method navClick
  * @param {HTMLElement} el
  * @param {string} [opt_buttonName]
  * @param {boolean} [opt_confirmValidation] - this is true if they have seen the validation message and wish to continue without answering
  * @param {integer} [jumpIndex]
   * @private
  */
  navClick: function(el, opt_buttonName, opt_confirmValidation, jumpIndex) {
    var setSubmitting = function(opt_buttonName2, value) {
      if (opt_buttonName2 && $(opt_buttonName2)) {
        $(opt_buttonName2).setAttribute("submitting", value.toString());
      }
    };
    var event = null;
    if (el && !el.nodeName) {
      event = el;
      el = Event.element(el);
    }
    if (el && el.getAttribute && el.getAttribute("confirmed")) {
      opt_confirmValidation = true;
    }
    if (opt_buttonName == "NextButton" || opt_buttonName == "PreviousButton" || opt_buttonName == "JumpButton") {
      window.noSEAutoSave = true;
    }
    if (opt_buttonName == "NextButton" && Qualtrics.SurveyPage && Qualtrics.SurveyPage.getInstance()) {
      var surveyPage = Qualtrics.SurveyPage.getInstance();
      var info = surveyPage.getValidationInfo();
      if (info.frontEndValidation && info.valid == false) {
        if (!opt_confirmValidation && !Qualtrics.SurveyPage.getInstance().validatePage()) {
          if (event) {
            Event.stop(event);
          }
          setSubmitting(opt_buttonName, false);
          return false;
        }
      }
      if (Qualtrics.SurveyPage.getInstance().validate) {
        if (!opt_confirmValidation && !Qualtrics.SurveyPage.getInstance().validate()) {
          if (event) {
            Event.stop(event);
          }
          setSubmitting(opt_buttonName, false);
          return false;
        }
      }
    }
    if (opt_buttonName == "PreviousButton" && Qualtrics.ToC && !$$(".END_OF_SURVEY").length) {
      if (window.Q_Window && !Q_Window.getInstance("ConfirmBackButton")) {
        Qualtrics.SurveyPage.getInstance().confirmBackButton();
        if (event) {
          Event.stop(event);
        }
        setSubmitting(opt_buttonName, false);
        return false;
      }
    }
    if (opt_buttonName == "JumpButton") {
      if (jumpIndex) {
        $("JumpIndex").value = jumpIndex;
      } else if ($("JumpIndex").value == "")
        $("JumpIndex").value = -1;
    }
    if (opt_buttonName && $("buttonPressed")) {
      $("buttonPressed").name = opt_buttonName;
      $("submitPageFeauBTN").click();
    } else if (opt_buttonName && $(opt_buttonName)) {
      if ($(opt_buttonName).getAttribute("submitting") != "true") {
        $(opt_buttonName).setAttribute("confirmed", true);
        setSubmitting(opt_buttonName, true);
        $(opt_buttonName).click();
      }
    }
    try {
      if (el) {
        (function() {
          el.disabled = true;
        }).defer();
        (function() {
          el.disabled = false;
          setSubmitting(opt_buttonName, false);
        }).delay(10);
      }
    } catch (e) {
    }
  },
  restartResponse: function() {
    window.noSEAutoSave = true;
    $("Page").appendChild(QBuilder("input", { hidden: "true", value: "true", name: "RestartResponse" }));
    submitForm("Page");
  }
};
Qualtrics.SurveyEngine.QuestionInfo = {};
Qualtrics.SurveyEngine.QuestionData = Class.create({
  /**
   * The question ID
   * @property {string} questionId
   */
  questionId: this.questionId || null,
  /**
   * The question container
   * @property {HTMLElement} questionContainer
   */
  questionContainer: this.questionContainer || null,
  /**
   * Can be set to a callback function to perform a custom function when any element of the question is clicked. The
   * function will be passed the following parameters:
   * @property {function} questionclick
   * @param {event} event - The click event
   * @param {HTMLElement} element - The element that was clicked
   * @example
   *	this.questionclick = function(event,element){
   *		//for a single answer multiple choice question, the element type will be radio
   *		if (element.type == 'radio')
   *		{
   *			var choiceNum = element.id.split('~')[2];
   *			alert('You clicked on choice '+choiceNum);
   *		}
   *	}
   */
  questionclick: this.questionclick || null,
  /**
   * @class Qualtrics JavaScript Question API
   * @constructor
   * @param {string} [opt_questionId] - the id of the desired question
   */
  initialize: function(opt_questionId) {
    var el = null;
    if (opt_questionId) {
      this.questionContainer = $(opt_questionId);
    }
    if (!this.questionContainer) {
      var d = document.getElementsByTagName("script");
      el = d[d.length - 1];
      this.questionContainer = $(el).up(".QuestionOuter") || $(el).up("question");
    }
    if (this.questionContainer) {
      this.questionId = this.questionContainer.getAttribute("questionid") || this.questionContainer.getAttribute("posttag");
      this.addOnClick();
      Qualtrics.SurveyEngine.registry[this.questionId] = this;
    }
  },
  /**
   * Adds an observer/listener to the click event on the question.  Rather than calling addOnClick directly,
   * this method will be called automatically by the addOnLoad method.  You only need to assign a function to the
   * <a href="#property_questionclick">questionclick</a> property and the Survey Engine will take care of it for you.
   * @method addOnClick
   * @example
   *	Qualtrics.SurveyEngine.addOnload(function ()
   *	{
   *		this.questionclick = function(event,element){
   *			//for a single answer multiple choice question, the element type will be radio
   *			if (element.type == 'radio')
   *			{
   *				var choiceNum = element.id.split('~')[2];
   *				alert('You clicked on choice '+choiceNum);
   *			}
   *		}
   *	});
   */
  addOnClick: function() {
    this.questionclick = function() {
    };
    var that = this;
    Event.observe(this.questionContainer, "click", function(event) {
      that.questionclick(event, Event.element(event));
    }.bind(this));
  },
  /**
   * Sets the disabled attribute to true on the Next Button to disable it
   * @method disableNextButton
   */
  disableNextButton: function() {
    if ($("NextButton"))
      $("NextButton").disabled = true;
  },
  /**
   * Sets the disabled attribute to false on the Next Button to enable it
   * @method enableNextButton
   */
  enableNextButton: function() {
    if ($("NextButton"))
      $("NextButton").disabled = false;
  },
  /**
   * Shows the Next Button
   * @method showNextButton
   */
  showNextButton: function() {
    if ($("NextButton"))
      $("NextButton").show();
  },
  /**
   * Hides the Next Button
   * @method hideNextButton
   */
  hideNextButton: function() {
    if ($("NextButton"))
      $("NextButton").hide();
  },
  /**
   * Emulates a click on the Next Button to submit the page
   * @method clickNextButton
   * @example
   *	//Hides the next button and displays the question
   *	//for 5 seconds before moving to the next page
   *	this.hideNextButton();
   *	var that = this;
   *	(function(){that.clickNextButton();}).delay(5);
   */
  clickNextButton: function() {
    var nextButton = $("NextButton");
    if (nextButton && nextButton.click)
      nextButton.click();
    else if (nextButton && nextButton.onclick)
      nextButton.onclick();
  },
  /**
   * Sets the disabled attribute to true on the Previous Button to disable it
   * @method disablePreviousButton
   */
  disablePreviousButton: function() {
    if ($("PreviousButton"))
      $("PreviousButton").disabled = true;
  },
  /**
   * Sets the disabled attribute to false on the Previous Button to enable it.
   * @method enablePreviousButton
   */
  enablePreviousButton: function() {
    if ($("PreviousButton"))
      $("PreviousButton").disabled = false;
  },
  /**
   * Shows the Previous Button
   * @method showPreviousButton
   */
  showPreviousButton: function() {
    if ($("PreviousButton"))
      $("PreviousButton").show();
  },
  /**
   * Hides the Previous Button
   * @method hidePreviousButton
   */
  hidePreviousButton: function() {
    if ($("PreviousButton"))
      $("PreviousButton").hide();
  },
  /**
   * Emulates a click on the Previous Button to submit the page
   * @method clickPreviousButton
   */
  clickPreviousButton: function() {
    var previousButton = $("PreviousButton");
    if (previousButton && previousButton.click)
      previousButton.click();
    else if (previousButton && previousButton.onclick)
      previousButton.onclick();
  },
  /**
   * Hides the choice container
   * @method hideChoices
   */
  hideChoices: function() {
    var choices = this.getChoiceContainer();
    if ($(choices))
      $(choices).hide();
  },
  /**
   * Returns the div of the question (.QuestionOuter)
   * @method getQuestionContainer
   */
  getQuestionContainer: function() {
    return this.questionContainer;
  },
  /**
   * Gets the div of the question text
   * @method getQuestionTextContainer
   * @example
   *	$$('.QuestionText')
   */
  getQuestionTextContainer: function() {
    return $(this.questionContainer).down(".QuestionText");
  },
  /**
   * Gets the div of the choices
   * @method getChoiceContainer
   * @example
   *	$$('.ChoiceStructure')
   *
   */
  getChoiceContainer: function() {
    return $(this.questionContainer).down(".ChoiceStructure");
  },
  /**
   * Gets the input element according to the choiceId and answerId
   * @method getInput
   * @param {string} choiceId - the id of the desired input's choice
   * @param {string} answerId - the id of the desired input's answer
   * @param {boolean} [opt_returnArray] - set to true if the caller can handle an array return value
   * @return {InputElement|Array} the Input Element, or if opt_returnArray is true, an array of elements (ie matrix single answer questions)
   * @private
   */
  getInput: function(choiceId, answerId, opt_returnArray) {
    var postTag = this.getPostTag() || this.questionId;
    var inputName = "QR~" + postTag + (!choiceId !== null && choiceId !== void 0 ? "~" + choiceId : "");
    var questionType = $("QR~" + postTag + "~QuestionType");
    var questionSelector = $("QR~" + postTag + "~Selector");
    if (questionType && questionType.value === "MC" && questionSelector && (questionSelector.value === "DL" || questionSelector.value === "SB")) {
      inputName = "QR~" + postTag;
    }
    var valueName = inputName + (answerId !== null && answerId !== void 0 ? "~" + answerId : "");
    var input = null;
    if ($(inputName) && $(inputName).id == inputName && ($(inputName).nodeName == "INPUT" || $(inputName).nodeName == "TEXTAREA" || $(inputName).nodeName == "SELECT")) {
      input = $(inputName);
    } else if ($(valueName) && ($(valueName).nodeName == "INPUT" || $(valueName).nodeName == "TEXTAREA" || $(valueName).nodeName == "SELECT")) {
      input = $(valueName);
    } else if ($("Select~" + postTag)) {
      input = $("Select~" + postTag);
    } else if ($(valueName + "~TEXT")) {
      input = $(valueName + "~TEXT");
    } else {
      if ($("Page")[inputName]) {
        var control = $("Page")[inputName];
        if (!control.getAttribute) {
          for (var i2 = 0, ilen = control.length; i2 < ilen; i2++) {
            if (control[i2].value == valueName) {
              input = control[i2];
              return input;
            }
          }
          if (opt_returnArray) {
            return control;
          }
        } else {
          input = control;
        }
      }
    }
    return input;
  },
  /**
   * For javascript to get a timing question's time
   * @return {[type]} [description]
   */
  getCurrentVisualTime: function() {
    try {
      return $("_" + this.questionId + "Timer").getAttribute("time");
    } catch (e) {
    }
    return void 0;
  },
  /**
   * Sets the value of the choice(s) specified by a recode value. Multiple choices in a question may have the same
   * recode value. An attempt will be made to set each choice that is found. For single answer questions this may result
   * in only the last matching choice being set.
   *
   * @method setChoiceValueByRecodeValue
   * @param {string} recodeValue - The recode value of the choice(s) being set
   * @param {string} [subId] - The ID of the Column Answer, etc.
   * @param {string} value - The value being set
   */
  setChoiceValueByRecodeValue: function() {
    var choiceIds = this.getChoicesFromRecodeValue(arguments[0]);
    for (var i2 = 0, ilen = choiceIds.length; i2 < ilen; i2++) {
      var cid = choiceIds[i2];
      if (arguments.length == 3) {
        this.setChoiceAnswerValue(cid, arguments[1], arguments[2]);
      } else {
        this.setChoiceAnswerValue(cid, null, arguments[1]);
      }
    }
  },
  /**
   * Sets the value of the choice(s) specified by a variable name. Multiple choices in a question may have the same
   * variable name. An attempt will be made to set each choice that is found. For single answer questions this may
   * result in only the last matching choice being set.
   *
   * @method setChoiceValueByVariableName
   * @param {string} variableName - The variable name of the choice(s) being set
   * @param {string} [subId] - The ID of the Column Answer, etc.
   * @param {string} value - The value being set
   */
  setChoiceValueByVariableName: function() {
    var choiceIds = this.getChoicesFromVariableName(arguments[0]);
    for (var i2 = 0, ilen = choiceIds.length; i2 < ilen; i2++) {
      var cid = choiceIds[i2];
      if (arguments.length == 3) {
        this.setChoiceAnswerValue(cid, arguments[1], arguments[2]);
      } else {
        this.setChoiceAnswerValue(cid, null, arguments[1]);
      }
    }
  },
  /**
   * Sets the actual value of a choice in the question. If a matrix-style question, also specify the subId (answerId).
   *	@method setChoiceValue
   * @param {string} choiceId - The ID of the choice being set
   * @param {string} [subId] - The ID of the Column Answer, etc.
   * @param {string} value - The value being set
   */
  setChoiceValue: function() {
    if (arguments.length == 3) {
      this.setChoiceAnswerValue(arguments[0], arguments[1], arguments[2]);
    } else {
      this.setChoiceAnswerValue(arguments[0], null, arguments[1]);
    }
  },
  /**
   * Sets the choice answer's value
   * @method setChoiceAnswerValue
   * @param {string} choiceId
   * @param {string} answerId
   * @param {string} value
   * @return true if success, false if failure
   */
  setChoiceAnswerValue: function(choiceId, answerId, value) {
    var input = this.getInput(choiceId, answerId);
    if (input && (input.getAttribute("type") || input.tagName)) {
      var inputType = input.getAttribute("type") || input.tagName;
      switch (inputType) {
        case "checkbox":
        case "radio":
          input.checked = value;
          input.defaultChecked = value;
          var postTag = this.getPostTag() || this.questionId;
          var questionInfo = this.getQuestionInfo();
          if (questionInfo["QuestionType"] == "Matrix") {
            exclusiveAnswerCheck("QR~" + postTag, "QR~" + postTag + "~" + choiceId, answerId);
            exclusiveChoiceCheck("QR~" + postTag, "QR~" + postTag + "~" + choiceId, choiceId, answerId);
          } else if (questionInfo["QuestionType"] == "MC") {
            exclusiveAnswerCheck("QR~" + postTag, "QR~" + postTag, choiceId);
            exclusiveChoiceCheck("QR~" + postTag, "QR~" + postTag, choiceId, choiceId);
          }
          break;
        case "SELECT":
          var postTag = this.getPostTag() || this.questionId;
          var valueName = "QR~" + postTag + "~" + choiceId + (answerId !== null ? "~" + answerId : "");
          for (var i2 = 0, iLen = input.options.length; i2 < iLen; i2++) {
            if (input.options[i2].value == valueName) {
              var questionType = $("QR~" + postTag + "~QuestionType");
              var questionSelector = $("QR~" + postTag + "~Selector");
              if (questionType && questionType.value === "MC" && questionSelector && (questionSelector.value === "DL" || questionSelector.value === "SB")) {
                input.value = input.options[i2].value;
              } else {
                input.options[i2].setAttribute("selected", true);
              }
            }
          }
          break;
        default:
          var postTag = this.getPostTag() || this.questionId;
          var questionType = $("QR~" + postTag + "~QuestionType");
          if (questionType && questionType.value === "Slider") {
            var slider = window["CS_" + postTag];
            var barTag = postTag + "~" + choiceId;
            if (slider && slider.snapToGrid) {
              value = Math.round(value / 100 * slider.gridLines) / slider.gridLines * 100;
            }
            slider.sliders[barTag].setValue(value / 100);
          }
          input.value = value;
          break;
      }
      return true;
    }
    return false;
  },
  /**
   * Gets the actual value of a choice in the question. If a matrix-style question, also specify the subId (answerId).
   * @method getChoiceValue
   * @example
   *	this.getChoiceValue(3); //returns the value of choice 3
   *	this.getChoiceValue(3,2); //returns the value of row choice 3 answer col 2
   * @param {string} choiceId - The ID of the choice
   * @param {string} [subId] - The ID of the Column Answer, etc.
   * @return {string} the value of the choice
   */
  getChoiceValue: function(choiceId, subId) {
    var ret = false;
    var input = this.getInput(choiceId, null, true);
    if (input && input.getAttribute && (input.getAttribute("type") || input.tagName)) {
      var inputType = input.getAttribute("type") || input.tagName;
      switch (inputType) {
        case "checkbox":
        case "radio":
          ret = input.checked;
          break;
        case "SELECT":
          var postTag = this.getPostTag() || this.questionId;
          var valueName = "QR~" + postTag + "~" + choiceId + (subId ? "~" + subId : "");
          ret = input.options[input.selectedIndex].value == valueName;
          break;
        default:
          ret = input.value;
          break;
      }
    } else if (input && input.length) {
      for (var i2 = 0, ilen = input.length; i2 < ilen; i2++) {
        if (input[i2].checked) {
          return input[i2].value;
        }
      }
    }
    return ret;
  },
  /**
   * Gets the value of the input text
   * @method getTextValue
   * @param {string} [opt_choiceId]
   * @return value of the current choice's input
   */
  getTextValue: function(opt_choiceId) {
    var input = null;
    if (opt_choiceId) {
      input = this.getInput(opt_choiceId + "~TEXT", null);
    } else {
      input = this.getInput();
    }
    if (input) {
      return input.value;
    }
  },
  /**
   *
   * @method getChoiceAnswerValue
   * @param {string} choiceId
   * @param {string} answerId
   * @param {string} subId
   * @return {string} value of the choice answer
   */
  getChoiceAnswerValue: function(choiceId, answerId, subId) {
    var ret = null;
    var input = this.getInput(choiceId, answerId);
    if (input && (input.getAttribute("type") || input.tagName)) {
      var inputType = input.getAttribute("type") || input.tagName;
      switch (inputType) {
        case "checkbox":
        case "radio":
          ret = input.checked;
          break;
        case "SELECT":
          var postTag = this.getPostTag() || this.questionId;
          var valueName = "QR~" + postTag + "~" + choiceId + (subId ? "~" + subId : "");
          ret = input.options[input.selectedIndex].value == valueName;
          break;
        default:
          ret = input.value;
          break;
      }
    }
    return ret;
  },
  /**
   * Determines if the question is displayed or hidden
   * @method getQuestionDisplayed
   * @return {boolean} true if displayed
   */
  getQuestionDisplayed: function() {
    var questionIsHidden = this.questionContainer.getAttribute("hiddenbyinpagedisplaylogic") == "true" ? true : false;
    return !questionIsHidden;
  },
  /**
   * Determines if the choice is displayed or hidden
   * @method getChoiceDisplayed
   * @return {boolean} true if displayed
   * @param {string} choiceId
   * @param {string} answerId
   * @param {string} subId
   */
  getChoiceDisplayed: function(choiceId, answerId, subId) {
    var questionIsHidden = this.questionContainer.getAttribute("hiddenbyinpagedisplaylogic") == "true" ? true : false;
    if (questionIsHidden) {
      return false;
    }
    var input = this.getInput(choiceId, answerId);
    if (input) {
      if (subId) {
        if (input.options[subId]) {
          return true;
        }
      } else {
        return true;
      }
    }
    return false;
  },
  /**
   * Returns an object containing information about the question.
   * See <a href="#property_Qualtrics.SurveyEngine.QuestionInfo">Qualtrics.SurveyEngine.QuestionInfo</a>
   *
   * @method getQuestionInfo
   * @return {object | null} QuestionInfo
   */
  getQuestionInfo: function() {
    if (Qualtrics.SurveyEngine && Qualtrics.SurveyEngine.QuestionInfo && Qualtrics.SurveyEngine.QuestionInfo[this.questionId]) {
      return Qualtrics.SurveyEngine.QuestionInfo[this.questionId];
    }
    return null;
  },
  /**
   * Gets the post tag from the current question's QuestionInfo object
   * @method getPostTag
   * @return {string | null}
   */
  getPostTag: function() {
    var questionInfo = this.getQuestionInfo();
    if (questionInfo && questionInfo.postTag) {
      return questionInfo.postTag;
    }
    return null;
  },
  /**
   * Gets the choice's recode value
   * @method getChoiceRecodeValue
   * @param {string} choiceId
   */
  getChoiceRecodeValue: function(choiceId) {
    var questionInfo = this.getQuestionInfo();
    if (questionInfo && questionInfo["Choices"][choiceId]) {
      return questionInfo["Choices"][choiceId]["RecodeValue"];
    }
  },
  getAnswerRecodeValue: function(answerId) {
    var questionInfo = this.getQuestionInfo();
    if (questionInfo && questionInfo["Answers"] && questionInfo["Answers"][answerId]) {
      return questionInfo["Answers"][answerId]["RecodeValue"];
    }
  },
  /**
   * Gets the choice's variable name
   * @method getChoiceVariableName
   * @param {string} choiceId
   */
  getChoiceVariableName: function(choiceId) {
    var questionInfo = this.getQuestionInfo();
    if (questionInfo && questionInfo["Choices"][choiceId]) {
      return questionInfo["Choices"][choiceId]["VariableName"];
    }
  },
  /**
   * Gets the choice ids that have matching variable names
   * @method getChoicesFromVariableName
   * @param {string} varName - The variable name to search for
   * @return {array} choice ids with matching variable name
   */
  getChoicesFromVariableName: function(varName) {
    return this.getChoicesFromQuestionInfo("VariableName", varName);
  },
  /**
   * Gets the choice ids that have matching recode values
   * @method getChoicesFromRecodeValue
   * @param {string} recodeVal
   * @return {array} choice ids with matching recode value
   */
  getChoicesFromRecodeValue: function(recodeVal) {
    return this.getChoicesFromQuestionInfo("RecodeValue", recodeVal);
  },
  /**
   * Gets the choices from the question info
   * @method getChoicesFromQuestionInfo
   * @param {string} type
   * @param {string} val
   * @private
   */
  getChoicesFromQuestionInfo: function(type, val) {
    var choices = [];
    var questionInfo = this.getQuestionInfo();
    if (questionInfo && questionInfo["Choices"]) {
      for (var cid in questionInfo["Choices"]) {
        if (val == questionInfo["Choices"][cid][type]) {
          choices.push(cid);
        }
      }
    }
    return choices;
  },
  /**
   * Gets the choices
   * @method getChoices
   * @return {array}
   */
  getChoices: function() {
    var choices = [];
    var questionInfo = this.getQuestionInfo();
    if (questionInfo && questionInfo["Choices"]) {
      for (var cid in questionInfo["Choices"]) {
        choices.push(cid);
      }
    }
    return choices;
  },
  /**
   * Gets the answer ids for the question.
   * @method getAnswers
   * @return {array}
   */
  getAnswers: function() {
    var answers = [];
    var questionInfo = this.getQuestionInfo();
    if (questionInfo && questionInfo["Answers"]) {
      for (var aid in questionInfo["Answers"]) {
        answers.push(aid);
      }
    }
    return answers;
  },
  /**
   * Gets the selected choices
   * @method getSelectedChoices
   */
  getSelectedChoices: function() {
    var choices = this.getChoices();
    var selectedChoices = [];
    for (var i2 = 0, len2 = choices.length; i2 < len2; ++i2) {
      if (this.getChoiceValue(choices[i2])) {
        selectedChoices.push(choices[i2]);
      }
    }
    return selectedChoices;
  },
  /**
   * Gets the selected answers
   * @method getSelectedAnswers
   */
  getSelectedAnswers: function() {
    var choices = this.getChoices();
    var answers = this.getAnswers();
    var selectedAnswers = {};
    for (var i2 = 0, len2 = choices.length; i2 < len2; ++i2) {
      for (var a = 0, alen = answers.length; a < alen; ++a) {
        if (this.getChoiceAnswerValue(choices[i2], answers[a])) {
          if (!selectedAnswers[answers[a]]) {
            selectedAnswers[answers[a]] = 0;
          }
          selectedAnswers[answers[a]]++;
        }
      }
    }
    return selectedAnswers;
  },
  /**
   * Gets the selected answer's value
   * @method getSelectedAnswerValue
   * @param choiceId
   */
  getSelectedAnswerValue: function(choiceId) {
    var answers = this.getAnswers();
    var choices = this.getChoices();
    var selectedAnswerValue = null;
    for (var a = 0, alen = answers.length; a < alen; ++a) {
      if (this.getChoiceAnswerValue(choiceId, answers[a], answers[a])) {
        if (selectedAnswerValue == null || selectedAnswerValue > answers[a])
          selectedAnswerValue = answers[a];
      }
    }
    return selectedAnswerValue;
  }
});
Qualtrics.SurveyEngine.QuestionData.getInstance = function(questionId) {
  if (Qualtrics.SurveyEngine.registry[questionId]) {
    return Qualtrics.SurveyEngine.registry[questionId];
  }
  return new Qualtrics.SurveyEngine.QuestionData(questionId);
};
Qualtrics.SurveyEngine.OnEndOfSurvey = function() {
  try {
    if (window.top.postMessage && $("SessionID")) {
      var sid = $F("SurveyID");
      var ssid = $F("SessionID");
      window.top.postMessage("closeQSIWindow", "*");
      window.top.postMessage("QualtricsEOS|" + sid + "|" + ssid, "*");
    }
    if (window.parent && window.parent.qualtricsEndOfSurvey) {
      window.parent.qualtricsEndOfSurvey.call(window.parent);
    }
  } catch (e) {
    console.log(e);
  }
};
Qualtrics.SurveyEngine.onPageLoad = function() {
  try {
    if (window.canCheckParent) {
      if (window.parent) {
        if (window.parent.qualtricsPageLoad) {
          window.parent.qualtricsPageLoad.call(window.parent);
        }
      }
    }
  } catch (e) {
  }
};
Qualtrics.SurveyEngine.savePageBeforeUnload = function() {
  if (!window.noSEAutoSave) {
    if (!$("submitPageFeauBTN")) {
      if ($("PreviousButton"))
        $("PreviousButton").disable();
      if ($("NextButton"))
        $("NextButton").disable();
    }
    if ($F("SessionID") != "DummySessionID")
      $("Page").request({
        parameters: {
          SavePageButton: true,
          ReturnSessionMeta: true
        },
        asynchronous: false
      });
    if ($("PreviousButton"))
      (function() {
        $("PreviousButton").disabled = false;
      }).defer(0.1);
    if ($("NextButton"))
      (function() {
        $("NextButton").disabled = false;
      }).defer(0.1);
  }
};
Qualtrics.SurveyEngine.changeLanguage = function() {
  window.noSEAutoSave = true;
  submitForm("Page");
};
Qualtrics.inputClickHelper = function(e) {
  e = e || window.event;
  var el = Event.element(e);
  var kids = el.childNodes;
  var count = 0;
  var inputNode = null;
  if (kids && kids.length) {
    for (i = 0; i < kids.length; i++) {
      if (kids[i].nodeName == "INPUT" && (kids[i].type == "radio" || kids[i].type == "checkbox")) {
        count++;
        inputNode = kids[i];
      }
    }
  }
  if (el.nodeName == "LABEL" || el.nodeName == "INPUT")
    return;
  if (count == 1 && inputNode) {
    inputNode.click();
  }
  if (el.parentNode && el.parentNode.nodeName == "LABEL" && el.parentNode.click && Qualtrics.Browser.IE && Qualtrics.Browser.Version <= 8) {
    el.parentNode.click();
  }
};
Qualtrics.openPageInPDF = function() {
  QModules.loadModule("/WRQualtricsShared/JavaScript/Libraries/QPDFPrinter.js");
  var pages = [QBuilder("div", {}, [$("SurveyEngineBody").cloneNode(true)])];
  QPDFPrinter.print(pages, {
    includeCSS: true,
    orientation: "portrait",
    filename: "surveysummary.pdf",
    usePrintMediaType: true,
    paginate: true,
    background: true,
    margin: "0px",
    marginTop: "50px",
    marginBottom: "50px",
    baseCSS: "width: auto;",
    customCSS: " div.END_OF_SURVEY,div#EndSurveyResponseSummary,.DownloadResponsesPDF { display: none; } .Skin input[type=radio], .Skin input[type=checkbox] { opacity: .3; } .Skin input[type=radio]:checked, .Skin input[type=checkbox]:checked {	opacity: 1;	}	.QuestionOuter { page-break-inside: avoid; page-break-before: auto; }"
  });
};
Qualtrics.syncLabelsAndInputs = function(addEvent) {
  if (!$("SurveyEngineBody") || !$("SurveyEngineBody").hasClassName("CSSV4")) {
    return;
  }
  if (addEvent === void 0)
    addEvent = true;
  Qualtrics.cachedInputs = Qualtrics.cachedInputs || $$('#Questions input[type="radio"], #Questions input[type="checkbox"]');
  Qualtrics.cachedInputs.each(function(input) {
    Qualtrics.cachedLabels = Qualtrics.cachedLabels || {};
    Qualtrics.cachedLabels[input.id] = Qualtrics.cachedLabels[input.id] || $$('label[for="' + input.id + '"]');
    Qualtrics.cachedLabels[input.id].each(function(label) {
      if (!label.hasClassName("offScreen")) {
        if (input.checked)
          label.addClassName("q-checked");
        else
          label.removeClassName("q-checked");
        if (!label.hasClassName("q-radio") && !label.hasClassName("q-checkbox")) {
          if (input.type === "radio") {
            label.addClassName("SingleAnswer");
          } else {
            label.addClassName("MultipleAnswer");
          }
        }
        if (addEvent) {
          input.on("click", function(event, el) {
            var questionOuter = $(el).up(".QuestionOuter");
            if (questionOuter) {
              var qId = questionOuter.id;
              Qualtrics.cachedQuestionInputs = Qualtrics.cachedQuestionInputs || {};
              Qualtrics.cachedQuestionInputs[qId] = Qualtrics.cachedQuestionInputs[qId] || questionOuter.select('input[type="radio"], input[type="checkbox"]');
              Qualtrics.cachedQuestionInputs[qId].each(function(questionInput) {
                Qualtrics.cachedLabels[questionInput.id] = Qualtrics.cachedLabels[questionInput.id] || $$('label[for="' + questionInput.id + '"]');
                Qualtrics.cachedLabels[questionInput.id].each(function(inputLabel) {
                  if (!inputLabel.hasClassName("offScreen")) {
                    if (questionInput.checked && !inputLabel.hasClassName("q-checked")) {
                      inputLabel.addClassName("q-checked");
                    } else if (!questionInput.checked && inputLabel.hasClassName("q-checked")) {
                      inputLabel.removeClassName("q-checked");
                    }
                  }
                });
              });
            }
          });
          input.on("focus", function(event, el) {
            Qualtrics.cachedLabels[el.id] = Qualtrics.cachedLabels[el.id] || $$('label[for="' + el.id + '"]');
            Qualtrics.cachedLabels[el.id].each(function(inputLabel) {
              if (!inputLabel.hasClassName("offScreen")) {
                inputLabel.addClassName("q-focused");
              }
            });
          });
          input.on("blur", function(event, el) {
            Qualtrics.cachedLabels[el.id] = Qualtrics.cachedLabels[el.id] || $$('label[for="' + el.id + '"]');
            Qualtrics.cachedLabels[el.id].each(function(inputLabel) {
              inputLabel.removeClassName("q-focused");
            });
          });
        }
      }
    });
  });
};
Qualtrics.uniformLabelHeight = function() {
  var makeUniform = function($question) {
    var tallest = 0;
    var labels = $question.select("label.SingleAnswer, label.MultipleAnswer");
    labels.each(function(label) {
      if (label.getHeight() > tallest) {
        tallest = label.getHeight();
      }
    });
    labels.each(function(label) {
      var layout = label.getLayout();
      var newHeight = tallest - layout.get("border-box-height");
      newHeight = parseInt(newHeight / 2);
      var paddingTop = layout.get("padding-top") + newHeight;
      var paddingBottom = layout.get("padding-bottom") + newHeight;
      label.setStyle({
        paddingTop: paddingTop + "px",
        paddingBottom: paddingBottom + "px"
      });
    });
  };
  $$(".QuestionOuter.MC .Inner.SAHR, .QuestionOuter.MC .Inner.MAHR, .QuestionOuter.MC .Inner.MACOL, .QuestionOuter.MC .Inner.SACOL").each(function(questionInner) {
    makeUniform(questionInner);
  });
  $$(".QuestionOuter.Matrix .Inner.Profile").each(function(questionInner) {
    makeUniform(questionInner);
  });
  $$(".QuestionOuter.GAP").each(function(questionInner) {
    makeUniform(questionInner);
  });
};
Event.observe(window, "load", function() {
  if ($("SurveyEngineBody")) {
    Event.observe("SurveyEngineBody", "mousedown", Qualtrics.inputClickHelper);
  }
  Qualtrics.syncLabelsAndInputs(true);
  setTimeout(function dirtyWatch() {
    Qualtrics.syncLabelsAndInputs(false);
    setTimeout(dirtyWatch, 200);
  }, 200);
});
Event.observe(document, "keydown", Qualtrics.SurveyEngine.globalKeyDownHandler);
Event.observe(document, "keyup", Qualtrics.SurveyEngine.globalKeyUpHandler);
Qualtrics.SurveyPage = new Class.create();
Qualtrics.SurveyPage.getInstance = function() {
  return Qualtrics.SurveyPage._instance;
};
Qualtrics.SurveyPage.prototype = {
  questions: null,
  initialize: function() {
    Qualtrics.SurveyPage._instance = this;
    this.questions = [];
  },
  /**
  * generate searches the page for survey elements and constructs the javascript model
  */
  generate: function(domNode) {
    var questionsNode = $("Questions");
    if (questionsNode) {
      var questionsChilds = $(questionsNode).childElements();
      for (var i2 = 0, len2 = questionsChilds.length; i2 < len2; ++i2) {
        if (questionsChilds[i2].getAttribute("questionid") !== null) {
          this.questions.push(new Qualtrics.SurveyPage.Question(this, questionsChilds[i2]));
        }
      }
      if (this.hasInPageDisplayLogic) {
        this.setupInPageDisplayLogicEvents();
        this.evaluateInPageDisplayLogic();
      }
    }
  },
  confirmBackButton: function() {
    var winOptions = {
      title: Qualtrics.getMessage("SurveyEngine", "ConfirmNavigation"),
      buttons: [
        {
          id: "ContinueWithoutAnswering",
          click: "Qualtrics.SurveyPage.previousPage()",
          text: Qualtrics.getMessage("SurveyEngine", "DiscardAndGoBack"),
          className: "negative"
        },
        {
          click: "Q_Window.closeWindow(ConfirmBackButton)",
          text: Qualtrics.getMessage("SurveyEngine", "StayOnPage"),
          className: "positive"
        }
      ]
    };
    if (window.parent != window) {
      winOptions.overlayOpacity = 0;
    }
    if (window.Q_Window) {
      var win = new Q_Window("ConfirmBackButton", winOptions);
      win.setContent(QBuilder("div", {}, Qualtrics.getMessage("SurveyEngine", "ConfirmDiscardAnswers")));
    }
  },
  /**
  * opt_questionId {String} opt_questionId - stop validating at this question
  */
  validatePage: function(opt_questionId) {
    var info = this.getValidationInfo();
    if (info && info.valid == false) {
      var title = Qualtrics.getMessage("SurveyEngine", "UnansweredQuestion");
      var answerButton = Qualtrics.getMessage("SurveyEngine", "AnswerQuestion");
      var count = info.invalidQuestionCount + info.invalidRequiredQuestionCount;
      if (count > 1) {
        title = Qualtrics.getMessage("SurveyEngine", "UnansweredQuestions", count);
        answerButton = Qualtrics.getMessage("SurveyEngine", "AnswerQuestions");
      }
      var winOptions = {
        title: title,
        buttons: [
          {
            click: "Q_Window.closeWindow(ValidationConfirm)",
            text: answerButton
          },
          {
            id: "ContinueWithoutAnswering",
            click: "Qualtrics.SurveyPage.nextPage(true)",
            text: Qualtrics.getMessage("SurveyEngine", "ContinueWithoutAnswering")
          }
        ]
      };
      if (window.parent != window) {
        winOptions.overlayOpacity = 0;
      }
      if (window.Q_Window) {
        var win = new Q_Window("ValidationConfirm", winOptions);
        win.setIframeParent(window.parent);
        win.setContent(this.buildValidationMessage(info));
        this.highlightQuestions(info);
      }
      return false;
    }
    return true;
  },
  getValidationInfo: function() {
    var validationInfo = {
      valid: true,
      frontEndValidation: false,
      invalidQuestionCount: 0,
      invalidRequiredQuestionCount: 0,
      invalidQuestions: []
    };
    for (var i2 = 0, len2 = this.questions.length; i2 < len2; ++i2) {
      var q = this.questions[i2];
      if (q.validate() === false) {
        if (q.responseRequired()) {
          validationInfo.invalidRequiredQuestionCount++;
        } else {
          validationInfo.frontEndValidation = true;
          validationInfo.invalidQuestionCount++;
        }
        validationInfo.valid = false;
        validationInfo.invalidQuestions.push(q.questionId);
      }
    }
    return validationInfo;
  },
  buildValidationMessage: function(info) {
    return QBuilder("strong", {}, Qualtrics.getMessage("SurveyEngine", "ContinueQuestion"));
  },
  highlightQuestions: function(validationInfo) {
    if (validationInfo && validationInfo.invalidQuestions) {
      for (var i2 = 0, len2 = validationInfo.invalidQuestions.length; i2 < len2; ++i2) {
        this.highlightQuestion(validationInfo.invalidQuestions[i2]);
      }
    }
  },
  highlightQuestion: function(qid) {
    QualtricsSETools.questionHighlighter();
    if ($(qid)) {
      $(qid).addClassName("Highlight");
    }
  },
  previousPage: function(opt_confirmValidation) {
    if (Q_Window.getInstance("ConfirmBackButton")) {
      Q_Window.getInstance("ConfirmBackButton").busifyButton("ContinueWithoutAnswering");
    }
    Qualtrics.SurveyEngine.navClick(null, "PreviousButton", opt_confirmValidation);
  },
  nextPage: function(opt_confirmValidation) {
    if (Q_Window.getInstance("ValidationConfirm")) {
      Q_Window.getInstance("ValidationConfirm").busifyButton("ContinueWithoutAnswering");
    }
    Qualtrics.SurveyEngine.navClick(null, "NextButton", opt_confirmValidation);
  },
  initInPageDisplayLogic: function() {
    this.hasInPageDisplayLogic = true;
  },
  setupInPageDisplayLogicEvents: function() {
    Event.observe(document, "mouseup", this.evaluateInPageDisplayLogicDefered.bind(this));
    Event.observe(document, "keyup", this.handleKeyUp.bind(this));
  },
  handleKeyUp: function(evt) {
    var el = Event.element(evt);
    if (el.nodeName == "INPUT" || "TEXTAREA") {
      if (this.displayLogicDelay) {
        clearTimeout(this.displayLogicDelay);
      }
      this.displayLogicDelay = window.setTimeout(this.evaluateInPageDisplayLogic.bind(this), 400);
    }
  },
  evaluateInPageDisplayLogicDefered: function() {
    this.evaluateInPageDisplayLogic.bind(this).defer();
  },
  evaluateInPageDisplayLogic: function() {
    for (var i2 = 0, len2 = this.questions.length; i2 < len2; ++i2) {
      if (this.questions[i2].hasInPageDisplayLogic) {
        this.questions[i2].evaluateInPageDisplayLogic();
      }
    }
    document.body.className = document.body.className;
  }
};
Qualtrics.SurveyPage.Question = new Class.create();
Qualtrics.SurveyPage.Question.prototype = {
  questionId: null,
  hasValidation: null,
  surveyPage: null,
  hasInPageDisplayLogic: null,
  initialize: function(surveyPage, domNode) {
    this.surveyPage = surveyPage;
    this.domNode = domNode;
    this.questionId = domNode.getAttribute("questionid");
    this.data = Qualtrics.SurveyEngine.QuestionInfo[this.questionId];
    if (this.data && this.data["Validation"] && this.data["Validation"]["Settings"]) {
      if (this.data["Validation"]["Settings"]["ForceResponse"] == "ON") {
        this.hasValidation = true;
      }
    }
    if (this.data && this.data["InPageDisplayLogic"]) {
      this.hasInPageDisplayLogic = true;
      surveyPage.initInPageDisplayLogic();
    }
  },
  validate: function() {
    if (this.data && this.data["Validation"] && this.data["Validation"]["Settings"] && (this.data["Validation"]["Settings"]["ForceResponse"] == "RequestResponse" || this.data["Validation"]["Settings"]["ForceResponse"] == "ON") && (!this.data["InPageDisplayLogic"] || this.evaluateLogic(this.data["InPageDisplayLogic"]))) {
      if (this["validate" + this.data["QuestionType"]]) {
        return this["validate" + this.data["QuestionType"]]();
      }
    }
    return true;
  },
  responseRequired: function() {
    if (this.data && this.data["Validation"] && this.data["Validation"]["Settings"] && this.data["Validation"]["Settings"]["ForceResponse"] == "ON") {
      return true;
    }
    return false;
  },
  showLocalValidation: function() {
    this.validationErrorClass = true;
    $(this.domNode).addClassName("ValidationErrorHighlight");
  },
  getPosition: function() {
    for (var i2 = 0, len2 = this.surveyPage.questions.length; i2 < len2; ++i2) {
      if (this.surveyPage.questions[i2].questionId == this.questionId) {
        return i2;
      }
    }
  },
  getPrev: function() {
    return this.surveyPage.questions[this.getPosition() - 1];
  },
  getSelectionInfoByTag: function(tag) {
    var parts = tag.split("~");
    if (isNaN(Number(parts[2])) && !this.isCarryForwardChoice(parts[2])) {
      if (parts[2] == "TEXT") {
        return { type: "TextEntry" };
      }
      return false;
    }
    return { type: "Selection", choiceID: parts[2] };
  },
  isCarryForwardChoice: function(choice) {
    if (typeof choice == "string" && choice.match(/^x+[0-9]+$/)) {
      return true;
    }
    return false;
  },
  validateMC: function() {
    var s = this.data["Selector"];
    if (s == "SAVR" || s == "MAVR" || s == "SAHR" || s == "MAHR" || s == "SACOL" || s == "MACOL" || s == "NPS") {
      var inputs = this.domNode.getElementsByTagName("input");
      for (var i2 = 0, len2 = inputs.length; i2 < len2; ++i2) {
        if (inputs[i2]["type"] == "radio" || inputs[i2]["type"] == "checkbox") {
          if (inputs[i2].checked) {
            return true;
          }
        }
      }
      return false;
    } else {
      var selects = this.domNode.getElementsByTagName("select");
      for (var i2 = 0, len2 = selects.length; i2 < len2; ++i2) {
        if (selects[i2].value) {
          return true;
        }
      }
      return false;
    }
    return true;
  },
  validateHL: function() {
    var inputs = this.domNode.getElementsByTagName("input");
    for (var i2 = 0, len2 = inputs.length; i2 < len2; i2++) {
      if (inputs[i2].value == "Selected") {
        return true;
      }
    }
    return false;
  },
  validateTreeSelect: function() {
    var postTag = this.data.postTag;
    if ($("QR~" + postTag + "_PrimaryNodes") && $("QR~" + postTag + "_PrimaryNodes").value == "") {
      return false;
    }
    return true;
  },
  validateMatrix: function() {
    var s = this.data["Selector"];
    var sub = this.data["SubSelector"];
    if (s == "Likert" || s == "Bipolar" || s == "RO" || s == "TE" || s == "Profile") {
      if (sub == "DL") {
        var selects = this.domNode.getElementsByTagName("select");
        for (var i2 = 0, len2 = selects.length; i2 < len2; ++i2) {
          if (!selects[i2].value) {
            return false;
          }
        }
        return true;
      } else {
        var inputs = this.domNode.getElementsByTagName("input");
        var possibleChoiceIDs = {};
        for (var i2 = 0, len2 = inputs.length; i2 < len2; ++i2) {
          var inputHasAnswer = false;
          var selectionInfo = this.getSelectionInfoByTag(inputs[i2].name);
          if (selectionInfo && selectionInfo.choiceID) {
            var choiceID = selectionInfo.choiceID;
            if (inputs[i2]["type"] == "radio" || inputs[i2]["type"] == "checkbox") {
              inputHasAnswer = inputs[i2].checked;
            } else if (inputs[i2]["type"] == "text") {
              inputHasAnswer = inputs[i2].value != "";
            }
            if (possibleChoiceIDs[choiceID] === void 0) {
              possibleChoiceIDs[choiceID] = inputHasAnswer;
            }
            if (inputHasAnswer && !possibleChoiceIDs[choiceID]) {
              possibleChoiceIDs[choiceID] = true;
            }
          }
        }
        for (var id in possibleChoiceIDs) {
          if (!possibleChoiceIDs[id]) {
            return false;
          }
        }
      }
    } else if (s == "MaxDiff") {
      var inputs = this.domNode.getElementsByTagName("input");
      var possibleChoiceIDs = {};
      for (var i2 = 0, len2 = inputs.length; i2 < len2; ++i2) {
        var inputHasAnswer = false;
        var selectionInfo = this.getSelectionInfoByTag(inputs[i2].name);
        if (selectionInfo && selectionInfo.choiceID) {
          var choiceID = selectionInfo.choiceID;
          inputHasAnswer = inputs[i2].checked;
          if (possibleChoiceIDs[choiceID] === void 0) {
            possibleChoiceIDs[choiceID] = inputHasAnswer;
          }
          if (inputHasAnswer && !possibleChoiceIDs[choiceID]) {
            possibleChoiceIDs[choiceID] = true;
          }
        }
      }
      var checkedCount = 0;
      for (var id in possibleChoiceIDs) {
        if (possibleChoiceIDs[id]) {
          checkedCount++;
        }
      }
      var statementCount = Object.keys(this.data.Choices).length;
      var allStatementsAnswered = checkedCount == statementCount;
      return checkedCount == 2 || allStatementsAnswered;
    }
    return true;
  },
  validateTE: function() {
    var s = this.data["Selector"];
    if (s == "FORM") {
      var inputs = this.domNode.getElementsByTagName("textarea");
      var inputs2 = this.domNode.getElementsByTagName("input");
      var inputArray = [];
      for (var i2 = 0; i2 < inputs.length; i2++)
        inputArray.push(inputs[i2]);
      for (i2 = 0; i2 < inputs2.length; i2++)
        inputArray.push(inputs2[i2]);
      inputs = inputArray;
    } else if (s == "ESTB" || s == "ML") {
      inputs = this.domNode.getElementsByTagName("textarea");
    } else {
      inputs = this.domNode.getElementsByTagName("input");
    }
    for (var i2 = 0, len2 = inputs.length; i2 < len2; ++i2) {
      if (inputs[i2]["type"] == "text" || inputs[i2]["type"] == "password" || inputs[i2].tagName == "TEXTAREA") {
        var selectionInfo = this.getSelectionInfoByTag(inputs[i2].name);
        if (selectionInfo.type == "TextEntry" && !inputs[i2].value) {
          return false;
        } else if (selectionInfo.type == "Selection" && !inputs[i2].value) {
          return false;
        }
      }
    }
    return true;
  },
  validateSS: function() {
    return $F($(this.domNode).down("td.QuestionBody input")) != "";
  },
  validateSlider: function() {
    var barId = "CS_" + this.questionId;
    var valid = true;
    if (window[barId]) {
      var csBar = window[barId];
      if (csBar.sliders) {
        valid = true;
        for (var sliderId in csBar.sliders) {
          var slider = csBar.sliders[sliderId];
          if (!slider.activated) {
            var notApplicableInput = $(this.questionId + "~" + slider.choiceId + "~NA");
            if (notApplicableInput && notApplicableInput.checked) {
              continue;
            }
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  },
  evaluateInPageDisplayLogic: function() {
    var result = this.evaluateLogic(this.data["InPageDisplayLogic"]);
    var questionData = Qualtrics.SurveyEngine.QuestionData.getInstance(this.questionId);
    if (result) {
      $(this.domNode).setAttribute("hiddenbyinpagedisplaylogic", false);
      if (questionData) {
        questionData.hiddenByInPageDisplayLogic = false;
      }
      $(this.domNode).removeClassName("IPDLHidden");
      $(this.domNode).setStyle({ visibility: "visible" });
      $("QM~" + questionData.getPostTag() + "~Displayed").value = "1";
    } else {
      $(this.domNode).setAttribute("hiddenbyinpagedisplaylogic", true);
      $(this.domNode).addClassName("IPDLHidden");
      $(this.domNode).setStyle({ visibility: "hidden" });
      if (questionData) {
        questionData.hiddenByInPageDisplayLogic = true;
      }
      $("QM~" + questionData.getPostTag() + "~Displayed").value = "0";
    }
    try {
      if (window.parent.Q && window.parent.Q.EvaluationFrame) {
        var evalFrame = window.parent.Q.EvaluationFrame.getInstance();
        evalFrame && evalFrame.onFormLoad(true);
      } else {
        var iframe = window.parent.document.getElementById("formiframe");
        if (iframe) {
          iframe.height = document.body.clientHeight || document.body.scrollHeight;
        }
      }
    } catch (err) {
    }
  },
  /**
   * Evaluates a boolean expression. NOT COMPLETE!!!
   * It can only do very basic question choiceId/answerId selects
   **/
  evaluateLogic: function(logic) {
    var exprStr = "";
    var result = false;
    var predicateCount = 0;
    for (var expressionSetIndex in logic) {
      var exprSetStr = "";
      if (!isNaN(expressionSetIndex)) {
        for (var expressionIndex in logic[expressionSetIndex]) {
          if (!isNaN(expressionIndex)) {
            var ex = logic[expressionSetIndex][expressionIndex];
            if (ex["LogicType"] == "Question") {
              var locData = Qualtrics.Logic.getDataFromLocator(ex["ChoiceLocator"]);
              if (locData["questionId"]) {
                var questionData = Qualtrics.SurveyEngine.QuestionData.getInstance(locData["questionId"], false);
                if (questionData && questionData.questionId) {
                  if (!questionData.hiddenByInPageDisplayLogic) {
                    if (ex["Operator"] == "Selected" || ex["Operator"] == "NotSelected") {
                      var condition = ex["Operator"] == "Selected" ? true : false;
                      if (locData["choiceId"]) {
                        if (locData["answerId"]) {
                          result = questionData.getChoiceAnswerValue(locData["choiceId"], locData["answerId"]) == condition;
                          exprSetStr = this.extendExpr(exprSetStr, result, ex["Conjuction"]);
                        } else {
                          result = questionData.getChoiceValue(locData["choiceId"]) == condition;
                          exprSetStr = this.extendExpr(exprSetStr, result, ex["Conjuction"]);
                        }
                      } else if (locData["answerId"]) {
                        var selectedAnswers = Object.keys(questionData.getSelectedAnswers());
                        var result = false;
                        for (var i2 = 0, len2 = selectedAnswers.length; i2 < len2; ++i2) {
                          if (selectedAnswers[i2] == locData["answerId"]) {
                            result = condition;
                            break;
                          }
                        }
                        exprSetStr = this.extendExpr(exprSetStr, result, ex["Conjuction"]);
                      }
                    } else if (ex["Operator"] == "Displayed" || ex["Operator"] == "NotDisplayed") {
                      var condition = ex["Operator"] == "Displayed" ? true : false;
                      if (locData["choiceId"]) {
                        result = questionData.getChoiceDisplayed(locData["choiceId"], locData["answerId"]) == condition;
                        exprSetStr = this.extendExpr(exprSetStr, result, ex["Conjuction"]);
                      } else {
                        result = questionData.getQuestionDisplayed() == condition;
                        exprSetStr = this.extendExpr(exprSetStr, result, ex["Conjuction"]);
                      }
                    } else {
                      if (locData.type == "SelectedChoicesCount") {
                        var selectedChoices = questionData.getSelectedChoices();
                        result = this.evaluateExpression(selectedChoices.length, ex["Operator"], ex["RightOperand"]);
                        exprSetStr = this.extendExpr(exprSetStr, result, ex["Conjuction"]);
                      } else if (locData.type == "SelectedAnswerCount") {
                        var selectedAnswers = questionData.getSelectedAnswers();
                        result = this.evaluateExpression(selectedAnswers[locData["answerId"]], ex["Operator"], ex["RightOperand"]);
                        exprSetStr = this.extendExpr(exprSetStr, result, ex["Conjuction"]);
                      } else if (locData.type == "SelectedAnswerRecode") {
                        var selectedAnswer = questionData.getSelectedAnswerValue(locData["choiceId"]);
                        var selectedAnswerRecode = questionData.getAnswerRecodeValue(selectedAnswer);
                        result = this.evaluateExpression(selectedAnswerRecode, ex["Operator"], ex["RightOperand"]);
                        exprSetStr = this.extendExpr(exprSetStr, result, ex["Conjuction"]);
                      } else if (locData.type == "ChoiceTextEntryValue") {
                        var val = questionData.getTextValue(locData.choiceId);
                        var rightOperand = ex["RightOperand"];
                        if (locData.choiceId && val !== "" && !questionData.getChoiceValue(locData.choiceId)) {
                          return false;
                        } else {
                          if ((ex["Operator"] == "EqualTo" || ex["Operator"] == "NotEqualTo" || ex["Operator"] == "Contains" || ex["Operator"] == "DoesNotContain") && ex["IgnoreCase"] && ex["IgnoreCase"] == 1) {
                            val = val.toLowerCase();
                            rightOperand = rightOperand.toLowerCase();
                          }
                          result = this.evaluateExpression(val, ex["Operator"], rightOperand);
                        }
                        exprSetStr = this.extendExpr(exprSetStr, result, ex["Conjuction"]);
                      } else if (locData.type == "ChoiceNumericEntryValue") {
                        var choiceVal = questionData.getChoiceValue(locData["choiceId"]);
                        if (!choiceVal) {
                          choiceVal = questionData.getSelectedAnswerValue(locData["choiceId"]);
                        }
                        result = this.evaluateExpression(choiceVal, ex["Operator"], ex["RightOperand"]);
                        exprSetStr = this.extendExpr(exprSetStr, result, ex["Conjuction"]);
                      } else if (locData.type == "IsDetractor" || locData.type == "IsPassive" || locData.type == "IsPromoter") {
                        var choiceVal = questionData.getSelectedChoices();
                        if (choiceVal && choiceVal.length == 1) {
                          result = parseInt(choiceVal[0], 10);
                          if (locData.type == "IsDetractor") {
                            result = result < 7 ? 1 : 0;
                          } else if (locData.type == "IsPassive") {
                            result = result >= 7 && result <= 8 ? 1 : 0;
                          } else {
                            result = result > 8 ? 1 : 0;
                          }
                          var resultMatches = this.evaluateExpression(result, ex["Operator"], ex["RightOperand"]);
                          exprSetStr = this.extendExpr(exprSetStr, resultMatches, ex["Conjuction"]);
                        }
                      } else {
                        console.log("Unknown locData type", locData.type);
                      }
                    }
                  } else {
                    exprSetStr = this.extendExpr(exprSetStr, false, ex["Conjuction"]);
                  }
                } else {
                  var that = this;
                  if ($F("SessionID") == "DummySessionID") {
                    result = false;
                    if (ex["Operator"] == "NotDisplayed" || ex["Operator"] == "NotSelected") {
                      result = true;
                    } else if (ex["Operator"] == "Displayed" || ex["Operator"] == "Selected") {
                      result = false;
                    } else {
                      result = this.evaluateExpression("", ex["Operator"], ex["RightOperand"]);
                    }
                    exprSetStr = that.extendExpr(exprSetStr, result, ex["Conjuction"]);
                  } else {
                    new Ajax.CachedRequest("/SE/Ajax.php?action=EvalDisplayLogicExpression", {
                      asynchronous: false,
                      parameters: {
                        SurveyID: $F("SurveyID"),
                        SessionID: $F("SessionID"),
                        Preview: $("Preview") ? $F("Preview") : null,
                        Expression: Object.toJSON(ex)
                      },
                      onComplete: function(transport2) {
                        var json = Qualtrics.parseJSON(transport2.responseText);
                        result = json["Error"] ? false : !!json;
                        exprSetStr = that.extendExpr(exprSetStr, result, ex["Conjuction"]);
                      }
                    });
                  }
                }
              }
            }
            predicateCount++;
          }
        }
      }
      if (exprSetStr.length) {
        exprStr = this.extendExpr(exprStr, "(" + exprSetStr + ")", logic[expressionSetIndex]["Type"]);
      }
    }
    if (predicateCount > 0 && exprStr.length > 0) {
      var compiledExpr = new Function("return " + exprStr);
      result = compiledExpr();
    } else {
      result = false;
    }
    return result;
  },
  evaluateExpression: function(left2, op, right) {
    switch (op) {
      case "EqualTo": {
        return left2 == right;
      }
      case "NotEqualTo": {
        return left2 != right;
      }
      case "GreaterThan": {
        return Number(left2) > Number(right);
      }
      case "GreaterThanOrEqual": {
        return Number(left2) >= Number(right);
      }
      case "LessThan": {
        return Number(left2) < Number(right);
      }
      case "LessThanOrEqual": {
        return Number(left2) <= Number(right);
      }
      case "Empty": {
        return left2 == "" || left2 == null;
      }
      case "NotEmpty": {
        return left2 != "" && left2 != null;
      }
      case "Contains": {
        return String(left2).indexOf(right) != -1;
      }
      case "DoesNotContain": {
        return String(left2).indexOf(right) == -1;
      }
      case "MatchesRegex": {
        var regex = right;
        var regexmatch = /^\/(.*)\/([gim]*)/;
        regex.match(regexmatch);
        var val = "";
        if (RegExp.$1) {
          return String(left2).match(new RegExp(RegExp.$1, RegExp.$2));
        } else {
          return String(left2).match(new RegExp(regex));
        }
      }
    }
    return false;
  },
  extendExpr: function(exprStr, condition, op) {
    if (exprStr.length) {
      if (op == "And" || op == "AndIf")
        exprStr += "&&";
      else if (op == "Or" || op == "OrIf" || op == "ElseIf")
        exprStr += "||";
    }
    if (typeof condition == "string") {
      exprStr += condition;
    } else {
      if (condition)
        exprStr += "true";
      else
        exprStr += "false";
    }
    return exprStr;
  }
};
Qualtrics.Logic = {
  /**
  * Qualtrics.Logic.getDataFromLocator:
  * This is the same function that is used for Skip logic and Branching logic (Q_GlobalLogic.getDataFromLocator)
  * It is copied here for safety. I don't want future changes to it affecting the survey engine.
  * returns an object with properties parsed from the locator
  * @param {String} locator - the system locator eg. q://QID1/SelectableChoice/1
  * @returns {Object} - the same data in a nice object that is usable eg. {type:'SelectableChoice, choiceId:1}
  */
  getDataFromLocator: function(locator) {
    var data = {};
    var aggregate = false;
    if (locator) {
      var parts = locator.split("/");
      data.type = parts[3];
      if (locator.startsWith("qo://")) {
        data.quotaId = parts[2];
        var queryIndex = locator.indexOf("?");
        if (queryIndex != -1) {
          var queryParam = locator.substr(queryIndex + 1);
          var queryParts = queryParam.split("=");
          if (queryParts[0] == "SV")
            data.surveyId = queryParts[1];
        }
      } else {
        data.questionId = parts[2];
        if (data.questionId && data.questionId.indexOf("#") != -1) {
          var questionParts = data.questionId.split("#");
          data.questionId = questionParts[0];
          data.aggregateId = questionParts[1];
          aggregate = true;
        }
        if (parts[4] == "Group") {
          data.choiceId = parts[5];
          data.answerIndex = parts[6];
          data.subType = "Group";
        } else if (parts[4] == "Rank") {
          data.choiceId = parts[5];
          data.subType = "Rank";
        } else {
          if (data.type == "DisplayableQuestion") {
            return data;
          } else if (data.type == "SelectableAnswer" || data.type == "SelectedAnswerCount" || data.type == "SelectedChoicesCount") {
            data.answerId = parts[4];
          } else if (data.type == "Region") {
            data.regionId = parts[4];
          } else {
            data.choiceId = parts[4];
          }
          if (parts.length > 5) {
            data.answerId = parts[5];
          }
        }
        if (aggregate) {
          if (data.type == "SelectableAnswer" || data.type == "SelectedAnswerCount" || data.type == "SelectedChoicesCount") {
            data.answerSeriesIndex = parts[4];
          } else {
            data.choiceId = parts[4];
            data.answerSeriesIndex = parts[5];
            data.answerId = data.aggregateId;
          }
          if (data.answerSeriesIndex !== void 0) {
            data.answerSeriesIndex--;
          }
        }
      }
    }
    return data;
  }
};
Event.observe(window, "load", function() {
  new Qualtrics.SurveyPage().generate();
});
